<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023 ICPC 南京站游记 with ZhangCW &amp; skytyf</title>
      <link href="/2023/11/07/Other/Journey-2023ICPCNanjing/"/>
      <url>/2023/11/07/Other/Journey-2023ICPCNanjing/</url>
      
        <content type="html"><![CDATA[<p>省流：过程很刺激，最后还是拿到队伍第一块 Au了</p><a id="more"></a><p><img src="https://pic4.zhimg.com/80/v2-9d541df5715662b53f406342fa7ed9b5_1440w.jpg" alt="img"></p><p>队名是“月间天路”，取了我名字中的“lu”，tyf 名字中的“tian”和 zcw 网名中的“月”再作了一些美化得到了一个还算比较文艺的名字。的朋友交流了一下，他们也觉得键盘的手感有些偏硬，不过总体的体验还是非常不错的，尤其是中文题面，做题体验极度舒适。</p><p>正式赛当天早上，刚从酒店里出来突然发现噩耗——回哈尔滨的航班取消了。不过感觉大伙都没怎么受影响，更加关注的还是下午的比赛。</p><p>开场按照队伍惯例，我首先去看了 A，一开始并没有太多思路，马上 tyf 发现 I 是一个签到题马上上机写掉了，我跟榜开了 G 题然后发现使用免费的一定是最贵的几个元素，于是就很好写了，之后 zcw 上机准备 CM 连写，结果 M 写了一半我发现我把 F 的题意看错了，其实是个傻逼题，中途让我上机写掉了，因为初始化的时候把 $m$ 打成了 $n$ 导致 wa 了一发（如果不是 tyf 指出来可能一时半会还没法发现）。在 zcw 写 M 的期间我发现 L 是个简单题，A 每个连通块是否是答案一定是一样的（不过听原神哥说可以 bitset 相对简单解决）。tyf 之后还发现 zcw 的 M 里把下标当最小值用了，调完 M 之后我把 L 和 A 连着写了，这两题在各 wa 了一两发之后也都过了（甚至 L 也是 tyf 发现的叉点）之后在还剩 1 个小时多一点的时候我们开始写了 D。此时此刻，恰如彼时彼刻，西安站的时候我们也是在差不多这个时间点开始写了 A，同样是交给队内数据结构大爹 zcw 写的数据结构题，的只不过与那次不同的是其实我们在通过第七题的那一刻就已经过了金牌线了（但是显然考场上的我们并不知道）。</p><p><img src="https://picx.zhimg.com/80/v2-ecd023f3dc6a992dea5de65300f389ed_1440w.png" alt="img"></p><blockquote><p>三个人的比赛，五个人的急（图是在刚封榜时的去年老队友群）</p></blockquote><p>在 zcw 写到一半，刚刚封榜的时候，我们在赛场上有大概这么一段话：</p><p>tyf：我们封榜前是rk23，去掉打星队是rk17，应该过这道题就能稳金了吧。</p><p>我：说不定现在就有金了。</p><p>我：昨日不会再次重现的吧。</p><p>结果最后还是重现了。</p><p>虽然 qzh 说我们稳金了，不过等滚榜的时候大家还是都很急，tyf 在不停的找人问有没有偷跑金线，到滚榜滚到7题的时候 zcw 甚至每看到一个队没过题就大喊一声“好死！”，引得周围人纷纷侧目。</p><p><img src="https://pic1.zhimg.com/80/v2-966c91abda7a76c7fa5f6ae8c186fcf7_1440w.png" alt="img"></p><p>最后滚到金线的时候 tyf 跑去找别的好位置了，于是滚到金线的一瞬间我和 zcw 直接抱在了一起。</p><p><img src="https://picx.zhimg.com/80/v2-9bc0d8ad55b62a19a761b21efd720c41_1440w.png" alt="img"></p><blockquote><p>虽然 Sooke 当时已经离场了，但是他的消息刚好在我拿出手机的时候非常适时地出现了</p></blockquote><p>总体而言打的体验还是非常舒适的，很高的题目质量，非常舒适的场地安排，还有作为纪念品的小袋鼠，感觉是我从 OI 生涯到 ACM 生涯打的最舒适的一场比赛了，如果明年还能来的话我们大概也会再次选择南京站的吧。</p><p>有很多人想要感谢。</p><p>想要感谢我的队友阿玮和甜甜；</p><p>想要感谢摇人队的千姐和lqr；</p><p>想要感谢陪我续了266天大火花的焜宝；</p><p>想要感谢勤人节的大家；</p><p>……</p><p>“我真的好想好想哭”。</p><p>回哈尔滨的航班因为大雪取消了，我们拖到了现在（11月7号）才得以坐绿皮火车回去。</p><p>如果有时间可能会把这部分的故事也写一下？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「火锅旅梦」 with. dyxg &amp; Sooke</title>
      <link href="/2023/08/16/Other/Journey-Chongqing/"/>
      <url>/2023/08/16/Other/Journey-Chongqing/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-n"><a href="#Day-n" class="headerlink" title="Day -n"></a>Day -n</h2><p>在暑假的初期，突发奇想，准备和自己的好兄弟们来一场去年没能完成的旅行。</p><a id="more"></a><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>鸽了下午的多校，坐飞机来重庆。</p><p>结果一下飞机直接传出噩耗：</p><blockquote><p>下午 3:15</p><p>dyxg：延误了！</p><p>下午 5:58</p><p>我（刚下飞机）：/惊恐</p></blockquote><p>（ps：在我回这一句的时候，他们的飞机甚至还没开始登机，直到8点才起飞）</p><p>重庆的路确实非常的 错落有致 不愧是山城，有一种会让人走迷路的美。</p><p>到酒店之后。</p><p>Sooke：酒店两张床，怎么分床位？</p><p>我：我睡这张床，Sooke 你想和谁睡还是自己睡？</p><p>Sooke：我们旅游这么几天，也就 $\binom{3}{2}$ 种可能！</p><p>Sooke：……有没有一种可能，有 $\binom{4}{2}$ 种可能！</p><p>我：有没有一种可能，因为有两张床，所以是 $\frac{\binom{4}{2}}{2}$ 种可能！</p><p>dyxg: 让纳尔和我睡！</p><p>Sooke：不行！纳尔和我是捆绑的！！</p><p>最终我们决出了一个优秀的方案：第一天喝酒的和没喝酒的分开来睡，然后之后每天轮换。</p><p>雀食河鲤！</p><p>办完入住陪 dyxg 和 Sooke 出去 吃了串串。</p><p>Sooke：如果我们把重庆画成一个平面图，他肯定会有一堆的 n (n $\ge$ 7) 边形！</p><p>dyxg：有没有一种可能，由于立交桥的存在，重庆不能被画成一个平面图？</p><p>Sooke：那我们就画他的投影！</p><p>有一说一，重庆吃串串确实相对而言比较便宜。</p><p>dyxg 喝了两瓶啤酒，在睡觉前疯狂对着自己的 npy 在 QQ 上发癫，甚至因为手机没电了有一段用的是我的手机。</p><p><del>我：（因为和 dyxg 打赌输了）今天我陪喝醉的 dyxg 睡觉</del></p><p><del>czz ： ？？？</del></p><p>我还喝了三瓶，怎么感觉我比他还清醒？</p><p><del>甚至，有没有一种可能，滴酒没沾的 Sooke 才是三个人里最不清醒的！</del></p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>早上，一起床，发现已经是 12 点了。</p><p>在一番的思想斗争之后，我们终于去吃了午饭 —— 最后吃的主食是辣子鸡和毛血旺。</p><p>量比想象的大特别多，最后成功的没有吃完。</p><p>本来想直奔长江索道的，结果因为实在太热，一致决定回酒店打雀魂。打完一把之后我和 Sooke 直接躺床上开睡，结果一觉睡到了 6 点半。</p><p>但是因为午饭吃的比较晚，本来是想先去长江索道再吃晚饭的，结果当时长江索道的票甚至已经卖光了（当时晚上 7 点，据后来的出租车司机大哥描述，甚至有的时候 5 点就会卖完拿，过于变态了）。</p><p>因为去不成索道了，然后我们把本来准备 Day 3 去的弹子石老街提前到今天。在那边的晚饭终于来了一顿正经的火锅。</p><p>Sooke：如果爆发核战争的话，重庆肯定非常安全！</p><p>我：为啥？因为在盆地里？</p><p>dyxg：你就这么想，别的国家丢核弹炸重庆显然不如炸别的城市吧，他们炸重庆有什么特殊用处吗？</p><p>我：为了让全中国人没重庆火锅吃！</p><p>只可惜去老街的时候比较晚，那边的商贩大多数都已经打烊了，本来想喝霸王茶姬的，结果打烊了，于是我们跑去隔壁的 DQ，结果也打烊了，最终认为：不如回酒店点外卖。</p><p>那家火锅店还卖奶茶，Sooke 对那边 「鸭屎香」 的奶茶非常的中意，甚至想回去再买一杯，也不知道会不会再有机会去呢。</p><p>ps：dyxg 为了让 czz 不吃四，不择手段地打压 Sooke，以致于打完麻将Sooke道心破碎了。</p><p>ps2：虽然我拿了一场 rk1 和两场 rk2，但是这场麻将只有 dyxg 赢了，因为我也吃了满嘴的狗粮。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>因为 12 点要打多校，所以早上大概 10 点半起了个小早去吃早中饭。</p><p>吃的是昨天的出租车司机老哥推荐的一家美蛙鱼头，只可惜时间比较紧，所以最后没能够吃完。</p><p>下午的多校我打的依托答辩。1011 各种猜结论，最后终于（甚至在 Sooke 的某种帮助下）猜对了</p><p>ps：「某种帮助」指的是：Sooke 在过 1011 的时候大喊出了我正在试图证明的结论。</p><p>晚上坐了半个小时地铁去吃了某家在巷子里的苍蝇馆子火锅，也是昨天的司机老哥推荐的，好吃是真的好吃，辣也是真的辣，只可惜……他的空调一点都不管用，我们三个在那里被热了个半死。</p><p>吃完饭本来想去昨天没能去成的洪崖洞，结果人一到那里直接就被人潮淹没了。</p><p>虽然说我们本来也就只想找一个外围的地方大概看一下洪崖洞的全貌，但是我们是真的完全没有想到人竟然多到了那种程度。</p><p>我：你看那边那座桥，我盲猜那边风景应该不错，咱跑过去看两眼再润。</p><p>dyxg：那边能走人吗？</p><p>我：我刚才看到上面有人了！</p><p>（经过了10分钟的人挤人，我们终于挤到了那座大桥的桥头）</p><p>于是我看到了又一队拥挤的人流，缓缓地朝着大桥的方向蠕动过去。</p><p>在回去的路上，dyxg 提出了非常关键的一个问题。</p><p>dyxg：有没有一种可能，既然你能一眼看出来那座桥上角度不错，那么显然能看出来的远不止你一个人，那么那座桥上就必定会人多？</p><p>我：好有道理……</p><p>Sooke 也提出了关键的理论。</p><p>Sooke：有没有一种可能，我们在坐地铁回去的路上就会经过那座桥的底下？</p><p>我：无法反驳……</p><p>在经过了这么长途的跋涉之后，我们也没精力继续玩了，于是滚回酒店打雀魂去了。</p><p>期间 czz 和了一个三暗刻。</p><p>我，dyxg，Sooke：？（怎么这么大？）</p><p>czz：？？？？（怎么这么大？？？？）</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>虽然今天也要打多校，但是我们还是放弃了早起去吃饭，点了一家重庆小面的外卖。</p><blockquote><p>11：30。</p><p>dyxg：卧槽！我tm忘记定闹钟了。</p><p>我：（迷迷糊糊）辣窝闷中饭肿莫办？</p><p>dyxg：点外卖呗。</p><p>11：40。</p><p>Sooke：起床！打多校了！</p><p>我：50分再起。</p><p>我：还有 10分钟可以睡。</p><p>11：50。</p><p>我：再睡5分钟……</p></blockquote><p>最终我在11：57拿起了电脑，迷迷糊糊地打开了牛客。</p><p>还好今天 zcw 血妈 C。</p><p>因为不会 python 胡出来的难题丢给队友写，我自己写了一道打表题之后开始躺在床上睡大觉！直接当带战犯！</p><p>以及，得告诫某位天天对着芳乃发电的，喜欢喝不加糖绿豆汤的虾头楠：慎用 python 的 (int)。</p><p>打完多校去八一美食街吃晚饭，东西是很不错，只是排队的时间比吃饭的时间还长——而且还要反复排队。</p><p>而且位置巨难抢，我们在随机游走了将近 10 分钟才终于等到一个空位。</p><p>吃完晚饭我们直奔了长江索道。因为有预约所以排队的时间没有长到完全难以接受，但是说实话，一个缆车里边的人实在太多了，导致很难看到外边，而且简直就和挤地铁一样……</p><p>Sooke：那些被挤到缆车最里边的的人怎么办？</p><p>我：如果是我，我会直接日你妈退钱！</p><p>然后就打车去了涂鸦一条街。</p><p>我：这条街就挨着川美，我们可以在川美外头看两眼。</p><p>dyxg：（突然兴奋）川美！</p><p>走了一段路之后。</p><p>dyxg：你看前面那个大门是不是川美的门。</p><p>我：不知道这个时间点还能不能进去参观。</p><p>dyxg：你在想屁吃。</p><p>我：这个时间点，如果是我校，你大概可以看到一群广场舞大妈在图书馆前跳广场舞。</p><p>ps：当时是晚上9点钟。</p><p>结果走进一看，门口赫然写着「XX高等专科学校」。</p><p>dyxg：为什么离川美这么近的地方会有个带专啊！川美附属带专吗。</p><p>我：怎么可能，你看那是个电力相关的学校。</p><p>涂鸦一条街上的涂鸦全是字，而且以人名居多——而且绝大多数是流量明星的名字。</p><p>甚至某个路灯上赫然写着四个大字「我爱四川」，不知道是写的人地理没学好还是真的想在重庆表达自己对四川的热爱。</p><p>我：是不是有一种可能，一个明星的粉丝群体的素质和在涂鸦墙上的字体大小和出现频率成反比？</p><p>话音刚落，我就看到前面写着一行大字，后边忘了，总之有一个前缀是「ZXY」。</p><p>我：（转头看向 dyxg）。</p><p>甚至还有个涂鸦写着 「ST.」后面画了一只小熊维尼。</p><p>回酒店之后我莫名感到很累，于是躺在床上小睡一会儿。</p><p>我：（打呼噜）</p><p>dyxg：你睡着了吗？</p><p>我：（突然清醒）没有！</p><p>之后 Sooke 提议要去吃烤鱼当夜宵，于是我们在凌晨 12 点半左右出发了。</p><p>我：这家烤鱼挺好吃的，为啥没啥人呢？</p><p>dyxg：你要不看看现在几点？</p><p>现在我们刚刚吃完烤鱼回到酒店，但是可惜的是由于 czz 要睡觉今天的睡前雀魂环节被取消了，变成了 Sooke 单排，dyxg 云顶，而我在写游记。</p><p>ps. 在我写游记的时候 Sooke 因为没打过挂机的机器人红温了。</p><p>ps2. 在我写上面那段话的时候 Sooke 点炮了，然后进入了红温之后的沉默不语环节。</p><p>ps3. 在我写 ps2 的时候，dyxg 突然兴奋大喊：吃鸡吃鸡！</p><p>看来人类的悲欢并不相通啊。</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>要走了，还是有点惆怅的啊。</p><p>毕竟难得的假期就要结束了，之后还得回哈尔滨打网络赛坐牢呢。</p><p>睡了一个早上之后去李子坝。还是参考之前那个出租车司机大哥的建议，直接坐过一战再坐回去看。</p><p>不过个人感觉相比之下更有意思还是从李子坝地铁站出来之后的那段盘山公路（？）。</p><p>毕竟盘山公路虽然不罕见，但是盘山公路修在城市里还堵车就是难得一见的了。</p><p>从盘山公路的几节走下去之后是李子坝梁山鸡，似乎是还算比较有名的一个馆子，小等了一会儿才等到座。</p><p>吃完饭之后因为导航显然不会考虑坡度，或者说他计算距离算的本质上是一个投影的长度，导致我们打车直接打到了一辆山上鹅岭二厂那边的出租车。</p><blockquote><p>（导航显示）司机预计还有5分钟到达。</p><p>司机：（打电话过来）可能还有很久才能到。</p><p>我：大概还有多久啊？</p><p>司机：我在山上鹅岭二厂那边，现在堵车，大概半个小时吧！</p><p>我：（良久的沉默）（看向手机）（看了一眼车流）（往上看了一眼鹅岭二厂）</p><p>我：草！（打开手机，取消订单）</p></blockquote><p>然后就重新打了一辆车去朝天门——也就是我们此行最后一个景点。</p><p>在那里坐了一趟游轮，沿着长江基本把重庆的城区给看了一遍，也能看到前几天去过的洪崖洞和长江索道。</p><p>我：这玩意儿是不是严格优于长江索道？</p><p>我：又不用排队，视野也更好，唯一的缺点就是费时间了一点，甚至还有座位，可以吹空调！</p><p>期间和 dyxg 一起去游轮的顶上吹了一会儿风，不过又因为太阳太晒下来了。</p><p>之后便是打车去机场，Sooke 和 dyxg 在 T3 航站楼，而我的航班在 T2。</p><p>从出租车上下来，三人就此别过，挥手回到各自平凡的日常去了。</p><h2 id="Day-n-1"><a href="#Day-n-1" class="headerlink" title="Day n"></a>Day n</h2><p>终于在家里补全了这份游记的最后一部分。</p><p>耳机里放着的歌突然让我想起了某游戏前一天刚刚结束的夏活。</p><p>火山和火锅似乎有某种程度的相似？</p><p>于是我想到了现在的这个标题。</p><p>我确实很喜欢这首 BGM，所以顺手把之前主题支持的每页对应一个歌曲的功能也加进来了。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1793E Velepin and Marketing</title>
      <link href="/2023/02/24/Solutions/Solution-CF1793E/"/>
      <url>/2023/02/24/Solutions/Solution-CF1793E/</url>
      
        <content type="html"><![CDATA[<p><del>时隔3年 我终于又发了一篇正经题解</del></p><p><del>要不是lqr我可能这博客就卡在这里了</del></p><a id="more"></a><p>首先对所有的读者按照 $a_i$ 的大小排序</p><p>我令 $f_i$ 为 当你满足前 $i$ 个读者的时候（后面的 $n - i$ 个直接摆烂，一人一本书读）的时候你最多能写多少书</p><p>然后我们考虑如何求 $f_n$</p><p>首先对于第 $n$ 个人 如果我们要让他开心</p><p>我们需要至少 $a_n$ 个人和他读一本书</p><p>那么这 $a_n$ 个人</p><p>显然应该是连续，最难满足的那的 $a_n$ 个（如果不止 $a_n$ 个也是同理）</p><p>那么我们就可以写出一个转移方程</p><p>$f_n = \max\{f_1 \cdots f_{n - a_i} + 1\}$</p><p>其中需要特判一下 $a_i &gt; i$ 的情况，这种时候你需要把让 $a_i$ 个人全都读一本书 同时后面摆烂的人会变成 $n - a_i$ 个</p><p>这个方程可以简单通过一个前缀最大和来实现</p><p>最后把根据 $f_i$ 算出写若干本书的时候可以满足的读者数量（我的代码里多了一个 $h_i$ 用来合并 $a_i &gt; i$ 的情况）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">300010</span>], f[<span class="number">300010</span>], g[<span class="number">3000010</span>], ans[<span class="number">300010</span>], h[<span class="number">300010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = inp();</span><br><span class="line">    <span class="built_in">std</span>::sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i] = (a[i] &gt; i) ? <span class="number">0</span> : (g[i - a[i]] + <span class="number">1</span>);</span><br><span class="line">        h[i] = (a[i] &gt; i) ? (n - a[i] + <span class="number">1</span>) : (f[i] + n - i);</span><br><span class="line">        g[i] = <span class="built_in">std</span>::max(f[i], g[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(h[i] &gt; <span class="number">0</span>)</span><br><span class="line">            ans[h[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &lt; ans[i + <span class="number">1</span>])</span><br><span class="line">            ans[i] = ans[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> q = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[inp()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACM Journal</title>
      <link href="/2022/08/01/Other/ACM-Journal/"/>
      <url>/2022/08/01/Other/ACM-Journal/</url>
      
        <content type="html"><![CDATA[<p>HZEZ OIer Dilute 的故事虽然已经结束……</p><p>但是接下来是属于 HIT ACMer Dilute 的时间！</p><a id="more"></a><h2 id="2023-10-28"><a href="#2023-10-28" class="headerlink" title="2023.10.28"></a>2023.10.28</h2><p>vp 了 <a href="https://codeforces.com/gym/104270" target="_blank" rel="noopener">18年的青岛站</a></p><p>开场发现 A 和 B 一眼不可做，但是 tyf 发现 M 和 J 是签到，在 tyf 写 M 的时候我也发现 C 是个小签到，于是快速把这三题都过了。</p><p>然后 zcw 会了 E ，但是交上去 wa 了，他觉得做法假了之后去看别的题了</p><p>但是我觉得做法没问题，调了半天最后发现其实是把 $n$ 和 $n - 1$ 搞混 + 爆 long long 了。</p><p>之后我发现 D 是个好想不好写的题，期间下了两次机让 tyf 写了个 F ，zcw 写了个 I，最后成功在10点半前下班打cf去了。</p><p>（虽然我没打，zcw A 卡太久直接当逃兵了）</p><p>（唯一打了的tyf -2，基本等于三个人都没打）</p><h2 id="2023-10-26"><a href="#2023-10-26" class="headerlink" title="2023.10.26"></a>2023.10.26</h2><p>vp 了 <a href="https://codeforces.com/gym/104460" target="_blank" rel="noopener">19年的山西省赛</a></p><p>感觉状态有些回暖，杀的很爽。</p><p>开场 tyf 开了 L ，迅速把到签上了，然后我看了 E 发现也是个签到。</p><p>然后就因为枚举范围写错寄了一发。</p><p>同时 tyf 也把 F 给过了。</p><p>然后发现 B 也是个简单题，只需要随便找一个入度是0的点跑一边dfs就行了（如果没有就随便找一个）</p><p>之后 tyf 开了 K，我发现 C 是个诈骗题，很快就过了。</p><p>之后看 J 题，发现贪心时被切断的区间都可以直接删掉，非常好写，于是也迅速过了。</p><p>然后去帮 tyf 看 I 题，我给他讲了一遍算法，我让他去写然后自己推 ba 去了。</p><p>结果这个 b 给自己绕晕了，于是我自己去写，他去鼓捣 D。</p><p>最后他还绝杀了，可喜可贺。</p><h2 id="2023-10-25"><a href="#2023-10-25" class="headerlink" title="2023.10.25"></a>2023.10.25</h2><p>vp 了 <a href="https://codeforces.com/gym/102832" target="_blank" rel="noopener">20年的长春站</a></p><p>因为 zcw 不在，所以是临时的两人两机的自行车场）</p><p>开场之后 A D 两个签到，我和 tyf 一人一道迅速解决了。</p><p>（tyf D 还寄了一发，这个甜甜就是逊拉！）</p><p>然后我就卡了好久的 F。最后把 $unordered_map$ 给压掉才过。</p><p>再过了一个小时左右 tyf 把 J 也过了。</p><p>最后一段时间我在看 L ，tyf看 C，结果双线程假掉，最后发现 L 题其实枚举 $a_1 \mod (k + 1) $ 即可，不需要枚举 $a_1$ 本身，判断也可以做到 $\mathcal{O}(1)$ 的。</p><h2 id="2023-10-18"><a href="#2023-10-18" class="headerlink" title="2023.10.18"></a>2023.10.18</h2><p>vp 了 <a href="https://codeforces.com/gym/103055" target="_blank" rel="noopener">18届浙江省赛</a></p><p>陆陆续续签完 ACFGM 五个签到之后</p><p>I 题仔细一想，发现实际上可以把他每两个圆环之间的问题拆分开来，针对三个圆环的情况直接特判，然后大力分类讨论即可。</p><p>接下来胡了一个 D 的奇怪算法（不过之后直接被证伪了）</p><p>正好这个时候 qzh 叫我们去打雀魂，于是就愉快的开摆了。</p><h2 id="2023-10-14"><a href="#2023-10-14" class="headerlink" title="2023.10.14"></a>2023.10.14</h2><p>vp 了 <a href="https://codeforces.com/gym/102452" target="_blank" rel="noopener">19~20的香港站</a></p><p>具体的不记得了（毕竟写这段话的时候已经过去半个月了）</p><p>但是我只记得这个 K 我胡了个网络流做法，交给 zcw 写结果被卡常了。</p><h2 id="2023-10-11"><a href="#2023-10-11" class="headerlink" title="2023.10.11"></a>2023.10.11</h2><p>vp 了 <a href="https://codeforces.com/gym/103447" target="_blank" rel="noopener">21年的哈尔滨站</a></p><p>但是到都没签完大伙儿都有事于是提前离场了。</p><h2 id="2023-10-2-2023-10-7"><a href="#2023-10-2-2023-10-7" class="headerlink" title="2023.10.2 ~ 2023.10.7"></a>2023.10.2 ~ 2023.10.7</h2><p>这段时间的训练记录交给了给了 <a href="https://www.cnblogs.com/SkyRainWind/p/17747332.html" target="_blank" rel="noopener">tyf</a> 来写。</p><p>所以我懒得再写一遍了！</p><h2 id="2023-10-1"><a href="#2023-10-1" class="headerlink" title="2023.10.1"></a>2023.10.1</h2><p>vp 了 <a href="https://codeforces.com/gym/104008" target="_blank" rel="noopener">去年的桂林站</a></p><p>开场看 A 发现是签到，于是直接拿下。</p><p>然后和 tyf 一起看 M ，我指出冒泡排序交换次数本质上就是逆序对之后我们就都会了，于是交给 tyf 写。</p><p>发现 E 题是个类计算几何状物，于是我丢给 tyf 一个算法让他写，结果之后他把我做法 hack 了，于是发现这题本质是个数论题，还是让 tyf 去写。</p><p>tyf 写到一半我发现 C 题本质只有两种情况，于是上了几分钟机过了。</p><p>在这期间 zcw 一直在猛猛调 G，我在过了 C 之后想了一个 J 的乱搞（但是是假的），甚至因为对拍写挂了导致没拍出错误来，tyf写完 E 之后就润去帮忙答疑了，心态非常爆炸。</p><p>调到块结束的时候 tyf 突然回来说 L 是个结论题，于是他花了十分钟过了。</p><p>之后直接把 J 换了个算法重写了一遍，终于过了，只可惜 zcw 的 G 没有过，6 题遗憾离场了。</p><h2 id="2023-9-30"><a href="#2023-9-30" class="headerlink" title="2023.9.30"></a>2023.9.30</h2><p>vp 了 <a href="https://codeforces.com/gym/104065" target="_blank" rel="noopener">去年的绵阳站</a></p><p>开场看了 A ，看到 dota 背景以为是个签到题，于是大胆猜了一个结论然后成功 wa 了一发。</p><p>然后 zcw 看到 C 是个签到，快速过了。</p><p>我暂时放下 A 和 tyf 去看 G，然后我听完题面反应过来最多执行 $\log$ 次，于是交给 tyf 去写了。</p><p>结果这个细狗甚至因为数组开小 RE 了一发。</p><p>(黄豆，笑哭，前指.png)</p><p>然后发现 H 只需要构造一条斜向直线即可，快速过了。</p><p>然后 zcw 在调 M，和我后来想的 A 正解交替上机，然后先后过了。</p><p>之后我去看 D ，zcw 看 E，D是个简单题，但是被 cin 卡了一下常数导致调了好久，zcw的 E 在 wa 了几发之后也过了。</p><p>tyf 最后 10 分钟蓟县会了 J ，只可惜没有写完。</p><h2 id="2023-9-13"><a href="#2023-9-13" class="headerlink" title="2023.9.13"></a>2023.9.13</h2><p>vp 了 <a href="https://codeforces.com/gym/104090" target="_blank" rel="noopener">去年的杭州站</a></p><p>开场我去看 A ，zcw 看 K , tyf 跟榜。</p><p>于是 tyf 顺利的把两个签到题给签上了，K 也是个相对简单的题，zcw 很快的过了。</p><p>之后我 A 会了一半，会算答案但是不会输出方案，于是丢给 zcw 去做了，他秒了。</p><p>于是我去看 C，tyf 去看 G，我把 C 给一眼了，但是各种写挂导致 -5 。</p><p>之后我和 tyf 一起看 G ，zcw继续调 A，tyf 发现 G 题只需要考虑 $n=m$ 的情况即可，于是我觉得只需要找出环上的子树做树上哈希即可（事实后来证明其实得间隔着判断）</p><p>之后 zcw 去看了 M ，我和 tyf 看 I，zcw 的 M 胡了一个假算法，我在想了之后发现可以通过随机化把 n 可能的范围缩小到 1e6 的级别，就可以前后分段做了，于是过了。</p><h2 id="2023-9-4"><a href="#2023-9-4" class="headerlink" title="2023.9.4"></a>2023.9.4</h2><p>开场看题。三个人都在比较短的时间内各发现了一个签到题，并在半小时内 1 发过掉了。</p><p>然后我开写 G，然后 tyf 给 zcw 讲了下 L 的题意，zcw 秒了，tyf 去看了 E。</p><p>我的 G 的 hash 因为一些奇怪的小问题爆了 3 发才过，zcw 的 L 树剖花了 10min 写一发过了。</p><p>tyf 的 E 打表找了找规律爆了 1 发也过了。</p><p>我的 B 我直接大力猜结论，然后结论被 zcw 一眼证明了，于是开写之后仔细一想发现需要一个最大流。然后又因为常数过大导致被卡了两发常，最后改了个奇怪的东西把边数 &gt;&gt;= 1 之后才卡过了</p><p>A 题想了一个神必 LCT 做法，因为我不会写所以丢给 zcw 去了。</p><p>（其实这篇的前半部分是 tyf 帮我写的）</p><h2 id="2023-9-3"><a href="#2023-9-3" class="headerlink" title="2023.9.3"></a>2023.9.3</h2><p>vp 了 <a href="https://codeforces.com/gym/104172" target="_blank" rel="noopener">去年的香港站</a></p><p>开场我去看了 A，zcw 去看了 H，tyf 去看了 L，然后 H 是签到，于是 zcw 直接过了。</p><p>这个时候我发现 A 也是个读题难度大于想做法的签，而且非常好写，于是花了 5 分钟过了。同时我发现 E 题是简单题，因为是数据结构所以丢给 zcw 写了。</p><p>这个时候 tyf 把 K 秒了，但是实践证明他的做法是假的。</p><p>然后我和 tyf 一起看了一眼，然后发现正确做法非常好些，最后 tyf 爆了 4 发，然后我和 tyf 一起调过去了，然后我发现 F 也是个一眼题，因为需要高精所以丢给 tyf 去写 python 了。</p><p>这个时候和 tyf 交替上机的 zcw 也把 E 给过了，他自己同时把 L 秒了。</p><p>tyf 调完 K 之后开始写 F ，期间我发现 B 题巨好写，于是把 B 给写了。</p><p>之后 tyf 和 zcw 交替写 F 和 L ，然后因为 python 常数太大了被疯狂卡常。于是我重新写了一遍 C++ 的版本，然后过了。</p><p>就在我之后没多久，zcw 那边捷豹传来，他也过了，直接下班开摆。</p><p>tyf的忏悔：今天这场我打的很不理想。关于 K 题我错了 4 次。一开始想出来的做法比较麻烦，需要离散化求线段交。事实上也不需要。给卢说了一下做法，然后他很快就想到了一个简单的做法。然后连续死于一些边界问题，有点急了。F 题卢给我报了个时间复杂度假的做法导致写了半个多小时最后T飞了。</p><h2 id="2023-8-30"><a href="#2023-8-30" class="headerlink" title="2023.8.30"></a>2023.8.30</h2><p>vp 了 <a href="https://codeforces.com/gym/103446/" target="_blank" rel="noopener">2021年的上海站</a></p><p>开场一开始去看了 A。看了几分钟觉得不可做，于是跟榜去开了 E。把当时正在写 G 写到一半的 zcw 给踢下了机。</p><p>tyf：这个 D 有点熟悉？</p><p>我：已验丁真，鉴定为之前我被 qsy 薄纱那场周测的题。</p><p>于是和 tyf 重新讲了一遍做法，他直接过了。</p><p>tyf 把 I 一眼了，然后我去看 M，期间连续胡了两个假算法。和 tyf 交替爆了好多发之后把 I 和 M 过了。之后 zcw 断断续续写的 G 也过了。</p><p>tyf: $\texttt{memset(dp,0x3f,sizeof dp);}$ 是可行的，但是如果把 $\texttt{0x3f}$ 换成 $\texttt{-0x3f}$，就会出问题，被这个地方坑了。</p><p>zcw 听说 H 是个数据结构题，上了 1h 机把他做出来了，期间我口胡了个 B。</p><p>B被卡了很久，最后发现根本不需要多项式快速幂。期间 tyf 还上了 10 分钟机把 K 给过了。</p><p>最后 8 题滚粗了。</p><p>tyf：这个 to practice 是什么啊？我点点看。</p><p>于是我们的 vp 记录就没了。</p><p>成功敲诈 tyf 一杯咖啡。</p><h2 id="2023-8-8"><a href="#2023-8-8" class="headerlink" title="2023.8.8"></a>2023.8.8</h2><h2 id="2023-8-7"><a href="#2023-8-7" class="headerlink" title="2023.8.7"></a>2023.8.7</h2><p>E 线段树维护每个区间上最左最右的未成对左括号和右括号以及已经成对的括号数量即可。</p><p>B 傻逼题，暴力匹配就完了</p><p>F 用可持久化 Trie 树来维护，每次相当于全局异或上一个值，在询问的时候处理即可</p><p>I Trie 裸题，没啥好说的</p><p>C 暴力 dp，$f_{i, j}$ 代表模板和当前字符串分别匹配到第 $i, j$ 位的情况是否可行，$\mathcal{O} (n^2)$ 转移即可。</p><h2 id="2023-8-5"><a href="#2023-8-5" class="headerlink" title="2023.8.5"></a>2023.8.5</h2><p><a href="https://codeforces.com/problemset/problem/383/E" target="_blank" rel="noopener">F</a> 高维前缀和裸题，没啥好说的</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7337" target="_blank" rel="noopener">E</a> 暴力找出所有合法的数对之后做扫描线即可，主意树状数组要替换成分块来平衡修改和查询的复杂度</p><p><a href="https://www.luogu.com.cn/problem/P3899" target="_blank" rel="noopener">A</a> 正解应该是线段树合并或者二位数点啥的，但我写了个奇怪的 bfs序 + 倍增做法，如果有时间专门写篇题解吧。</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7284" target="_blank" rel="noopener">C</a> 因为每次修改的 $x$ 不降，所以如果一个数触发了取绝对值，之后每次肯定都会触发，那么先预处理出每个点触发取绝对值的时间点，之后用两棵线段树维护即可。</p><h2 id="2023-8-4"><a href="#2023-8-4" class="headerlink" title="2023.8.4"></a>2023.8.4</h2><p>A 裸莫队，没啥好说的</p><p>B 裸带修莫队，没啥好说的</p><p>F 维护一个块内排过序的数组 $b$，每次修改暴力重构边缘块，中间直接全体打标机即可。</p><p>E 分块维护每个点弹到块外的位置，修改暴力重构即可。</p><p>G 分块维护每个块的桶，容易发现一次询问的答案要么出现在边缘块中，要么就是中间完整块的答案，而后者可以 $\mathcal{O} (n\sqrt{n})$ 预处理。</p><h2 id="2023-8-3"><a href="#2023-8-3" class="headerlink" title="2023.8.3"></a>2023.8.3</h2><p>A, B, F fft, ntt, fwt 模板题，没啥好讲的</p><p>C 把模式串反过来，然后把 ? 设成 0，其他的第 i 位设成 $30^i$，然后发现就可以用类哈希状物判断是否匹配。</p><h2 id="2023-8-2"><a href="#2023-8-2" class="headerlink" title="2023.8.2"></a>2023.8.2</h2><p>验题场，不能写</p><h2 id="2023-8-1"><a href="#2023-8-1" class="headerlink" title="2023.8.1"></a>2023.8.1</h2><p>A Manacher 裸题，没啥好说的。</p><p>B 二分 + 哈希预处理每个点开始的后缀和原串的 lcp，然后枚举即可。</p><p>C 预处理和前一题一样，不过从维护一个最大值变成了维护一个set</p><p>E 处理出 next 数组之后预处理出不考虑重复的 num’ 数组，然后通过暴力跳 next 找出满足不重复的第一个位置，取那个点的 num’ 即可。</p><p>G 和 BC 预处理一样，不过需要一个树状数组维护一下。</p><h2 id="2023-7-31"><a href="#2023-7-31" class="headerlink" title="2023.7.31"></a>2023.7.31</h2><p><del>为什么树链剖分和主席树会在同一天同一个专题的啊</del></p><p>B 用主席树维护每个数在每个点上最后出现的位置，然后二分即可。</p><p>A 主席树裸题，没啥好说的。</p><p>C 把裸题维护的变成树上从根节点开始的链即可。</p><p>G 树链剖分裸题，没啥好说的。</p><p>E 也是主席树裸题，不过空间卡的比较死，很傻逼。</p><h2 id="2023-7-29"><a href="#2023-7-29" class="headerlink" title="2023.7.29"></a>2023.7.29</h2><p>周测。</p><p><a href="https://codeforces.com/problemset/problem/242/E" target="_blank" rel="noopener">L</a> 用 $20$ 棵线段树维护每个数每位是 $1$ 还是 $0$。</p><p><a href="https://www.luogu.com.cn/problem/P2045" target="_blank" rel="noopener">C</a> 经典费用流题。每个点拆点之后两个点之间连一条有费用，流量为1的边和一条无费用，流量无限的边之后跑费用流即可。</p><p><a href="https://www.luogu.com.cn/problem/P2949" target="_blank" rel="noopener">I</a> 傻逼题，排个序之后倒着贪心即可。</p><p><a href="https://codeforces.com/gym/104345/problem/M" target="_blank" rel="noopener">J</a> 也是费用流，对于每堵墙建点，然后向汇点连两条边，代表第一次在这堵墙开窗不需要费用，第二次要。</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7304" target="_blank" rel="noopener">N</a> 暴力 $\mathcal{O} (n^2)$ dp 即可，没啥好说的。</p><h2 id="2023-7-28"><a href="#2023-7-28" class="headerlink" title="2023.7.28"></a>2023.7.28</h2><p>感冒了，还巨 tm 困，写的都是以前写过的或者傻逼题，跳过。</p><h2 id="2023-7-27"><a href="#2023-7-27" class="headerlink" title="2023.7.27"></a>2023.7.27</h2><p>A 预处理出每个数作为左端点能取到的最右边的端点位置，然后 $st$ 表维护即可。</p><p>B 扫描线裸题，没啥好说的</p><p>D 维护每个点作为右端点，左端点的最优选，然后可以认为一开始是右端点为 $i$，左端点 $\in [1, i - 1]$ ，最优解为 $o$ ，之后可以拆分成 $[1, o - 1]$ 和 $[o + 1, i - 1]$ ，维护一个堆，贪心地取然后拆分即可。</p><p>F 从后往前枚举，此时我们已经确认了哪些节点已经被去掉，直接树状数组维护当前还剩哪些数，然后二分即可。</p><p>G  可以认为所有 $\ge s$ 的数对于答案的贡献就是 c—，然后计算所有 $&lt; s$的数的和，可以用权值树状数组简单维护。</p><h2 id="2023-7-26"><a href="#2023-7-26" class="headerlink" title="2023.7.26"></a>2023.7.26</h2><p><a href="https://codeforces.com/gym/103855/" target="_blank" rel="noopener">马拉松</a>。</p><p><a href="https://codeforces.com/gym/103855/problem/H" target="_blank" rel="noopener">H</a> 找出每个可能成为信标的节点（显然贪心地找右边第一个比当前大的即可）然后直接算就可以了。</p><p><a href="https://codeforces.com/gym/103855/problem/F" target="_blank" rel="noopener">F</a> 把每个颜色相同的极长段缩成一个点之后，只需要去头去尾之后选一半的即可。</p><p><a href="https://codeforces.com/gym/103855/problem/D" target="_blank" rel="noopener">D</a> 显然只有四种取法，$3 + 0$ 型显然好处理，$2 + 1$ 型只要枚举那个 $1$ 然后用 $set$ 维护最优的行 / 列即可。</p><p><a href="https://codeforces.com/gym/103855/problem/E" target="_blank" rel="noopener">E</a> 对于每个极长的连续段，如果可以赢右边的元素，那么就将至多 $k$ 个移到右边极长段的右边，主意可能要和再有边的极长段合并</p><p><a href="https://codeforces.com/gym/103855/problem/M" target="_blank" rel="noopener">M</a> 推出柿子之后发现其实就是求 $\displaystyle\sum_{j &lt; i} \max\{(q_i - p_i) - (q_j - p_j), 0\}$ 和一个类似的东西，直接用树状数组维护即可。</p><p><a href="https://codeforces.com/gym/103855/problem/J" target="_blank" rel="noopener">J</a> 直接大力 $meet-in-the-middle$ 。注意需要特别处理在左半段或右半段之直接已经取到要求的子段和的情况，有一车细节。</p><h2 id="2023-7-25"><a href="#2023-7-25" class="headerlink" title="2023.7.25"></a>2023.7.25</h2><p>J 经典状压，不多赘述。</p><p>G 发现肯定是基环树森林，然后我们对于每棵基环树，找到他环上的一个节点，钦点不选他，然后再钦点不选与他相连的一个节点，分别以这两个点为根进行 dp 即可。</p><p>C 二分答案，计算 $\le x$ 的数里有多少个可以保留下来，这个是显然可以二分的。</p><p>A 直接树上背包，因为两个点只会在 $lca$ 处被统计所以复杂度是 $\mathcal{O}(n^2)$ 的</p><p>B wqs 二分裸题，转换成选 $k + 1$ 条不交的链之后，因为每个点的度数最多是 $2$ ，就可以二分了。</p><h2 id="2023-7-24"><a href="#2023-7-24" class="headerlink" title="2023.7.24"></a>2023.7.24</h2><p>网络流专场。</p><p>H 黑白染色之后变成二分图，然后求最小割即可。</p><p>A 可以转成对偶图求最短路，也可以直接最小割。</p><p>G 经典费用流问题，不多赘述。</p><p>B 把每个点拆成两个点，因为每个点肯定最多一个入的路径一个出的路径，然后跑最大流即可。</p><p>F 对于每个技术员，建<strong>倒数</strong>第一个修的他，倒数第二个修的他……然后可以直接计算每个人的贡献 = 他后面正在等的人数 * 修他的车花的时间</p><p>D 跑一遍 floyd 之后直接二分图匹配即可。</p><p>I 对于每个人，割掉连向原点的边代表放弃文科，割掉连向汇点的边代表放弃理科，之后根据剩下的连通性可以直接计算出在每种选择下，需要放弃掉哪些同科带来的贡献，直接最小割即可。</p><h2 id="2023-7-22"><a href="#2023-7-22" class="headerlink" title="2023.7.22"></a>2023.7.22</h2><p>给我打破防了，不想写了</p><h2 id="2023-7-21"><a href="#2023-7-21" class="headerlink" title="2023.7.21"></a>2023.7.21</h2><p><del>今天是0721节，你是0721高手</del></p><p>A 第一个不用说，第二种直接 exgcd，第三个是 bsgs 裸题。</p><p>B 也是 bsgs 裸题，只要把数改成矩阵即可。</p><p>C 写出 $a_n$ 的表达式之后经过一定变换可以转换成经典 bsgs 问题，但是特判巨多。</p><p>G 数论大杂烩，先用费马小定理转换成求他的指数 $\mod (\text{模数} - 1)$ 的问题，然后用中国剩余定理把模数拆开之后卢卡斯即可。 </p><h2 id="2023-7-20"><a href="#2023-7-20" class="headerlink" title="2023.7.20"></a>2023.7.20</h2><p><del>博弈论腐乳迪卢特, 出列！</del></p><p><a href="https://codeforces.com/gym/103366/problem/H" target="_blank" rel="noopener">D</a> 就是昨天的 H。</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2897" target="_blank" rel="noopener">H</a> 发现其 SG 函数有循环节 $p + q$，而且是连续 $p$ 个 $0$ 和连续 $q$ 个非 $0$，于是就结束了。</p><p><a href="https://codeforces.com/contest/1600/problem/E" target="_blank" rel="noopener">A</a> 假博弈，只用考虑左边和右边的各一个极长上升序列，考虑当前较大的那个序列头所属的序列长度的奇偶性即可，如果是奇数直接选，否则选较小的那个序列头。</p><p><a href="https://lightoj.com/problem/partitioning-game" target="_blank" rel="noopener">G</a> 暴力求 SG 函数即可。</p><p><a href="https://codeforces.com/contest/1215/problem/D" target="_blank" rel="noopener">D</a> 可以认为左边半边是正的而右半边是负的，然后右半边的问号只要自带一个 $+9$ 就可以和左边的问号一起考虑了</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1729" target="_blank" rel="noopener">I</a> 令 $f(n)$ 为最大的 $k$ 满足 $k + k^2 &lt; n$，发现如果 $\text{sg} (n) = 0$，那么 $\text{sg}(i) = i - k (i \in [k + 1, n - 1])$ ，利用这个性质可以快速求 SG 函数。</p><p><a href="https://codeforces.com/gym/104053/problem/H" target="_blank" rel="noopener">C</a> 显然只有 $n + 2k$ 以内的元素才有用，然后肯定是一个人填奇数的空位，一个人填偶数的空位，模拟即可。</p><p><a href="https://codeforces.com/gym/104053/submission/195009681" target="_blank" rel="noopener"><del>数组记得开n + 2k, lqr !</del></a></p><p><a href="https://lightoj.com/problem/game-of-hyper-knights" target="_blank" rel="noopener">E</a> 发现每次移动棋子的 $x + y$ 单调上升，于是暴力求 SG 函数即可。</p><h2 id="2023-7-19"><a href="#2023-7-19" class="headerlink" title="2023.7.19"></a>2023.7.19</h2><p>今天是<a href="https://codeforces.com/gym/103366" target="_blank" rel="noopener">马拉松</a></p><p><a href="https://codeforces.com/gym/103366/problem/B" target="_blank" rel="noopener">B</a>, <a href="https://codeforces.com/gym/103366/problem/A" target="_blank" rel="noopener">A</a>, <a href="https://codeforces.com/gym/103366/problem/K" target="_blank" rel="noopener">K</a>, <a href="https://codeforces.com/gym/103366/problem/L" target="_blank" rel="noopener">L</a> 四道签到题，没什么好说的</p><p><a href="https://codeforces.com/gym/103366/problem/J" target="_blank" rel="noopener">J</a> 考虑对于每次访问求出让其满足条件的最小的答案，容易发现这个就是两个相同元素之间不同元素的数量，用莫队即可。是不过正解似乎是二分答案（而且很好写）。</p><p><a href="https://codeforces.com/gym/103366/problem/F" target="_blank" rel="noopener">F</a> 找规律发现答案的差分满足形如：$2$ 个 $2$, $3$ 个 $4$, $4$ 个 $8 \cdots n$ 个 $2^{n - 1}$ ，虽然我不会证明，但是写个高精就可以了<del>有人瞎jb压位压挂了</del></p><p><a href="https://codeforces.com/gym/103366/problem/C" target="_blank" rel="noopener">C</a> 容易发现肯定取的肯定是一个线段的最左边或者最右边，于是考虑从下往上 dp，只需要多一维记录一下有多少个取在左 / 右边即可。</p><p><a href="https://codeforces.com/gym/103366/problem/D" target="_blank" rel="noopener">D</a> 逆天构造，枚举特殊的那种数，然后维护一个三元组$\{$ 第一和排序之后的数组不一样的位置 $, $ 在上述位置改成的数 $, $ 特殊的数$\}$ 然后根据这个三元组排序，选择最优的特殊数即可。</p><p><a href="https://codeforces.com/gym/103366/problem/H" target="_blank" rel="noopener">H</a> 重量级歪榜诈骗题，本来应该是签到题，结果愣是没人做。实际上只有在 $n \in (1, n + 1]$ 这段区间，即先手可以一回合斩杀的时候先手胜。</p><h2 id="2023-7-18"><a href="#2023-7-18" class="headerlink" title="2023.7.18"></a>2023.7.18</h2><p><a href="https://codeforces.com/gym/104128/problem/B" target="_blank" rel="noopener">G</a> 考虑强制选或者不选一个点的做法，直接从左边开始和右边开始分别做一次 dp，强制选择直接简单相加即可。然后强制不选就的情况下他的左边k个，和左边选择元素的右边k个（在当前元素的右边）内肯定各有一个被选中的元素，之后的枚举左边那个并且维护一下右边选的元素的最小值即可。</p><p><a href="https://codeforces.com/contest/1842/problem/E" target="_blank" rel="noopener">A</a> 容易发现选择的的三角形肯定没有交点，于是用线段树维护一下在当前枚举到的点，选择三角形的左端点在每个位置的时候可以覆盖到的点的权值和即可。</p><p><a href="https://www.luogu.com.cn/problem/P3195" target="_blank" rel="noopener">E</a> 斜率优化裸题，没啥好说的。</p><p><a href="https://codeforces.com/contest/383/problem/E" target="_blank" rel="noopener">I</a> 高位前缀和裸题，先枚举在哪一位再枚举具体的状态，可以保证不会重复算，</p><p><a href="https://www.luogu.com.cn/problem/P3311" target="_blank" rel="noopener">C</a> 在 AC 自动机上做 dp，注意预处理每个节点走 fail 指针能走到的节点里边有没有模式串的终点。</p><h2 id="2023-7-17"><a href="#2023-7-17" class="headerlink" title="2023.7.17"></a>2023.7.17</h2><p>在暑期集训的第二周的礼拜一……</p><p>我终于决定要重启这篇文章（虽然大概率只是三分钟热度）</p><p>今天是 tarjan 主题。</p><p><a href="https://www.luogu.com.cn/problem/P3387" target="_blank" rel="noopener">A</a> 洛谷的缩点板子题 直接缩点跑完写个 DAG 上 DP 即可。</p><p><a href="https://www.luogu.com.cn/problem/P4171" target="_blank" rel="noopener">H</a> 经典2-SAT 板子题，没啥好说的。</p><p><a href="https://www.luogu.com.cn/problem/P5058" target="_blank" rel="noopener">C</a> 首先直接从 $s$ 开始 tarjan ，然后在判断割点的时候多加一个判断 $t$ 是否在子连通块内的判断即可。</p><p><a href="https://codeforces.com/contest/467/problem/D" target="_blank" rel="noopener">B</a> 用 map 把每个字符串用 $\{ \text{r的数量}, \text{len}\}$ 的二元组表示出来之后跑一边缩点之后的 DAG 上 DP 即可</p><p><a href="https://darkbzoj.cc/problem/2730" target="_blank" rel="noopener">D</a> 先跑一遍割点，然后发现对于每个非割点的连通块，考虑和它项连的割点数量，如果没有或者有一个，那么在其中任选两个造出口，如果有两个即以上，那么不需要在里边造出口，因为它肯定是被其他的连通块夹在中间，不管那些割点中哪个被挂掉都会有其他的连通块与其相连。</p><p><a href="https://www.luogu.com.cn/problem/P2860" target="_blank" rel="noopener">F</a> 将每个双连通分量缩点之后容易发现答案就是 $\frac{\text{叶子节点数量} + 1}{2}$</p><p><a href="https://codeforces.com/contest/1239/problem/D" target="_blank" rel="noopener">J</a> 把每对认识的人和猫连边之后容易发现，对于一个强连通分量中的节点，如果其中一个人当了评委，所有人都得当评委，所以只有两种情况，一种情况所有人都在一个强连通分量内直接无解，其他情况肯定存在一个出度为0的分量，选那个分量里的所有人即可。</p><h2 id="2022-11-13"><a href="#2022-11-13" class="headerlink" title="2022.11.13"></a>2022.11.13</h2><p>队内训练。</p><p>在一个 furry 朋友倾力推荐下 vp 了今年的威海站。</p><p><del>据他原话：真的不是因为什么奇怪的原因，这场质量真的很高</del></p><p>（果然签到题还是交给 lqr 比较好，他做签到真的快）</p><p>开局我开 A，417 开 E，结果我因为无限读错题意导致签了半天到没签上。</p><p>做完 A 之后我去和 lqr 一起开 G。</p><p>lqr：他会不会有循环节吧！</p><p>我：不可能，绝对不可能！</p><p>（上完厕所回来）</p><p>我：卧槽还真有，卧槽我会了</p><p>J 题我看了几眼发现可以分段做，于是开写，同时 lqr 开 C ，最后差不多时间做完了。</p><p><del>（这个时候我们本想发挥队伍传统艺能开摆，结果在我的强力 KFC 之下成功得将队伍掰回了正轨，这波立大功！）</del></p><p>然后我一边摆烂一边和队友一起想 I 题，过了好久之后我大胆瞎猜结论，结果在连续寄了五发之后过了。</p><p><del>期间 417 因为没吃中饭所以点了一碗麻辣烫</del></p><p><del>干他妈的，真香，当时真的好像上去蹭一口</del></p><p>然后去看 D，一眼发现就是个 B 状压，然后开始写，越写就感觉越麻烦。</p><p>最后在离结束 10 分钟得时候过了，欢声笑语中打出 GG（大雾）</p><h2 id="2022-11-7"><a href="#2022-11-7" class="headerlink" title="2022.11.7"></a>2022.11.7</h2><p>好耶！终于上 IM 力！</p><p>（这两天可能是什么良辰吉日，Venus 晚上刚上黄金 我 CF 就上 IM 了</p><h2 id="2022-11-6"><a href="#2022-11-6" class="headerlink" title="2022.11.6"></a>2022.11.6</h2><p>队内训练。</p><p>vp了去年的icpc沈阳站。</p><p>开场直奔 B 题，结果脑子一傻逼一开始只想到了前半部分的转化，然后 417 秒了 J 之后一听题意说她会了于是让她去写了，lqr也把 E 过了。</p><p>于是去开 F 发现 $n \leq 2000$ 然后暴力即可。</p><p>跟榜发现 L 似乎不难，先容斥之后转化成求树上匹配数量，一开始想了个 $\text{O}(n^3)$ 的树上 dp，然后发现可以通过 NTT 优化成 $\text{O}(n^2 \log n)$ 的，然后通过在转移的时候全部以点值的转移，可以把 $\log$ 去掉，于是可以通过，后来我写忘记预处理逆元了写成 $n^2 \log$ 的结果卡常卡了半天。</p><p>我当时的心路历程：</p><p>我：先容斥一下，然后可以树上dp，但是这空间就是 $n ^ 2$ 的过不了</p><p>我：啊？$n \leq 2000$ ？</p><p>我：虽然复杂度是 $n^3$ 的，但是可以加个 ntt 就 $n^2 \log$ 了</p><p>我：哦 好像乱搞一下就 $n^2$ 了，开写！</p><p>在旁边插不上话的 lqr ： 你这样显得我很呆。</p><p><del>后来发现好像正解根本不用NTT</del></p><p>过了 L 之后全队直接开摆了，虽然还有整整三个小时，但是一个人在打牌，一个人在打皇室，还有一个人在看 S12 。</p><p>DRX真的牛逼，看的我根本没心思回去继续打 vp。</p><h2 id="2022-10-27"><a href="#2022-10-27" class="headerlink" title="2022.10.27"></a>2022.10.27</h2><ul><li>修复了 Valine，但是之前的评论找不回来了……</li><li>由于作者即将回归大群，将标题替换成了海嗣语（大雾）</li></ul><h2 id="2022-10-26"><a href="#2022-10-26" class="headerlink" title="2022.10.26"></a>2022.10.26</h2><p>今天是 2022 年 10 月 26 号。</p><p>距离我上一次更新这个博客已经过了两个多月。</p><p>我其实也没什么 xcpc 相关的东西要写的。</p><p>虽然我这两个月也写了些题，但是总是因为各种各样的原因发到博客上来；</p><p><del>主要原因是我换了电脑 把博客迁移过来很累的啦 而且我也懒得把前两个月的题目总结一下</del></p><p>直到今天的俄语课上……</p><p>我们的老师，她说了一个神秘的单词——————</p><blockquote><p>Ълог</p></blockquote><p>「啊这个单词意思是 博客 」</p><p>「欸我们班上有同学写博客吗？」</p><p>我举起了手，但是老师似乎没有看到。</p><p>「现在好像没什么人写这东西了。」</p><p>「我以前有个学生经常写，他好像是搞什么信息学竞赛的，很厉害。」</p><p>于是我终于想起来了我的小可爱博客。</p><p>并且把它移到了我的新电脑上。</p><p>好耶！</p><p>写完之后又发现出现了奇怪的问题。</p><p>苹果的电脑有个机制 会把文件保存到icloud上面而把本地的文件删掉。</p><p>于是我的头像便惨遭了毒手。</p><p>我还得从手机相册里把我的头像的高清原图找出来发给电脑。</p><p><del>icloud ！我要把你那肮脏的服务器！砍断！切开！剁碎！</del></p><h2 id="2022-8-19"><a href="#2022-8-19" class="headerlink" title="2022.8.19"></a>2022.8.19</h2><h3 id="Codeforces-1718C"><a href="#Codeforces-1718C" class="headerlink" title="Codeforces 1718C"></a><a href="https://codeforces.com/contest/1718/problem/C" target="_blank" rel="noopener">Codeforces 1718C</a></h3><p>比赛的时候多测没清空，甚至过了几天才发现，我的评价是：寄！</p><p>肯定成一个环，绕若干圈，然后可以发现最后选择的环长一定是一个质数，直接 $\text{multiset}$ 爆淦即可。</p><hr><p>高三毕业的暑假里突然想起自己还有一个blog。</p><p>于是打开了那个熟悉的网址，意料之外的是这个域名竟然一直没有过期。</p><p>而意料之中的是，虽然博客还在，但是包括评论系统，相当一部分的图片和友链都已经挂掉了<del>甚至在上传这篇文章的时候还遇到了github上的ssh key 离奇消失的奇怪事件</del>。上一次更新是两年半以前的事情——那好像是上个世纪的东西了。</p><p>接着我翻看了一下自己过往的文章。</p><p>看着初学OI时期的青涩的题解，那些是我看着可以扣地板扣出三室一厅的黑历史。</p><p>看着随着我OI水平的提高文风日渐成熟（虽然也没好到哪里去）的文章，我仿佛回到了坐在二中机房里，一杯水一台电脑，一个bug调一天的时光。</p><p>看着各处打比赛的游记，死去的回忆突然从我的脑海中苏醒，ZJOI时mwh「你瑞兹爸爸来啦！」的战吼仿佛又回荡在了我的脑海、PKUWC时和wxw和sooke的夜晚蹦迪似乎就发生在昨天、想到了NOIp / CSP 时的欢笑与泪水……</p><p>回首往昔，我的OI生涯虽然称不上成功，但在我看来也并非是彻底的失败。</p><p>但是高中阶段的OI对我而言已然是过往云烟，我们应当向着未来去看。</p><p>换了新的头像，重新启用这个百废待兴的博客，不论是在日常生活，学习上，还是 OI / ACM 的方面上，我都希望我自己也可以成长为更加成熟，更加可以独当一面的人。</p><p>也许我还可以在大学，在ACM的舞台上发光发热。</p><p>这篇文章将会持续更新，更新我作为 ACMer 时写的题，同时大概会作为这个博客的更新日志使用吧。</p><blockquote><p>Dilute 写于2022年8月1日。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1314D Tourism</title>
      <link href="/2020/02/24/Solutions/Solution-CF1314D/"/>
      <url>/2020/02/24/Solutions/Solution-CF1314D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>开场 10 分钟就有人过的 1D ，你值得拥有！</p><p>$\texttt{swap(B, D)}$ 警告。</p></blockquote><a id="more"></a><p>精读题面，发现 $k \le 10$ ，考虑从这个性质中寻找解法。</p><p>$k \le 10$ 意味着最后真正对结果产生贡献的节点只会有 $10$ 个以下。</p><p>结合题面中给出的「没有奇环」条件，容易想到二分图黑白染色。</p><p>考虑对每个点随机染 黑 / 白色，再强制走两端颜色 <strong>不相同</strong> 的边。</p><p>这个过程可以用简单 dp ，$f_{i, j}$ 表示走了 $i$ 条边，当前在节点 $j$ 的最小花费，$\Theta(n^2k)$ 直接转移即可。</p><p>重复这个过程若干遍即可。</p><p>我们继续考虑为什么这个解法是大概率正确的。</p><p>考虑如果我们已经知道了最终的一条最优路径，这上面最多有 $k$ 个点。</p><p>那么这 $k$ 个点在一种染色方案中黑白相间的概率是 $\frac{1}{2^{k - 1}}$ ，在 $k = 10$ 的情况下就是 $\frac{1}{512}$。</p><p>随机 $5000$ 次的情况下，随不出正确答案的概率是 $(\frac{511}{512})^{5000} \approx 0.000056845461206$ ，非常小，可以忽略不计。</p><p>这解法就 ** 离谱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">20</span>][<span class="number">100</span>], dis[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">int</span> k = inp();</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dis[i][j] = inp();</span><br><span class="line">    ll ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            c[i] = rand() &amp; <span class="number">1</span>;</span><br><span class="line">            f[<span class="number">0</span>][i] = <span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                f[i + <span class="number">1</span>][j] = <span class="number">1e18</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u++)</span><br><span class="line">                    <span class="keyword">if</span>(c[j] != c[u])</span><br><span class="line">                        f[i + <span class="number">1</span>][u] = <span class="built_in">std</span>::min(f[i + <span class="number">1</span>][u], f[i][j] + dis[j][u]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, f[k][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 随机化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1286C Madhouse</title>
      <link href="/2020/01/12/Solutions/Solution-CF1286C/"/>
      <url>/2020/01/12/Solutions/Solution-CF1286C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个 $0.777$ 让我想起了某位 EDG 的退役打野选手</p><p>—— Sooke</p></blockquote><p>4396（无 端 迫 害）</p><a id="more"></a><hr><p>我们首先考虑如果我们询问了一段区间 $[1 ,n ]$ ，我们可以得到什么信息。</p><p>我们考虑把 $s_1 , s_{2} , s_{3} \cdots s_n$ 在每种长度的子串中出现的次数给写出来（以 $n = 5$ 时的情况为例）。</p><div class="table-container"><table><thead><tr><th style="text-align:center">$len$</th><th style="text-align:center">$s_1$</th><th style="text-align:center">$s_2$</th><th style="text-align:center">$s_3$</th><th style="text-align:center">$s_4$</th><th style="text-align:center">$s_5$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><p>看出规律了吗？如果看不出来的话，我们把每列的数做差分之后的结果再写出来。</p><div class="table-container"><table><thead><tr><th style="text-align:center">$len$</th><th style="text-align:center">$s_1$</th><th style="text-align:center">$s_2$</th><th style="text-align:center">$s_3$</th><th style="text-align:center">$s_4$</th><th style="text-align:center">$s_5$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table></div><p>这样以来，我们是不是可以得到 $s[\frac{l + r}2]$ 的值（当 $len$ 为奇数的时候才可以），并且可以得到 $\lfloor \frac {len}2 \rfloor$ 组形如 「$s_x$ 和 $s_y$ 分别是 $a$ 和 $b$ 」（其中 $a$ 和 $b$ 代表两个字符）的限制。</p><p>我们接下来考虑如何利用这个性质来解决这道题目。</p><p>考虑将这个字符串划分为三段，分别为 $[1 , s]$，$[s + 1, t]$，$[t + 1, n]$ 三段区间。</p><p>这个分法要满足一定的要求，具体是什么要求稍后会讲到。</p><p>然后询问 $[1 , t]$ ，$[s + 1 , n]$ ，$[s + 1, n - 1]$ 三段。</p><p>把每组得到的约束条件都连起来，我们可以得到一个差不多长成这样的图……</p><p><img src="https://dilute.xyz/images/4.png" alt></p><p>注意那个画着一个绿色圈圈的位置，我们假设我们已经知道这里是什么。</p><p>那么考虑交替通过绿色和红色的约束就可以知道第二段和第三段，然后通过蓝色的约束就可以知道第一段了。 </p><p>那么只要在询问 $[s + 1 , n]$ 的时候那个长度为奇数的时候中间可以直接知道的数落在它身上就可以了。</p><p>这样一来，我们就知道这个分法要满足什么要求了。</p><p>我们设三段的长度分别为 $len1 , len2 , len3$，那么需要满足：</p><ul><li>$len2 + len3$ 为奇数</li><li>$len2 &gt; len3$</li><li>$len2 &gt; len1$ （否则无法由第二段推出完整的 $len1$）</li></ul><p>可以通过对 $n \mod 3$ 进行分类讨论得出 $len1 , len2 , len3$ 。</p><p>每次询问的长度都是 $\frac 23 n$ 级别，询问出来的字串数量都是 $\frac 29 n^2$ 级别，最终三次询问加起来就大约是 $\frac 23 n^2 \approx 0.66666 n^2 &lt; 0.777 n^2$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">int</span> neg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">            neg = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum * neg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ans[<span class="number">110</span>], s[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">char</span> f[<span class="number">110</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> _query(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'a'</span> || c &gt; <span class="string">'z'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec[<span class="number">110</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> a, <span class="built_in">std</span>::<span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.size() &lt; b.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">30</span>], q[<span class="number">110</span>], cou[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> qf = <span class="number">1</span>, qe = <span class="number">0</span>, n;</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">110</span>], have[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> last[<span class="number">30</span>], delta[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r - l + <span class="number">1</span>; i++)</span><br><span class="line">        vec[i].clear();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; l &lt;&lt; <span class="string">' '</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ((r - l + <span class="number">1</span>) * (r - l + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>); i++)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        vec[(<span class="keyword">int</span>)(str.size())].push_back(str);</span><br><span class="line">        <span class="comment">// printf("str.size() = %d\n", (int)(str.size()));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(delta, <span class="number">0</span>, <span class="keyword">sizeof</span>(delta));</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="number">0</span>, <span class="keyword">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)(vec[<span class="number">1</span>].size()); i++)&#123;</span><br><span class="line">        last[vec[<span class="number">1</span>][i][<span class="number">0</span>] - <span class="string">'a'</span>]++;</span><br><span class="line">        delta[vec[<span class="number">1</span>][i][<span class="number">0</span>] - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= ((r - l) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)(vec[i].size()); j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; i; u++)</span><br><span class="line">                cnt[vec[i][j][u] - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// printf("i = %d\n", i);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)&#123;</span><br><span class="line">            cnt[j] -= last[j];</span><br><span class="line">            last[j] += cnt[j];</span><br><span class="line">            <span class="keyword">int</span> last = cnt[j];</span><br><span class="line">            <span class="keyword">while</span>(cnt[j] &lt; delta[j])&#123;</span><br><span class="line">                <span class="comment">// printf("link %d %d\n", l + i - 2, r - i + 2);</span></span><br><span class="line">                f[l + i - <span class="number">2</span>][r - i + <span class="number">2</span>][cur] = <span class="string">'a'</span> + j;</span><br><span class="line">                f[r - i + <span class="number">2</span>][l + i - <span class="number">2</span>][cur] = <span class="string">'a'</span> + j;</span><br><span class="line">                have[l + i - <span class="number">2</span>][r - i + <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">                have[r - i + <span class="number">2</span>][l + i - <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">                cur++;</span><br><span class="line">                cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            delta[j] = last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf("maxinum %d | %d ", ((r - l + 1) &gt;&gt; 1) + ((r - l) &amp; 1), vec[2].size());</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((r - l + <span class="number">1</span>) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(delta[i] &amp;&amp; !used[mid])&#123;</span><br><span class="line">                used[mid] = <span class="literal">true</span>;</span><br><span class="line">                ans[mid] = <span class="string">'a'</span> + i;</span><br><span class="line">                q[++qe] = mid;</span><br><span class="line">                <span class="comment">// printf("ans[%d] = '%c' | %d\n", mid, 'a' + i, cnt[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">while</span>(delta[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// printf("| link %d %d | %d left\n", mid, mid + 1, delta[i]);</span></span><br><span class="line">                f[mid][mid + <span class="number">1</span>][cur] = <span class="string">'a'</span> + i;</span><br><span class="line">                f[mid + <span class="number">1</span>][mid][cur] = <span class="string">'a'</span> + i;</span><br><span class="line">                have[mid][mid + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                have[mid + <span class="number">1</span>][mid] = <span class="literal">true</span>;</span><br><span class="line">                cur++;</span><br><span class="line">                delta[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"! "</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        <span class="built_in">putchar</span>(ans[i]);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(qf &lt;= qe)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = q[qf++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(have[i][j] &amp;&amp; !used[j])&#123;</span><br><span class="line">                ans[j] = f[i][j][f[i][j][<span class="number">0</span>] == ans[i]];</span><br><span class="line">                used[j] = <span class="literal">true</span>;</span><br><span class="line">                q[++qe] = j;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = inp();</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            ans[i] = _query(i);</span><br><span class="line">        print(n);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = (n / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> len2 = len1, len3 = len1;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        len2++;</span><br><span class="line">        len3--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        len2++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len2++;</span><br><span class="line">        len3++;</span><br><span class="line">    &#125;</span><br><span class="line">    query(<span class="number">1</span>, len1 + len2);</span><br><span class="line">    query(len1 + <span class="number">1</span>, n);</span><br><span class="line">    query(len1 + <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; i++)</span></span><br><span class="line">    <span class="comment">//     for(int j = 1; j &lt;= n; j++)</span></span><br><span class="line">    <span class="comment">//         if(have[i][j])</span></span><br><span class="line">    <span class="comment">//             printf("&#123;%d, %d&#125; &#123;%c, %c&#125;\n", i, j, f[i][j][0], f[i][j][1]);</span></span><br><span class="line">    bfs();</span><br><span class="line">    print(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非传统题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF498D Traffic Jams in the Land</title>
      <link href="/2019/09/01/Solutions/Solution-CF498D/"/>
      <url>/2019/09/01/Solutions/Solution-CF498D/</url>
      
        <content type="html"><![CDATA[<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>首先观察数据范围，发现$a_i \le6$，这个是一个非常有用的性质。</p><p>发现$\mathrm{lcm}(1, 2, 3, 4, 5, 6)=60$，这个数有一个非常优美的性质：把$t$再$\mod 60$意义下进行不会影响结果的正确性。</p><a id="more"></a><p>接下来继续考虑线段树，对于每个区间$[l, r]$，再对于每个可能的时间$\mod 60$意义下的结果，我们维护如果在达到$l$的时候$t \mod 60 = i$，那么达到$r + 1$需要花费多少时间。</p><p>这个玩意儿可以$O(60)$的$push_up$。</p><p>那么我们就可以以$O(n \log n \times 60)$  的优秀复杂度通过此题。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(a) ((a) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(a) ((a) &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG_Tree</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SEG</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">61</span>];</span><br><span class="line">    &#125;t[<span class="number">400010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++)</span><br><span class="line">            t[cur].f[i] = t[rc(cur)].f[(i + t[lc(cur)].f[i]) % <span class="number">60</span>] + t[lc(cur)].f[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        t[cur].l = l;</span><br><span class="line">        t[cur].r = r;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">59</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                t[cur].f[i] = <span class="number">1</span> + (i % a[l] == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(lc(cur), l, mid);</span><br><span class="line">        build(rc(cur), mid + <span class="number">1</span>, r);</span><br><span class="line">        push_up(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> x, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l == t[cur].r)&#123;</span><br><span class="line">            a[x] = c;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">59</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                t[cur].f[i] = <span class="number">1</span> + (i % a[x] == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= t[lc(cur)].r)</span><br><span class="line">            modify(lc(cur), x, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            modify(rc(cur), x, c);</span><br><span class="line">        push_up(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt; r || t[cur].r &lt; l)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)&#123;</span><br><span class="line">            <span class="comment">// printf("[%d, %d].f[%d] = %d\n", t[cur].l, t[cur].r, x, t[cur].f[x]);</span></span><br><span class="line">            <span class="keyword">return</span> t[cur].f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ls = query(lc(cur), l, r, x);</span><br><span class="line">        <span class="keyword">return</span> ls + query(rc(cur), l, r, (x + ls) % <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = inp();</span><br><span class="line">    t.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> m = inp();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op = getchar();</span><br><span class="line">        <span class="keyword">while</span>(op != <span class="string">'C'</span> &amp;&amp; op != <span class="string">'A'</span>)</span><br><span class="line">            op = getchar();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = inp();</span><br><span class="line">            <span class="keyword">int</span> c = inp();</span><br><span class="line">            t.modify(<span class="number">1</span>, x, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = inp();</span><br><span class="line">            <span class="keyword">int</span> r = inp() - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.query(<span class="number">1</span>, l, r, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1178G The Awesomest Vertex</title>
      <link href="/2019/07/21/Solutions/Solution-CF1178G/"/>
      <url>/2019/07/21/Solutions/Solution-CF1178G/</url>
      
        <content type="html"><![CDATA[<h3 id="分块-斜率优化"><a href="#分块-斜率优化" class="headerlink" title="分块 + 斜率优化"></a>分块 + 斜率优化</h3><p><del>G真的比F2清真</del></p><p>首先，看到树上 + 子树操作，第一反应使用dfs序拍平。</p><p>那么这个问题就变成了支持：</p><ul><li>区间$a_i += x$</li><li>询问区间$\max\{|a_i| * |b_i|\}$</li></ul><a id="more"></a><p>考虑这个问题如何解决。</p><p>发现$b_i$并不会改变，所以预处理出来$|b_i|$。</p><p>之后考虑如何支持修改$a$，考虑斜率优化。</p><p>对于每个点维护$y = b_ix + a_i * b_i$的直线；</p><p>其中$x$表示的是这个点的$\Delta a_i$。</p><p>但是我们每次询问和修改的都是区间。</p><p>那么考虑分块，对于每个块内维护对应的凸壳。</p><p>然后对于每次修改，暴力重构边缘所在的块，对于中间完整覆盖的块，我们只需要打一个标记，代表这个块内所有东西的$a_i$值都加上了一个值，这样一来对于每块内他的$\Delta$就是一个相等的值，那么查询的时候边缘暴力做，中间可以在凸壳上二分。</p><p>那么还有一个问题：这个绝对值还没有解决。</p><p>$b_i$的问题非常好解决，预处理的时候取一下即可。</p><p>对于$a_i$这是一个取$\max$的问题，所以如果绝对值取反是肯定不优。那么只需要维护两个凸壳分别维护$a_i$取反和不取反的情况即可。</p><p>最终复杂度$O(n \sqrt{n} \log n)$，可能需要一些高超的卡常技巧，这边给一些卡常的技巧好了。</p><ul><li>块大小开小一点（这是最重要的一点），虽然询问时候复杂度是$O(\frac{n}{size} <em> \log{size})$，然后修改的时候暴力重构是$O(size </em> \log size)$的，但是询问的时候那个$\log$严重跑不满，暴力重构的$\log$是排序的，还是比较满的。</li><li>维护凸壳的时候用$vector$，不要用数组（我也不知道为什么，反正这样变快了，$\color{black}{z} \color{red}{xyhh}$大爷说这是高速缓存的问题）。</li></ul><p>最后上一波代码吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 250</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> is_bad(a, m, c) ((m.b - c.b) * (m.k - a.k) &lt;= (a.b - m.b) * (c.k - m.k))</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">int</span> neg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">            neg = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum * neg;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> head[<span class="number">200010</span>], nxt[<span class="number">200010</span>], end[<span class="number">200010</span>], dfn[<span class="number">200010</span>], size[<span class="number">200010</span>];</span><br><span class="line">ll a2[<span class="number">200010</span>], b2[<span class="number">200010</span>], a[<span class="number">200010</span>], b[<span class="number">200010</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> cou = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    nxt[++cou] = head[a];</span><br><span class="line">    head[a] = cou;</span><br><span class="line">    end[cou] = b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ll k;</span><br><span class="line">    ll b;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ll <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * k + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.k &lt; b.k;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Convex</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; s;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s.size() &gt; <span class="number">1</span> &amp;&amp; is_bad(s[s.size() - <span class="number">2</span>], s[s.size() - <span class="number">1</span>], x))</span><br><span class="line">            s.resize(s.size() - <span class="number">1</span>);</span><br><span class="line">        s.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1e18</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[mid].get(x) &lt;= s[mid + <span class="number">1</span>].get(x))</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[l].get(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        s.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;c[<span class="number">1000</span>], cf[<span class="number">1000</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ql[<span class="number">1000</span>], qr[<span class="number">1000</span>];</span><br><span class="line">ll delta[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vec.clear();</span><br><span class="line">    c[x].clear();</span><br><span class="line">    cf[x].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ql[x]; i &lt;= qr[x]; i++)&#123;</span><br><span class="line">        a[i] += delta[x];</span><br><span class="line">        vec.push_back((Node)&#123;b[i], a[i] * b[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(vec.begin(), vec.end(), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</span><br><span class="line">        c[x].insert(vec[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</span><br><span class="line">        cf[x].insert((Node)&#123;vec[i].k, -vec[i].b&#125;);</span><br><span class="line">    delta[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    dfn[cur] = ++idx;</span><br><span class="line">    size[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = head[cur]; x != <span class="number">-1</span>; x = nxt[x])&#123;</span><br><span class="line">        a[end[x]] += a[cur];</span><br><span class="line">        b[end[x]] += b[cur];</span><br><span class="line">        dfs(end[x]);</span><br><span class="line">        size[cur] += size[end[x]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">int</span> q = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = inp();</span><br><span class="line">        link(fa, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        b[i] = inp();</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(a2, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memcpy</span>(b2, b, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[dfn[i]] = a2[i];</span><br><span class="line">        b[dfn[i]] = <span class="built_in">abs</span>(b2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    qr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(qr[cur - <span class="number">1</span>] &lt; n)&#123;</span><br><span class="line">        ql[cur] = qr[cur - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        qr[cur] = ql[cur] + SIZE - <span class="number">1</span>;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    qr[cur - <span class="number">1</span>] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cur; i++)</span><br><span class="line">        rebuild(i);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op = inp();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = inp();</span><br><span class="line">            ll x = inp();</span><br><span class="line">            <span class="keyword">int</span> l = dfn[v];</span><br><span class="line">            <span class="keyword">int</span> r = dfn[v] + size[v] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> lb = (l - <span class="number">1</span>) / SIZE + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rb = (r - <span class="number">1</span>) / SIZE + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(lb == rb)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">                    a[i] += x;</span><br><span class="line">                rebuild(lb);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = lb + <span class="number">1</span>; i &lt; rb; i++)</span><br><span class="line">                    delta[i] += x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= qr[lb]; i++)</span><br><span class="line">                    a[i] += x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = ql[rb]; i &lt;= r; i++)</span><br><span class="line">                    a[i] += x;</span><br><span class="line">                rebuild(lb);</span><br><span class="line">                rebuild(rb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> v = inp();</span><br><span class="line">            <span class="keyword">int</span> l = dfn[v];</span><br><span class="line">            <span class="keyword">int</span> r = dfn[v] + size[v] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> lb = (l - <span class="number">1</span>) / SIZE + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rb = (r - <span class="number">1</span>) / SIZE + <span class="number">1</span>;</span><br><span class="line">            ll ans = <span class="number">-1e18</span>;</span><br><span class="line">            <span class="keyword">if</span>(lb == rb)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">                    ans = <span class="built_in">std</span>::max(ans, <span class="built_in">abs</span>(a[i] + delta[lb]) * b[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = lb + <span class="number">1</span>; i &lt; rb; i++)&#123;</span><br><span class="line">                    ans = <span class="built_in">std</span>::max(ans, c[i].query(delta[i]));</span><br><span class="line">                    ans = <span class="built_in">std</span>::max(ans, cf[i].query(-delta[i]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= qr[lb]; i++)</span><br><span class="line">                    ans = <span class="built_in">std</span>::max(ans, <span class="built_in">abs</span>(a[i] + delta[lb]) * b[i]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = ql[rb]; i &lt;= r; i++)</span><br><span class="line">                    ans = <span class="built_in">std</span>::max(ans, <span class="built_in">abs</span>(a[i] + delta[rb]) * b[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> 分块 </tag>
            
            <tag> DFS序. </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1183H Subsequences (hard version)</title>
      <link href="/2019/06/27/Solutions/Solution-CF1183H/"/>
      <url>/2019/06/27/Solutions/Solution-CF1183H/</url>
      
        <content type="html"><![CDATA[<h2 id="瞎搞DP"><a href="#瞎搞DP" class="headerlink" title="瞎搞DP"></a>瞎搞DP</h2><p><del>CF出了H没出G 菜的真实</del></p><p>发现$k$从$\texttt{E}$题的$100$变成了$O(10^{12})$，考虑与$k$复杂度无关的做法。</p><p>我们考虑$f_{i, j}$表示以$s_i$开始，<strong>本质不同</strong>的长度为$j$的子序列数量。</p><a id="more"></a><p>显然直接转移是错误的，例如下面这种情况就会在计算字符串$\texttt{baa}$的$f_{1, 2}$的时候把$\texttt{ba}$给计算两遍。</p><p>我们考虑如何去掉这些重复算的字符串。</p><p>首先，我们枚举下一个出现的位置$u$，考虑$f_{u, j - 1}$被算重的条件。</p><p>如果存在一个$k$，使得$s_k = s_j$且$i &lt; k &lt; u$，那么我们发现$f_{k, j - 1}$完全包含的$f_{u, j - 1}$，换句话说就是$f_{u, j - 1}$整个算重了。</p><p>也就是说，我们在枚举转移的时候，我们只需要选择$s_u$是在$(l, n]$这段区间内第一次出现的$f_{u, j - 1}$转移即可。</p><p>求出了$f$之后，我们可以得出长度为$len$的本质不同的子序列就是$f[0][len + 1]$。</p><p>我们只需要从高到低枚举$len$，然后贪心的尽量取长的字符串即可。</p><p>最终复杂度$O(n^3)$（其实是可以做到$O(26 n^2)$的，但是过了就行）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c =getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    ll k = inp();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n + <span class="number">1</span>; len++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span>(!used[s[j] - <span class="string">'a'</span>])&#123;</span><br><span class="line">                    used[s[j] - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">                    f[i][len] += f[j][len - <span class="number">1</span>];</span><br><span class="line">                    f[i][len] = <span class="built_in">std</span>::min(f[i][len], k);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        ll sum = f[<span class="number">0</span>][i + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="keyword">if</span>(k &gt; sum)&#123;</span><br><span class="line">            k -= sum;</span><br><span class="line">            ans += (n - i) * sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (n - i) * k;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF240F TorCoder</title>
      <link href="/2019/06/03/Solutions/Solution-CF240F/"/>
      <url>/2019/06/03/Solutions/Solution-CF240F/</url>
      
        <content type="html"><![CDATA[<h2 id="线段树乱搞"><a href="#线段树乱搞" class="headerlink" title="线段树乱搞"></a>线段树乱搞</h2><p>考虑如果要重排一段区间使得它是回文的是可行的</p><p>首先对这段区间的长度分类讨论</p><a id="more"></a><p>如果它的长度是奇数，那么在这个区间的数肯定满足以下条件：</p><ul><li>有一个字母出现了奇数次（这个放在最中间）</li><li>其他的出现了偶数次（放在旁边）</li></ul><p>如果它的长度是偶数，那么这个区间内出现过的数肯定都出现过了偶数次</p><p>再考虑如何构造</p><ul><li>如果长度是奇数，把那个出现了奇数次的数放一个在最中间</li><li>枚举A~Z，从最左和最右分别开始一直放（因为需要保证字典序最小）</li></ul><p>容易发现这只需要线段树维护区间每个字母的出现次数就行了（也可以理解成26棵线段树）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(a) ((a) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(a) ((a) &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> lazy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line">SEG <span class="keyword">operator</span> + (SEG a, SEG b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.l == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span>(b.l == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    SEG ret;</span><br><span class="line">    ret.l = a.l;</span><br><span class="line">    ret.r = b.r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        ret.sum[i] = a.sum[i] + b.sum[i];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG_Tree</span>&#123;</span></span><br><span class="line">    SEG t[<span class="number">800010</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            t[cur].sum[i] = t[lc(cur)].sum[i] + t[rc(cur)].sum[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        t[cur].lazy = <span class="number">-1</span>;</span><br><span class="line">        t[cur].l = l;</span><br><span class="line">        t[cur].r = r;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            t[cur].clear();</span><br><span class="line">            t[cur].sum[s[l] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(lc(cur), l, mid);</span><br><span class="line">        build(rc(cur), mid + <span class="number">1</span>, r);</span><br><span class="line">        push_up(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].lazy != <span class="number">-1</span>)&#123;</span><br><span class="line">            t[lc(cur)].clear();</span><br><span class="line">            t[rc(cur)].clear();</span><br><span class="line">            t[lc(cur)].sum[t[cur].lazy] = t[lc(cur)].r - t[lc(cur)].l + <span class="number">1</span>;</span><br><span class="line">            t[rc(cur)].sum[t[cur].lazy] = t[rc(cur)].r - t[rc(cur)].l + <span class="number">1</span>;</span><br><span class="line">            t[lc(cur)].lazy = t[rc(cur)].lazy = t[cur].lazy;</span><br><span class="line">        &#125;</span><br><span class="line">        t[cur].lazy = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        SEG nul;</span><br><span class="line">        nul.l = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt; r || t[cur].r &lt; l)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        push_down(cur);</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                cnt[i] += t[cur].sum[i];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        query(lc(cur), l, r);</span><br><span class="line">        query(rc(cur), l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt; r || t[cur].r &lt; l)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)&#123;</span><br><span class="line">            t[cur].clear();</span><br><span class="line">            t[cur].sum[c] = t[cur].r - t[cur].l + <span class="number">1</span>;</span><br><span class="line">            t[cur].lazy = c;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(cur);</span><br><span class="line">        modify(lc(cur), l, r, c);</span><br><span class="line">        modify(rc(cur), l, r, c);</span><br><span class="line">        push_up(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l == t[cur].r)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(t[cur].sum[i])</span><br><span class="line">                    <span class="built_in">putchar</span>(<span class="string">'a'</span> + i);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(cur);</span><br><span class="line">        print(lc(cur));</span><br><span class="line">        print(rc(cur));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"input.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"output.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">int</span> q = inp();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    t.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = inp();</span><br><span class="line">        <span class="keyword">int</span> r = inp();</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        t.query(<span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>((r - l + <span class="number">1</span>) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cs = <span class="number">0</span>, num;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    cs++;</span><br><span class="line">                    num = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cs == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                t.modify(<span class="number">1</span>, mid, mid, num);</span><br><span class="line">                <span class="keyword">int</span> cc = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[i] &lt;= <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> c2 = cc + (cnt[i] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    t.modify(<span class="number">1</span>, l + cc, l + c2 - <span class="number">1</span>, i);</span><br><span class="line">                    t.modify(<span class="number">1</span>, r - c2 + <span class="number">1</span>, r - cc, i);</span><br><span class="line">                    cc = c2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> cs = <span class="number">0</span>, num = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    cs++;</span><br><span class="line">                    num = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cs == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> cc = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> c2 = cc + (cnt[i] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    t.modify(<span class="number">1</span>, l + cc, l + c2 - <span class="number">1</span>, i);</span><br><span class="line">                    t.modify(<span class="number">1</span>, r - c2 + <span class="number">1</span>, r - cc, i);</span><br><span class="line">                    cc = c2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.print(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1051E Vasya and Big Integers</title>
      <link href="/2019/05/28/Solutions/Solution-CF1051E/"/>
      <url>/2019/05/28/Solutions/Solution-CF1051E/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希-二分-DP"><a href="#哈希-二分-DP" class="headerlink" title="哈希 + 二分 + DP"></a>哈希 + 二分 + DP</h2><p>首先看到题面，很容易想到一个$DP$，令$f[i]$为划分到$i$为止的方案数。</p><p>然后朴素的暴力转移是$O(n^2)$的，非常显然一个状态$i$能够转移到的$j$是一段连续的，进而想到使用前缀和优化。</p><a id="more"></a><p>令$l$的长度为$sl$，$r$的长度为$sr$，那么长度为$len$（$sl &lt; len &lt; sr$）的一段数字$s$必定满足$l &lt; s &lt; r$。然后那么我们只需要考虑当前状态$i$的时候$[i, i + sl)$和$[i,i + sr)$这两段区间分别和$l,r$的大小关系。</p><p>如果我们我们要比较两个字符串$a$和$b$的大小关系，我们完全先特判掉两个完全一样的情况，然后再求出它们的$lcp$，然后那么$a$和$b$的大小关系就是$a[lcp + 1]$和$b[lcp + 1]$的大小关系了。</p><p>$lcp$可以哈希 + 二分解决，接下来的事情就是$DP$的了</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> px 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(a, b) ((ll)(a) * (ll)(b) % mod)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000010</span>], l[<span class="number">1000010</span>], r[<span class="number">1000010</span>];</span><br><span class="line">ll f[<span class="number">1000010</span>], sum[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> n, sl, sr, pl[<span class="number">1000010</span>], pr[<span class="number">1000010</span>], hshs[<span class="number">1000010</span>], hshl[<span class="number">1000010</span>], hshr[<span class="number">1000010</span>], fpow[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x + sl - <span class="number">1</span> &gt; n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(sl == pl[x])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> l[pl[x] + <span class="number">1</span>] &lt; s[x + pl[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x + sr - <span class="number">1</span> &gt; n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(pr[x] == sr)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> r[pr[x] + <span class="number">1</span>] &gt; s[x + pr[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_hsh</span><span class="params">(<span class="keyword">int</span> *hsh, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hsh[r] - mul(hsh[l - <span class="number">1</span>], fpow[r - l + <span class="number">1</span>]) + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *s, <span class="keyword">int</span> *hsh, <span class="keyword">int</span> len)</span></span>&#123; <span class="comment">// 求lcp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = len;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(get_hsh(hshs, i, i + mid - <span class="number">1</span>) == get_hsh(hsh, <span class="number">1</span>, mid))</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gethash</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *hsh, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        hsh[i] = ((ll)(hsh[i - <span class="number">1</span>]) * (ll)(px) + str[i] - <span class="string">'0'</span> + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fpow[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++)</span><br><span class="line">        fpow[i] = mul(fpow[i - <span class="number">1</span>], px);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, r + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    sl = <span class="built_in">strlen</span>(l + <span class="number">1</span>);</span><br><span class="line">    sr = <span class="built_in">strlen</span>(r + <span class="number">1</span>);</span><br><span class="line">    gethash(l, hshl, sl);</span><br><span class="line">    gethash(r, hshr, sr);</span><br><span class="line">    gethash(s, hshs, n);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    solve(pl, hshl, sl);</span><br><span class="line">    solve(pr, hshr, sr);</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; i++)</span></span><br><span class="line">    <span class="comment">//     printf("%d ", pl[i]);</span></span><br><span class="line">    <span class="comment">// putchar('\n');</span></span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; i++)</span></span><br><span class="line">    <span class="comment">//     printf("%d ", pr[i]);</span></span><br><span class="line">    <span class="comment">// putchar('\n');</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i)&#123;</span><br><span class="line">            sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">            f[i] += sum[i];</span><br><span class="line">            f[i] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf("f[%d] = %d\n", i, f[i]);</span></span><br><span class="line">        <span class="keyword">if</span>(s[i + <span class="number">1</span>] == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sl == <span class="number">1</span> &amp;&amp; l[<span class="number">1</span>] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                f[i + <span class="number">1</span>] += f[i];</span><br><span class="line">                f[i + <span class="number">1</span>] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt; sr)&#123;</span><br><span class="line">            sum[sl + i + <span class="number">1</span>] += f[i];</span><br><span class="line">            sum[sl + i + <span class="number">1</span>] %= mod;</span><br><span class="line">            sum[sr + i] += mod - f[i];</span><br><span class="line">            sum[sr + i] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sl == sr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ok1(i + <span class="number">1</span>) &amp;&amp; ok2(i + <span class="number">1</span>))&#123;</span><br><span class="line">                f[i + sl] += f[i];</span><br><span class="line">                f[i + sl] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(ok1(i + <span class="number">1</span>))&#123;</span><br><span class="line">                f[i + sl] += f[i];</span><br><span class="line">                f[i + sl] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok2(i + <span class="number">1</span>))&#123;</span><br><span class="line">                f[i + sr] += f[i];</span><br><span class="line">                f[i + sr] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf("f[%d] = %d\n", i, f[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF15D Map</title>
      <link href="/2019/05/08/Solutions/Solution-CF15D/"/>
      <url>/2019/05/08/Solutions/Solution-CF15D/</url>
      
        <content type="html"><![CDATA[<h2 id="set-瞎搞"><a href="#set-瞎搞" class="headerlink" title="$set$ 瞎搞"></a>$set$ 瞎搞</h2><p>首先非常显然，一个矩形$(x1, y1, x2, y2)$的代价就是$\displaystyle\sum_{i = x1}^{x2}\sum_{j = y1}^{y2} h[i][j] - \min_{x1 \le i \le x2, y1 \le j \le y2} h[i][j]$，我们用$f[i][j]$表示以$(i, j)$为左上角的矩形的代价。即矩形$(i, j, i + a - 1, j + b - 1)$的代价。</p><p>我们首先考虑如何求出$f[i][j]$。</p><a id="more"></a><p>前面的求和可以一个二维前缀和简单解决，关键在于后面的$\min$。</p><p>我们对每行都建一个$st$表，考虑我们把当前我们要求的区间里的$h[i][j]$都丢进一个$set$中。</p><p>我们考虑每次把矩形往下移动。</p><p>发现其实对于每一行，只有它的在范围内的最小值才有贡献，所$set$中只需要放每行的最小值（可以用$st$表快速查询）。</p><p>我们再考虑如下图所示。</p><p><img src="https://dilute.xyz/images/3.png" alt></p><p>然后如果我们要从蓝色矩形移动到黑色矩形，那么我们只需要在$set$中删去灰色部分的最小值，再加入浅蓝色部分的最小值即可。</p><p>求出了$f[i][j]$之后就可以按题意模拟了w</p><p>每次我们可以找出$f[i][j]$的最小值，这个排遍序轻松解决（<del>我之前作死用set被卡常了</del>）然后给所有因为这个矩形被取到了导致不能取的打上标记，这样子时间复杂度是正确的，最多只会被取到$\frac{n m}{ab}$个矩形，然后每次打标记是$O(a * b)$的，最后复杂度就是$O(\frac{n m}{a b} a b) = O(n m)$的。</p><p>复杂度$O(n m \log n)$，轻微卡常w</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>][<span class="number">1010</span>][<span class="number">12</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;ll&gt; s2;</span><br><span class="line"><span class="keyword">int</span> ans1[<span class="number">1000010</span>], ans2[<span class="number">1000010</span>], h[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">ll ans3[<span class="number">1000010</span>], sum[<span class="number">1010</span>][<span class="number">1010</span>], val[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lg = log2(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::min(f[x][l][lg], f[x][r - (<span class="number">1</span> &lt;&lt; lg) + <span class="number">1</span>][lg]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val[a.first][a.second] == val[b.first][b.second])</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    <span class="keyword">return</span> val[a.first][a.second] &lt; val[b.first][b.second];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">int</span> m = inp();</span><br><span class="line">    <span class="keyword">int</span> a = inp();</span><br><span class="line">    <span class="keyword">int</span> b = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            f[i][j][<span class="number">0</span>] = h[i][j] = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= <span class="number">10</span>; u++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">if</span>(j + (<span class="number">1</span> &lt;&lt; u) - <span class="number">1</span> &lt;= m)</span><br><span class="line">                    f[i][j][u] = <span class="built_in">std</span>::min(f[i][j][u - <span class="number">1</span>], f[i][j + (<span class="number">1</span> &lt;&lt; (u - <span class="number">1</span>))][u - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + h[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - b + <span class="number">1</span>; j++)&#123;</span><br><span class="line">        s2.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line">            s2.insert(query(i, j, j + b - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - a + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            val[i][j] = sum[i + a - <span class="number">1</span>][j + b - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j - <span class="number">1</span>] - sum[i + a - <span class="number">1</span>][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j + b - <span class="number">1</span>] - (*(s2.begin())) * (a * b);</span><br><span class="line">            s2.erase(s2.find(query(i, j, j + b - <span class="number">1</span>)));</span><br><span class="line">            <span class="keyword">if</span>(i + a &lt;= n)</span><br><span class="line">                s2.insert(query(i + a, j, j + b - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - a + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - b + <span class="number">1</span>; j++)</span><br><span class="line">            s[++cc] = <span class="built_in">std</span>::make_pair(i, j);</span><br><span class="line">    <span class="built_in">std</span>::sort(s + <span class="number">1</span>, s + cc + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= cc; u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(used[s[u].first][s[u].second])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        ans1[cnt] = s[u].first;</span><br><span class="line">        ans2[cnt] = s[u].second;</span><br><span class="line">        ans3[cnt] = val[s[u].first][s[u].second];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ans1[cnt] - a + <span class="number">1</span>; i &lt;= ans1[cnt] + a - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = ans2[cnt] - b + <span class="number">1</span>; j &lt;= ans2[cnt] + b - <span class="number">1</span>; j++)</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; !used[i][j] &amp;&amp; i &lt;= n - a + <span class="number">1</span> &amp;&amp; j &lt;= m - b + <span class="number">1</span>)</span><br><span class="line">                    used[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %I64d\n"</span>, ans1[i], ans2[i], ans3[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJOI2019 游记</title>
      <link href="/2019/04/27/Other/ZJOI2019-Journey/"/>
      <url>/2019/04/27/Other/ZJOI2019-Journey/</url>
      
        <content type="html"><![CDATA[<h1 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h1><p>咕咕咕。</p><p>回头再补。</p><a id="more"></a><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>咕咕咕</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>咕咕咕</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>咕咕咕</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>比赛日。</p><p>密码暗示JYB政策？（河蟹警告）</p><p>不管了 题最重要</p><p>还没解压密码的时候就看到有一题文件名叫做$mahjong$。</p><p>打开题面，第一反应<del>八木唯好可爱啊awsl</del></p><p>我想着这个暴力应该不会太难敲（flag × 1）于是就开始敲这个T1</p><p>后来发现其实很大的一个瓶颈在于判断和牌，本来想法的“瞎jb判不就行了吗”被频繁$hack$，最后权衡再三写了个肯定对但是难敲的要死的5进制状压每种牌的数量。</p><h2 id="Day-懒得算"><a href="#Day-懒得算" class="headerlink" title="Day (懒得算)"></a>Day (懒得算)</h2><p>出成绩惹。。。</p><p>果然T1挂掉了</p><p>以后再也不敢开麻将斗地主一类的毒瘤题了。。。</p><p>最终成绩的$0 + 20 + 10 = 30\ pts$</p><h1 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h1><h2 id="Day-0-1"><a href="#Day-0-1" class="headerlink" title="Day 0"></a>Day 0</h2><p>颓废了一个上午，中午跟同学一起叫外卖肯德基结果发现就自己没有汉堡？？？只能吃点其他东西垫着算了。</p><p>接着坐车到了余姚中学。</p><p>然后又跟<code>xay5421</code> <code>_QAQ</code> <code>LJC00118</code>三个神仙打了一下午 + 晚上mc。</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>早上听讲课，日常听不懂，跟好久不见的<code>Venus</code>小姐姐面基了。结果她就直接坐在我旁边了，讲课的时间就在各种花式听不懂 + 颓废中度过了。</p><p>晚上<code>zxy_hhhh</code>想找我打LOL，结果我电脑容量太小了，装不下，于是他们去找<code>_QAQ</code>去了。</p><p>于是又打了一个晚上的MC，还顺便看了看盾勇<del>没网上说的那么糟糕啊</del></p><h2 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h2><p>上午我校高三巨野讲课，然而还是那样听不太懂，中午吃完饭，回到礼堂，<code>zxy_hhhh</code>看到地上躺着一个人，惊呼</p><blockquote><p>艹这不是Venus吗</p></blockquote><p>后面xxc（吹雪吹雪吹）做了一些奇奇怪怪的事情就不说了。</p><p>回到宾馆，<code>_QAQ</code>的LOL下好了，于是<code>_QAQ</code>，<code>Sooke</code>，<code>Venus</code>，<code>zxy_hhhh</code>和一个不知道网名的学长就开始五黑了。然后我就在<code>_QAQ</code>的房间里看他打。</p><p><code>_QAQ</code>拿了个剑圣正常地打了半把，LJ开始查房了。当时LJ查到他们房间的时候，<code>_QAQ</code>打LOL被石锤了，LJ还说</p><blockquote><p>撸啊撸我不认识啊？</p></blockquote><p>然后<code>_QAQ</code>跟啥都没发生一样继续打了。</p><p><del>结果他们就因为LJ查房输了。</del></p><p><code>_QAQ</code>后来开始玩快乐瑞兹，这里我整理一下他的语录。</p><blockquote><p>你瑞兹爸爸来了！（0/12/1）</p><p>啊～诺手鸽鸽带带我～诺手鸽鸽～</p><p>我觉得我能秒掉他！</p><p>这瑞兹是什么垃圾英雄！</p></blockquote><p><del>据某位不愿透露姓名的认识表示他的瑞兹连招QAAAAAA</del></p><h2 id="Day-3-1"><a href="#Day-3-1" class="headerlink" title="Day 3"></a>Day 3</h2><p>比赛日。</p><p>进考场，开题。</p><p>解压包密码看不懂还贼难输<del>考场老师还写错了一次</del>，输错*n，心情极差。</p><p>看到这个T1，一眼看出应该是个状压DP之类做的暴力，但是显然这玩意是有后效性的，所以必须得加个高斯消元，暴力复杂度是$O(8^n)$的，只能过$n \leq 8$的点，可可能优化之后是个治疗之雨状物？不知道，但是看上去不太好做的样子，所以先跳过。</p><p>一看T2，这题一看就比T1清真多了。一个显然的结论是一个点对$(a, b)$是合法的当且仅当存在给出的路径$c, d$包含$a, b$这条路径。枚举其中一个点，然后我们考虑所有穿过当前枚举的点$a$的给出路径，显然只有这些路径上的点是合法的，然后这么写就可以得到$O(n^2)$的优秀复杂度。链的情况非常好想，再花了点时间写了个对拍，直接$40 + 20 = 60$分到手。</p><p>之后试着想了想T2的正解，觉得可能是个树链剖分 + 容斥之类的玩意儿，反正我想不出来，滚粗。</p><p>接下来开T3，看上去像个类斜率优化之类的奇怪玩意儿，显然可以把每个人看成一根线段，那么反向选拔度就是横坐标。首先把$a_j \geq a_i, b_j \geq b_i​$的人提前判掉，因为他们是不可能被超过的。可以想到一个人分数比另一个人高可以表示为一个交点，换句话说也可以吧表示为一个约束条件。</p><p>约束条件只有$x \leq k$和$x \geq k​$两种。我们枚举第一种满足多少个，就可以得出第二种满足多少个，那么就可以得出一个人最多超过多少人，换句话说就是一个人的最高排名。</p><p>这时比赛还剩1个小时，虽然T3的$m = 1$部分分直接一个凸壳解决，但是只有$10$分并且也不好敲，我决定还是去做$T1$。</p><p>$T1​$的方程列错了n次，最后开始写高消的时候一个小时已经过去一半了，最后都没过$n = 8​$的样例。没办法，手动推了个$n = 2​$的柿子交上去滚粗了。</p><p>期望得分$20 + 60 + 40 = 120\ pts​$</p><h2 id="Day-（懒得算）"><a href="#Day-（懒得算）" class="headerlink" title="Day （懒得算）"></a>Day （懒得算）</h2><p>出成绩惹…<br>最终得分$20 + 40 + 40 = 100\ pts$ 我T2的链都打挂了，我果然太菜了嘤</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF609F Frogs and mosquitoes</title>
      <link href="/2019/04/22/Solutions/Solution-CF609F/"/>
      <url>/2019/04/22/Solutions/Solution-CF609F/</url>
      
        <content type="html"><![CDATA[<h2 id="set​瞎搞"><a href="#set​瞎搞" class="headerlink" title="set​瞎搞"></a>set​瞎搞</h2><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>我们考虑一下，一只青蛙能够影响的区间是什么</p><p>我们发现，如果将每只青蛙能够吃到的文字区间$[l, r]$按照左端点$l$排序，然后把后面的区间和前面的区间的重复部分去掉，那么就可以得到一个青蛙真正可以吃到的蚊子的范围区间</p><a id="more"></a><p>我觉得下面这张图讲的很清楚w</p><p><img src="http://dilute.xyz/images/2.png" alt></p><p>好，那么我们的预处理就这么完了。</p><h4 id="加入蚊子"><a href="#加入蚊子" class="headerlink" title="加入蚊子"></a>加入蚊子</h4><p>我们采用$set​$维护所有青蛙能够真正吃到的蚊子的范围区间，那么在加入一只蚊子的时候，可以lower_bound快速求出这只蚊子会不会被吃掉，如果它被吃掉了，是被哪只青蛙吃掉了。</p><p>显然，如果一只蚊子被吃掉了，那么吃掉它的哪只青蛙和其他青蛙可以吃到的蚊子的范围区间都会变化，那么我们只要从当前更新过的哪只青蛙的范围向后找，把所有被当前区间所包含的区间全都删除，最后再调整一下没有被完全覆盖的区间的左端点。</p><h4 id="还有一点"><a href="#还有一点" class="headerlink" title="还有一点"></a>还有一点</h4><p>这道题有一个非常恶心的设定：蚊子如果没有被吃掉，它会待在原地，直到被某只青蛙吃掉为止。</p><p>这让我们再用一个$set$维护当前没有被吃掉的蚊子，然后在前面吃掉一只蚊子，区间变长的时候，在储存蚊子的那个$set$里面lower_bound一下判断是否能够再吃掉其他的蚊子，等确定没有蚊子可吃的时候再去判断后面的区间是否被更新。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>我实现的丑的要命，反正跑得过去就行，轻喷…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l == b.l)</span><br><span class="line">            <span class="keyword">return</span> r &gt; b.r;</span><br><span class="line">        <span class="keyword">return</span> l &lt; b.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node&gt; s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; s2;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">200010</span>], x[<span class="number">200010</span>], t[<span class="number">200010</span>], p[<span class="number">200010</span>], b[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node&gt;::iterator <span class="keyword">operator</span> + (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node&gt;::iterator it, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)&#123;</span><br><span class="line">    it++;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node&gt;::iterator <span class="keyword">operator</span> - (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node&gt;::iterator it, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)&#123;</span><br><span class="line">    it--;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x[a] &lt; x[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">int</span> m = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        x[i] = inp();</span><br><span class="line">        t[i] = inp();</span><br><span class="line">        id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">    s.insert((Node)&#123;x[id[<span class="number">1</span>]], x[id[<span class="number">1</span>]] + t[id[<span class="number">1</span>]], id[<span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">std</span>::max(s.rbegin()-&gt;r + <span class="number">1</span>, x[id[i]]) &lt;= x[id[i]] + t[id[i]])</span><br><span class="line">            s.insert((Node)&#123;<span class="built_in">std</span>::max(s.rbegin()-&gt;r + <span class="number">1</span>, x[id[i]]), x[id[i]] + t[id[i]], id[i]&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        p[i] = inp();</span><br><span class="line">        b[i] = inp();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node&gt;::iterator it = s.upper_bound((Node)&#123;p[i], p[i]&#125;);</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;r &gt;= p[i] &amp;&amp; it-&gt;l &lt;= p[i])&#123;</span><br><span class="line">            t[it-&gt;id] += b[i];</span><br><span class="line">            ans[it-&gt;id]++;</span><br><span class="line">            Node nxt = *it;</span><br><span class="line">            s.erase(it);</span><br><span class="line">            s.insert((Node)&#123;nxt.l, nxt.r + b[i], nxt.id&#125;);</span><br><span class="line">            it = s.find((Node)&#123;nxt.l, nxt.r + b[i], nxt.id&#125;);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator it2 = s2.lower_bound(<span class="built_in">std</span>::make_pair(it-&gt;l, <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">while</span>(it2 != s2.end() &amp;&amp; it2-&gt;first &lt;= it-&gt;r)&#123;</span><br><span class="line">                t[it-&gt;id] += it2-&gt;second;</span><br><span class="line">                ans[it-&gt;id]++;</span><br><span class="line">                Node nxt = *it;</span><br><span class="line">                s.erase(it);</span><br><span class="line">                s.insert((Node)&#123;nxt.l, nxt.r + it2-&gt;second, nxt.id&#125;);</span><br><span class="line">                it = s.find((Node)&#123;nxt.l, nxt.r + it2-&gt;second, nxt.id&#125;);</span><br><span class="line">                s2.erase(it2);</span><br><span class="line">                it2 = s2.lower_bound(<span class="built_in">std</span>::make_pair(it-&gt;l, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>((it + <span class="number">1</span>) != s.end() &amp;&amp; it-&gt;r &gt;= (it + <span class="number">1</span>)-&gt;r)</span><br><span class="line">                s.erase(it + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((it + <span class="number">1</span>) != s.end())&#123;</span><br><span class="line">                Node nxt = *(it + <span class="number">1</span>);</span><br><span class="line">                s.erase(it + <span class="number">1</span>);</span><br><span class="line">                s.insert((Node)&#123;<span class="built_in">std</span>::max(nxt.l, it-&gt;r + <span class="number">1</span>), nxt.r, nxt.id&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            s2.insert(<span class="built_in">std</span>::make_pair(p[i], b[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans[i], t[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OI Journal</title>
      <link href="/2019/04/18/Other/Problems/"/>
      <url>/2019/04/18/Other/Problems/</url>
      
        <content type="html"><![CDATA[<p>看到学长txc爷的blog里写了个“最近写的题目”</p><p>然后心血来潮准备自己也弄个这个东西</p><a id="more"></a><h2 id="2019-11-3"><a href="#2019-11-3" class="headerlink" title="2019.11.3"></a>2019.11.3</h2><h4 id="Codeforces-557I"><a href="#Codeforces-557I" class="headerlink" title="Codeforces 557I"></a><a href="https://codeforces.com/contest/575/problem/I" target="_blank" rel="noopener">Codeforces 557I</a></h4><p>发现 BIT 可以实现平行四边形修改（把坐标系扭转一下，也就是把 $(x ,y)$ 映射到 $(x , x + y)$），考虑在超过边界的时候平行四边形可以被认为是一个直角梯形。直角梯形加，矩形减，用二维 BIT 维护，就能达到三角形加的效果。</p><h2 id="2019-11-2"><a href="#2019-11-2" class="headerlink" title="2019.11.2"></a>2019.11.2</h2><h4 id="Codeforces-997E"><a href="#Codeforces-997E" class="headerlink" title="Codeforces 997E"></a><a href="https://codeforces.com/contest/997/problem/E" target="_blank" rel="noopener">Codeforces 997E</a></h4><p>考虑题目中要求的子串满足 $\max - \min = r - l$，把询问离线下来，枚举右端点，维护 $(\max - \min) - (r - l)= 0$ 的个数，本质就是维护最小值出现次数，注意打标记实现前缀和统计。</p><h2 id="2019-11-1"><a href="#2019-11-1" class="headerlink" title="2019.11.1"></a>2019.11.1</h2><h4 id="Codeforces-585E"><a href="#Codeforces-585E" class="headerlink" title="Codeforces 585E"></a><a href="https://codeforces.com/contest/585/problem/E" target="_blank" rel="noopener">Codeforces 585E</a></h4><p>枚举前一半数的 $\gcd$ ，那么先算前一半数必须要在 $\gcd$ 的倍数中取，后面的数不在 $\gcd$ 的倍数中取的方案数，然后容斥，发现容斥系数正好是 $\mu$ ，证明可以感性理解（捂脸）。</p><h2 id="2019-10-31"><a href="#2019-10-31" class="headerlink" title="2019.10.31"></a>2019.10.31</h2><h4 id="Codeforces-587D"><a href="#Codeforces-587D" class="headerlink" title="Codeforces 587D"></a><a href="https://codeforces.com/contest/587/problem/D" target="_blank" rel="noopener">Codeforces 587D</a></h4><p>前来膜拜一波神仙学长 txc 的集训队作业。</p><p>对于每个点，如果连着他的一条边被割了，那么与之相连的其他边都不能被割。</p><p>对于每个点连着的边的每种颜色，如果其中一条边没有被割，其他边都必须被割。</p><p>二分 + 前后缀和优化建图 + 2-SAT 即可。</p><h2 id="2019-10-21"><a href="#2019-10-21" class="headerlink" title="2019.10.21"></a>2019.10.21</h2><h4 id="Codeforces-576D"><a href="#Codeforces-576D" class="headerlink" title="Codeforces 576D"></a><a href="https://codeforces.com/contest/576/problem/D" target="_blank" rel="noopener">Codeforces 576D</a></h4><p>对于每个存在某个航班从不可用到可用的分界点专门拿出来考虑。</p><p>中间可以用 floyd + 矩阵乘法 维护每个点可不可以在这个时刻到达，可以用bitset优化。</p><p>对于每个分界点跑一遍多源最短路即可。</p><h2 id="2019-10-20"><a href="#2019-10-20" class="headerlink" title="2019.10.20"></a>2019.10.20</h2><h4 id="Codeforces-1239C"><a href="#Codeforces-1239C" class="headerlink" title="Codeforces 1239C"></a><a href="https://codeforces.com/contest/1239/problem/C" target="_blank" rel="noopener">Codeforces 1239C</a></h4><p>使用一个堆维护下一个发生的事件即可。</p><h2 id="2019-10-12"><a href="#2019-10-12" class="headerlink" title="2019.10.12"></a>2019.10.12</h2><h4 id="Codeforces-954I"><a href="#Codeforces-954I" class="headerlink" title="Codeforces 954I"></a><a href="https://codeforces.com/contest/954/problem/I" target="_blank" rel="noopener">Codeforces 954I</a></h4><p>$\Theta(6^2)$ 的枚举两个字符，然后发现如果在这个子串中存在 $s[i] \neq t[i]$ 则表示有必要把 $s[i]$ 和 $t[i]$ 两种字符合并，存不存在可以写成卷积性质然后 FFT / NTT 解决，后半部分可以并查集。</p><h2 id="2019-10-8"><a href="#2019-10-8" class="headerlink" title="2019.10.8"></a>2019.10.8</h2><h4 id="Codeforces-573E"><a href="#Codeforces-573E" class="headerlink" title="Codeforces 573E"></a><a href="http://codeforces.com/problemset/problem/573/E" target="_blank" rel="noopener">Codeforces 573E</a></h4><p>发现肯定存在一个分界点，左边不取，右边去，然后就可以平衡树维护了。严格证明在<a href="https://www.luogu.org/blog/Mrsrz/solution-cf573e" target="_blank" rel="noopener">这篇题解</a>里有。</p><h2 id="2019-10-3"><a href="#2019-10-3" class="headerlink" title="2019.10.3"></a>2019.10.3</h2><h4 id="Codeforces-1172D"><a href="#Codeforces-1172D" class="headerlink" title="Codeforces 1172D"></a><a href="http://codeforces.com/problemset/problem/1172/D" target="_blank" rel="noopener">Codeforces 1172D</a></h4><p>$\color{black}{\text{S}}\color{red}{\text{ooke}}$ 跟我讨论怎么出题。</p><p>结果 $\color{black}{\text{S}}\color{red}{\text{ooke}}$ 一句「你做过Portals没」就把话题变成了Portals做法讨论了……</p><p>在 $(x,1)$ 和 $(y,1)$ 放一对传送门，满足 $r[x] = 1, r[y] = 1$，这样子 $x$ 和 $y$ 一行一列就解决了，然后递归即可。</p><h2 id="2019-9-26"><a href="#2019-9-26" class="headerlink" title="2019.9.26"></a>2019.9.26</h2><h4 id="BZOJ-3416"><a href="#BZOJ-3416" class="headerlink" title="BZOJ 3416"></a><a href="https://darkbzoj.tk/problem/3416" target="_blank" rel="noopener">BZOJ 3416</a></h4><p>倒过来做，每次选择一段连续的区间即可。</p><h2 id="2019-9-25"><a href="#2019-9-25" class="headerlink" title="2019.9.25"></a>2019.9.25</h2><h4 id="Codeforces-568E"><a href="#Codeforces-568E" class="headerlink" title="Codeforces 568E"></a><a href="http://codeforces.com/problemset/problem/568/E" target="_blank" rel="noopener">Codeforces 568E</a></h4><p>由于是严格的LIS，所以每个数只能填一遍跟没有一样，然后用正常的$\Theta(n \log n)$ LIS，做到gap的时候就枚举取哪个数，复杂度$\Theta(mk + n \log n)$，还是比较松的。</p><h4 id="BZOJ-3427"><a href="#BZOJ-3427" class="headerlink" title="BZOJ 3427"></a><a href="https://darkbzoj.tk/problem/3427" target="_blank" rel="noopener">BZOJ 3427</a></h4><p><del>为什么POI全是权限题</del></p><p>发现最优解的每个元素$\in \{-1, 0, 1\}$，然后瞎dp就可以了。</p><h2 id="2019-9-23"><a href="#2019-9-23" class="headerlink" title="2019.9.23"></a>2019.9.23</h2><h4 id="Codeforces-555E"><a href="#Codeforces-555E" class="headerlink" title="Codeforces 555E"></a><a href="http://codeforces.com/problemset/problem/555/E" target="_blank" rel="noopener">Codeforces 555E</a></h4><p>将原图中所有边双都拎出来，这些是可以做到强连通的。</p><p>拎出来之后就是树了，一条路径上一半设为向上另一半向下，判断有无矛盾即可。</p><h2 id="2019-9-22"><a href="#2019-9-22" class="headerlink" title="2019.9.22"></a>2019.9.22</h2><h4 id="Codeforces-1221F"><a href="#Codeforces-1221F" class="headerlink" title="Codeforces 1221F"></a><a href="http://codeforces.com/problemset/problem/1221/F" target="_blank" rel="noopener">Codeforces 1221F</a></h4><p>枚举矩形右端点，将左端点的每一个可能取值用线段树维护一下即可。</p><h4 id="Luogu4768-NOI2018-归程"><a href="#Luogu4768-NOI2018-归程" class="headerlink" title="Luogu4768 [NOI2018]归程"></a><a href="https://www.luogu.com.cn/problem/P4768" target="_blank" rel="noopener">Luogu4768 [NOI2018]归程</a></h4><p>$\text{Kruscal}$重构树…</p><p>跑出$1$到每个点的最段路之后就可以搞了。</p><h4 id="Luogu4197-Peaks"><a href="#Luogu4197-Peaks" class="headerlink" title="Luogu4197 Peaks"></a><a href="https://www.luogu.com.cn/problem/P4197" target="_blank" rel="noopener">Luogu4197 Peaks</a></h4><p>还是$\text{Kruscal}$重构树……</p><p>把询问最小值改成第$k$大即可。</p><h2 id="2019-9-21"><a href="#2019-9-21" class="headerlink" title="2019.9.21"></a>2019.9.21</h2><h4 id="CometOJ-11-D"><a href="#CometOJ-11-D" class="headerlink" title="CometOJ #11 D"></a><a href="https://cometoj.com/contest/67/problem/D?problem_id=3801" target="_blank" rel="noopener">CometOJ #11 D</a></h4><p>$\text{Kruscal}$重构树。</p><p>询问的是整一棵重构树上的子树的积。</p><p>但是因为$0$的存在，不能树状数组，必须线段树。</p><p>比赛的时候写了个$O(n \sqrt n \log n)$的莫队结果过不去。</p><p>最后半个小时的时候改写正解喜提$\text{rush}$失败，心情极差。</p><h2 id="2019-9-19"><a href="#2019-9-19" class="headerlink" title="2019.9.19"></a>2019.9.19</h2><h4 id="Codeforces-555D"><a href="#Codeforces-555D" class="headerlink" title="Codeforces 555D"></a><a href="http://codeforces.com/problemset/problem/555/D" target="_blank" rel="noopener">Codeforces 555D</a></h4><p>每次二分当前这玩意儿可以掼到哪里，注意加一个如果两次掼回去的话可以直接取模，这样每次至少减少一半就是$O(n \log^2 n)$的了。</p><h2 id="2019-9-18"><a href="#2019-9-18" class="headerlink" title="2019.9.18"></a>2019.9.18</h2><h4 id="Codeforces-1209F"><a href="#Codeforces-1209F" class="headerlink" title="Codeforces 1209F"></a><a href="http://codeforces.com/problemset/problem/1209/F" target="_blank" rel="noopener">Codeforces 1209F</a></h4><p>不美好的回忆$\times 2$…</p><p>虽然我打的很臭但是这场的题还是蛮有意思的…</p><p>先拆点，然后建出最短路$\text{DAG}$之后分层贪心取，细节很多…</p><h2 id="2019-9-17"><a href="#2019-9-17" class="headerlink" title="2019.9.17"></a>2019.9.17</h2><h4 id="Codeforces-1209E2"><a href="#Codeforces-1209E2" class="headerlink" title="Codeforces 1209E2"></a><a href="http://codeforces.com/problemset/problem/1209/E" target="_blank" rel="noopener">Codeforces 1209E2</a></h4><p>不美好的回忆…</p><p>E1的基础之上（$f[i][j]$表示枚举到第$i$列，状态为$j$的行的最大值已经被确定）状压之后记录一下对于当前列，每个状态可以达到的最大和优化DP，并且注意只取$max$值最大的$n$列。</p><h2 id="2019-9-16"><a href="#2019-9-16" class="headerlink" title="2019.9.16"></a>2019.9.16</h2><h4 id="Codeforces-1215F"><a href="#Codeforces-1215F" class="headerlink" title="Codeforces 1215F"></a><a href="http://codeforces.com/problemset/problem/1215/F" target="_blank" rel="noopener">Codeforces 1215F</a></h4><p>前一天CF的F题。</p><p>建出$M$个点，代表$f \le i$是否成立，建图十分神仙，最后$2-SAT$即可。</p><p><a href="https://www.luogu.org/blog/Sooke/solution-cf1215f" target="_blank" rel="noopener">Sooke txdy</a></p><h2 id="2019-9-14"><a href="#2019-9-14" class="headerlink" title="2019.9.14"></a>2019.9.14</h2><h4 id="Codeforces-553D"><a href="#Codeforces-553D" class="headerlink" title="Codeforces 553D"></a><a href="https://codeforces.com/problemset/problem/553/D" target="_blank" rel="noopener">Codeforces 553D</a></h4><p>二分答案，得出对于每个点，最少有多少个被选中的点和他相邻，然后每次把已经不可能选进的点给删掉即可。</p><h2 id="2019-9-13"><a href="#2019-9-13" class="headerlink" title="2019.9.13"></a>2019.9.13</h2><h4 id="Codeforces-547D"><a href="#Codeforces-547D" class="headerlink" title="Codeforces 547D"></a><a href="http://codeforces.com/problemset/problem/547/D" target="_blank" rel="noopener">Codeforces 547D</a></h4><p>对于每条横着 / 竖着的线，两两配对连边之后跑黑白染色即可。</p><h2 id="2019-9-11"><a href="#2019-9-11" class="headerlink" title="2019.9.11"></a>2019.9.11</h2><h4 id="Codeforces-536E"><a href="#Codeforces-536E" class="headerlink" title="Codeforces 536E"></a><a href="https://codeforces.com/problemset/problem/536/E" target="_blank" rel="noopener">Codeforces 536E</a></h4><p>树剖裸题。</p><h2 id="2019-9-10"><a href="#2019-9-10" class="headerlink" title="2019.9.10"></a>2019.9.10</h2><h4 id="Codeforces-536D"><a href="#Codeforces-536D" class="headerlink" title="Codeforces 536D"></a><a href="https://codeforces.com/problemset/problem/536/D" target="_blank" rel="noopener">Codeforces 536D</a></h4><p>直接把每个点转换为坐标为$\left(dis(s, i), dis(t, i)\right)$的点，然后就可以DP了。</p><h2 id="2019-9-9"><a href="#2019-9-9" class="headerlink" title="2019.9.9"></a>2019.9.9</h2><h4 id="Codeforces-528D"><a href="#Codeforces-528D" class="headerlink" title="Codeforces 528D"></a><a href="http://codeforces.com/problemset/problem/528/D" target="_blank" rel="noopener">Codeforces 528D</a></h4><p>把$t$串反过来，是否满足条件的柿子转成卷积形式后NTT即可。</p><h2 id="2019-9-6"><a href="#2019-9-6" class="headerlink" title="2019.9.6"></a>2019.9.6</h2><h4 id="Codeforces-521D"><a href="#Codeforces-521D" class="headerlink" title="Codeforces 521D"></a><a href="https://codeforces.com/problemset/problem/521/D" target="_blank" rel="noopener">Codeforces 521D</a></h4><p>先把赋值操作转换成加操作，再把加改成乘，因为对于一个数上加的顺序是固定的，贪心即可。</p><p>打了场CometOJ。</p><p>这C题难度实在超标。</p><p>虽然做完之后发现不难但是我就是愣是没想到$(x, x + 1) = 1$然后就可以$O(2^{\text{质因数个数}})$暴力枚举了艹。</p><p>似乎是打CometOJ以来rk最高的一次（雾）毕竟我之前打的两场都是打到一半回家了（大雾）</p><p>顺便把标题改了下</p><h2 id="2019-9-5"><a href="#2019-9-5" class="headerlink" title="2019.9.5"></a>2019.9.5</h2><h4 id="Codeforces-516D"><a href="#Codeforces-516D" class="headerlink" title="Codeforces 516D"></a><a href="http://codeforces.com/problemset/problem/516/D" target="_blank" rel="noopener">Codeforces 516D</a></h4><p>令$f(x)$为离$x$最远的点离$x$的距离。</p><p>两边$dfs$之后以$f(x)$最小的点为根，可以证明$\forall x\ f(x) \geq f(fa(x))$，倍增即可。</p><h2 id="2019-9-4"><a href="#2019-9-4" class="headerlink" title="2019.9.4"></a>2019.9.4</h2><h4 id="Codeforces-512E"><a href="#Codeforces-512E" class="headerlink" title="Codeforces 512E"></a><a href="http://codeforces.com/problemset/problem/512/E" target="_blank" rel="noopener">Codeforces 512E</a></h4><p>想办法把两个状态变成一个$(1, 3), (1, 4) … (1, n - 1)$的三角剖分，一个正着做一个倒着做即可。</p><p>打了场CF。</p><p>$zxyhh$和$Sooke$讨论了半个小时$F$，得出了一个优秀的假做法。</p><p>我和$Sooke$讨论了半个小时$H$，得出了一个优秀的假做法，赛后问$Isonan$爷发现距离正解仅仅差一个无解判断。</p><h2 id="2019-9-3"><a href="#2019-9-3" class="headerlink" title="2019.9.3"></a>2019.9.3</h2><h4 id="Codeforces-506D"><a href="#Codeforces-506D" class="headerlink" title="Codeforces 506D"></a><a href="http://codeforces.com/problemset/problem/506/D" target="_blank" rel="noopener">Codeforces 506D</a></h4><p>先用unordered_map​维护$n$个并查集，把每个联通块拎出来做根号分治即可。</p><h4 id="Codeforces-512D"><a href="#Codeforces-512D" class="headerlink" title="Codeforces 512D"></a><a href="https://codeforces.com/problemset/problem/512/D" target="_blank" rel="noopener">Codeforces 512D</a></h4><p>删掉环，他就是一个树形DP，连着环的可以直接做，没连环的枚举最后一个取了哪个点。</p><h2 id="2019-9-2"><a href="#2019-9-2" class="headerlink" title="2019.9.2"></a>2019.9.2</h2><h4 id="Codeforces-504D"><a href="#Codeforces-504D" class="headerlink" title="Codeforces 504D"></a><a href="http://codeforces.com/problemset/problem/504/D" target="_blank" rel="noopener">Codeforces 504D</a></h4><p>高精线性基。</p><p>懒得写了（大雾）</p><h4 id="Codeforces-504E"><a href="#Codeforces-504E" class="headerlink" title="Codeforces 504E"></a><a href="http://codeforces.com/problemset/problem/504/E" target="_blank" rel="noopener">Codeforces 504E</a></h4><p>倍增 + 哈希维护一条链上的哈希值。</p><p>由于是倍增所以不用二分，是$O(\log n)$的。</p><p>口胡完事（大雾）</p><p>都怪Sooke疯狂怂恿我口胡（大雾）</p><h4 id="Codeforces-505D"><a href="#Codeforces-505D" class="headerlink" title="Codeforces 505D"></a><a href="http://codeforces.com/problemset/problem/505/D" target="_blank" rel="noopener">Codeforces 505D</a></h4><p>对于一个联通块，如果有环，贡献为$size - 1$否则贡献为$size$。</p><p><del>我以为这是1D，做到一半：这真的是1D吗，然后去看了一下发现是2D</del></p><h2 id="2019-9-1"><a href="#2019-9-1" class="headerlink" title="2019.9.1"></a>2019.9.1</h2><p>一不小心就咕咕咕了3个月了…</p><p>都是高中生！怎么能这么咕咕咕！（这就是你晚自修跑出来玩电脑的理由？）</p><p>我要重新开始！</p><p>从现在的开始要反一下….越往上越新</p><p>之前的就懒得改了…反正也没什么人看这只菜鸡的blog</p><p>现在开始准备模仿zxyhh神仙每次随机找$\texttt{Codeforces}$的Div1 D E做了。</p><h4 id="Codeforces-498D"><a href="#Codeforces-498D" class="headerlink" title="Codeforces 498D"></a><a href="http://codeforces.com/problemset/problem/498/D" target="_blank" rel="noopener">Codeforces 498D</a></h4><p>直接在$\mod 60$意义在进行，线段树维护。</p><p><a href="https://dilute.xyz/2019/09/01/Solutions/Solution-CF498D/">完整题解</a></p><h4 id="Codeforces-498E"><a href="#Codeforces-498E" class="headerlink" title="Codeforces 498E"></a><a href="http://codeforces.com/problemset/problem/498/E" target="_blank" rel="noopener">Codeforces 498E</a></h4><p>状压维护竖着的杆子存在与否。</p><p>同一种颜色中间用矩乘加速。</p><hr><h2 id="2019-4-18"><a href="#2019-4-18" class="headerlink" title="2019.4.18"></a>2019.4.18</h2><h4 id="CF321E-Ciel-and-Gondolas"><a href="#CF321E-Ciel-and-Gondolas" class="headerlink" title="CF321E Ciel and Gondolas"></a><a href="http://codeforces.com/problemset/problem/321/E" target="_blank" rel="noopener"><strong>CF321E</strong> Ciel and Gondolas</a></h4><p>今天的考试题</p><p>一道神奇的斜率优化</p><p><del>考场上随便打的暴力艹过去了，CF上特判了一组数据就过了</del></p><h4 id="CF1154F-Shovels-Shop"><a href="#CF1154F-Shovels-Shop" class="headerlink" title="CF1154F Shovels Shop"></a><a href="https://codeforces.com/problemset/problem/1154/F" target="_blank" rel="noopener"><strong>CF1154F</strong> Shovels Shop</a></h4><p>傻逼背包题，昨天Div3的时候特别智障的看错题意导致没切、</p><p>我果然太菜了</p><h4 id="CF219E-Parking-Lot"><a href="#CF219E-Parking-Lot" class="headerlink" title="CF219E Parking Lot"></a><a href="https://codeforces.com/problemset/problem/219/E" target="_blank" rel="noopener"><strong>CF219E</strong> Parking Lot</a></h4><p>细节题。</p><p>用两个珂朵莉树状物维护一下连续的空段就行了。</p><h2 id="2019-4-19"><a href="#2019-4-19" class="headerlink" title="2019.4.19"></a>2019.4.19</h2><p>昨天23:35到今天1:35打了一场CF，还行，小号上紫成功w</p><p>（这出题人B题放码农题然后CDE三道傻逼题算什么意思啊）</p><h4 id="CF895E-Eyes-Closed"><a href="#CF895E-Eyes-Closed" class="headerlink" title="CF895E Eyes Closed"></a><a href="https://codeforces.com/problemset/problem/895/E" target="_blank" rel="noopener"><strong>CF895E</strong> Eyes Closed</a></h4><p>用线段树简单维护一下每个点的期望值</p><p>有点奇奇怪怪 容易写挂（又是细节题）</p><h4 id="CF442D-Adam-and-Tree"><a href="#CF442D-Adam-and-Tree" class="headerlink" title="CF442D Adam and Tree"></a><a href="https://codeforces.com/problemset/problem/442/D" target="_blank" rel="noopener"><strong>CF442D</strong> Adam and Tree</a></h4><p>每次暴力向根更新+DP+剪枝是正确的。</p><p>因为答案最大是$\log$的（树剖），所以封顶$n \log n$</p><h4 id="CF1154G-Minimum-Possible-LCM"><a href="#CF1154G-Minimum-Possible-LCM" class="headerlink" title="CF1154G Minimum Possible LCM"></a><a href="https://codeforces.com/problemset/problem/1154/G" target="_blank" rel="noopener"><strong>CF1154G</strong> Minimum Possible LCM</a></h4><p>淦 前天Div 3怎么全都是水题</p><p>直接用桶存一下数字然后再调和级数$O(10^7 \ln 10^7)$枚举即可。</p><h4 id="CF311D-Interval-Cubing"><a href="#CF311D-Interval-Cubing" class="headerlink" title="CF311D Interval Cubing"></a><a href="https://codeforces.com/problemset/problem/311/D" target="_blank" rel="noopener"><strong>CF311D</strong> Interval Cubing</a></h4><p>奇奇怪怪的找规律 + 线段树</p><p>发现所有数都在$48$的时候形成循环，然后再用线段树打标记维护一下。</p><h2 id="2019-4-21"><a href="#2019-4-21" class="headerlink" title="2019.4.21"></a>2019.4.21</h2><h4 id="CF746F-Music-in-Car"><a href="#CF746F-Music-in-Car" class="headerlink" title="CF746F Music in Car"></a><a href="https://codeforces.com/problemset/problem/746/F" target="_blank" rel="noopener"><strong>CF746F</strong> Music in Car</a></h4><p>又双叒叕是细节题</p><p>用两个$set$维护一下整首播放的和半首播放的即可。</p><p><del>其实这sb题我22号才调出来的</del></p><p><del>但是我看21号没做其他题就放过来的</del></p><h2 id="2019-4-22"><a href="#2019-4-22" class="headerlink" title="2019.4.22"></a>2019.4.22</h2><h4 id="CF176E-Archaeology-LOJ-10132-「一本通-4-4-例-3」异象石"><a href="#CF176E-Archaeology-LOJ-10132-「一本通-4-4-例-3」异象石" class="headerlink" title="CF176E Archaeology | LOJ #10132. 「一本通 4.4 例 3」异象石"></a><a href="https://codeforces.com/problemset/problem/176/E" target="_blank" rel="noopener"><strong>CF176E</strong> Archaeology</a> | <a href="https://loj.ac/problem/10132" target="_blank" rel="noopener">LOJ #10132. 「一本通 4.4 例 3」异象石</a></h4><p>结论：把需要求的点个按照$DFS$序排个序，设得到的序列为$s_1, s_2, s_3 … s_m$那么这个时候的答案就是$\frac{\sum\limits_{i = 1}^{m - 1}dis(s_i, s_{i + 1}) + dis(s_1, s_m)}{2}$，然后再用$set$维护$s$，和$\sum\limits_{i = 1}^{m - 1}dis(s_i, s_{i + 1})$然后把$dis(s_1, s_m)$单独拎出来，询问的时候加上就行了。</p><h4 id="CF609F-Frogs-and-mosquitoes"><a href="#CF609F-Frogs-and-mosquitoes" class="headerlink" title="CF609F Frogs and mosquitoes"></a><a href="https://codeforces.com/problemset/problem/609/F" target="_blank" rel="noopener"><strong>CF609F</strong> Frogs and mosquitoes</a></h4><p><del>怎么又双叒叕是set</del></p><p><del>整天就知道set, set 我看CF你这个OJ就像个set</del></p><p>用两个set维护青蛙能影响的区间和未被吃掉的问题</p><p>完整题解：<a href="https://dilute.xyz/2019/04/22/Solutions/Solution-CF609F">&gt;Here&lt;</a></p><h2 id="2019-4-24-4-27"><a href="#2019-4-24-4-27" class="headerlink" title="2019.4.24 ~ 4.27"></a>2019.4.24 ~ 4.27</h2><p>ZJOI期间，只打了一场CF，其他啥都没写</p><p><del>帮可爱的xay5421写了1个小时的假算法</del></p><h2 id="2019-4-28"><a href="#2019-4-28" class="headerlink" title="2019.4.28"></a>2019.4.28</h2><p>ZJOI2019爆完0回来了。</p><h4 id="CF295E-Yaroslav-and-Points"><a href="#CF295E-Yaroslav-and-Points" class="headerlink" title="CF295E Yaroslav and Points"></a><a href="https://codeforces.com/problemset/problem/295/E" target="_blank" rel="noopener"><strong>CF295E</strong> Yaroslav and Points</a></h4><p>不用离散化，算出$[l,  r]$之间每个点的贡献。</p><p>直接用$fhq\ treap$ 维护一个区间的答案，滋瓷插入和删除即可。</p><h4 id="CF542A-Place-Your-Ad-Here"><a href="#CF542A-Place-Your-Ad-Here" class="headerlink" title="CF542A Place Your Ad Here"></a><a href="https://codeforces.com/problemset/problem/542/A" target="_blank" rel="noopener"><strong>CF542A</strong> Place Your Ad Here</a></h4><p>首先枚举电视台。</p><p>钦点当前这个区间跟左边/右边其中一边不接触，用ST表维护一下区间内最右边/左边的点，然后特判一下广告区间包含电视台的区间的情况即可。</p><h2 id="2019-4-29"><a href="#2019-4-29" class="headerlink" title="2019.4.29"></a>2019.4.29</h2><h4 id="CF618E-Robot-Arm"><a href="#CF618E-Robot-Arm" class="headerlink" title="CF618E Robot Arm"></a><a href="https://codeforces.com/problemset/problem/618/E" target="_blank" rel="noopener"><strong>CF618E</strong> Robot Arm</a></h4><p>线段树 + 计算几何。</p><p>线段树区间$[l, r]$维护一个向量，表示$l$的起点和$r$的重点之间的位置关系，注意开$long\ double$和使用$atan2()$防止过大精度误差。</p><h4 id="CF558E-A-Simple-Task"><a href="#CF558E-A-Simple-Task" class="headerlink" title="CF558E A Simple Task"></a><a href="http://codeforces.com/problemset/problem/558/E" target="_blank" rel="noopener"><strong>CF558E</strong> A Simple Task</a></h4><p>线段树大水题。</p><p>$26$棵线段树随便艹。</p><p>orz $spfa$ ODT神仙。</p><p><img src="https://dilute.xyz/images/spfatql.png" alt></p><h4 id="CF420D-Cup-Trick"><a href="#CF420D-Cup-Trick" class="headerlink" title="CF420D Cup Trick"></a><a href="https://codeforces.com/problemset/problem/420/D" target="_blank" rel="noopener"><strong>CF420D</strong> Cup Trick</a></h4><p>使用$fhq\ treap$ 逆着题意模拟即可。</p><p>一开始所有点都不确定，每次取出第一个，判无解，$erase$ + $insert$二连，最终把不确定的瞎填一通输出即可。</p><h2 id="2019-4-30"><a href="#2019-4-30" class="headerlink" title="2019.4.30"></a>2019.4.30</h2><h4 id="CF316E3-Summer-Homework"><a href="#CF316E3-Summer-Homework" class="headerlink" title="CF316E3 Summer Homework"></a><a href="https://codeforces.com/problemset/problem/316/E3" target="_blank" rel="noopener"><strong>CF316E3</strong> Summer Homework</a></h4><p>我们考虑线段树，一个段里维护$\displaystyle\sum_{i = 1}^{n} a_i  fib_i$和$\displaystyle\sum_{i = 1}^{n} a_i  fib_{i - 1}$，然后可以矩阵乘法预处理出$\displaystyle\sum_{i = 1}^{n} a_i  fib_{i + k}$和$\displaystyle\sum_{i = 1}^{n} a_i fib_i$，$\displaystyle\sum_{i = 1}^{n} a_i fib_{i - 1}$的关系$pushup$的时候从预处理好的里面取系数就行了。</p><h4 id="CF1149C-Tree-Generator™"><a href="#CF1149C-Tree-Generator™" class="headerlink" title="CF1149C Tree Generator™"></a><a href="https://codeforces.com/problemset/problem/1149/C" target="_blank" rel="noopener"><strong>CF1149C</strong> Tree Generator™</a></h4><p>orz $S\color{red}{ooke}$ 红名巨爷。</p><p>首先两点之间一段可以转换为一个类dfs序状物，然后把距离可以做一个转换，变为序列上首尾相接的两端，前面那半段取反。接下来用线段树维护就行了。</p><h4 id="CF653F-Paper-task"><a href="#CF653F-Paper-task" class="headerlink" title="CF653F Paper task"></a><a href="https://codeforces.com/problemset/problem/653/F" target="_blank" rel="noopener"><strong>CF653F</strong> Paper task</a></h4><p>如果我们钦点左括号为$1$，右括号为$-1$，$sum_i$为$\displaystyle\sum_{i = 1}^{i} a_i$，一个序列$[l, r]$是括号匹配的当且仅当$\displaystyle\min_{l \leq i \leq r} (sum_i) \geq sum_{l - 1}$且$sum_r = sum_{l - 1}$那么用二分 + 后缀数组可以得出对于一个左端点，它右端点的范围。最后主席树维护一波即可。</p><h4 id="CF1070B-Berkomnadzor"><a href="#CF1070B-Berkomnadzor" class="headerlink" title="CF1070B Berkomnadzor"></a><a href="https://codeforces.com/problemset/problem/1070/B" target="_blank" rel="noopener"><strong>CF1070B</strong> Berkomnadzor</a></h4><p>先建出字典树（只针对需要被屏蔽的，白名单直接在他和根的路径中打个标记就好了）。</p><p>再判个无解。</p><p>然后遍历一遍字典树，尽量取浅的未被标记的节点即可。</p><h2 id="2019-5-1"><a href="#2019-5-1" class="headerlink" title="2019.5.1"></a>2019.5.1</h2><h4 id="CF436E-Cardboard-Box"><a href="#CF436E-Cardboard-Box" class="headerlink" title="CF436E  Cardboard Box"></a><a href="https://codeforces.com/problemset/problem/1070/B" target="_blank" rel="noopener"><strong>CF436E</strong>  Cardboard Box</a></h4><p>首先把所有的关卡按照通过第二关的难度排个升序，然后再对于枚举一个点$i$，使得在$i$前面的关卡拿了一颗星，$i$后面的关卡没拿第二颗星（可以证明肯定存在一个最优解使得满足性质的$i$存在）。我们令$w_j$为使第$j$关拿到下一颗星的代价，然后用$fhq\ treap$动态维护前$n - i + 1$个最大的$w_j$即可。</p><h2 id="2019-5-2"><a href="#2019-5-2" class="headerlink" title="2019.5.2"></a>2019.5.2</h2><p>打了场CF还unr了。。。今天一大半时间都在做前一天CF的题目w</p><h4 id="CF887D-Ratings-and-Reality-Shows"><a href="#CF887D-Ratings-and-Reality-Shows" class="headerlink" title="CF887D Ratings and Reality Shows"></a><a href="https://codeforces.com/problemset/problem/1070/B" target="_blank" rel="noopener"><strong>CF887D</strong> Ratings and Reality Shows</a></h4><p>显然脱口秀放在一个事件后面一个单位时间最优。</p><p>然后枚举放在哪个后面 + 模拟即可。</p><h4 id="CF1156E-Special-Segments-of-Permutation"><a href="#CF1156E-Special-Segments-of-Permutation" class="headerlink" title="CF1156E Special Segments of Permutation"></a><a href="https://codeforces.com/problemset/problem/1156/E" target="_blank" rel="noopener"><strong>CF1156E</strong> Special Segments of Permutation</a></h4><p>分治。</p><p>每次从一个线段中的最大值割开，维护一个$map$，然后合并的时候启发式合并一波即可。</p><p>感谢$L\color{red}{JC0118}$教我的orz</p><h4 id="CF1156D-0-1-Tree"><a href="#CF1156D-0-1-Tree" class="headerlink" title="CF1156D 0-1-Tree"></a><a href="https://codeforces.com/problemset/problem/1156/D" target="_blank" rel="noopener"><strong>CF1156D</strong> 0-1-Tree</a></h4><p>简单DP，$f1[i]$表示以$i$点为开始的只有$0$边的路径的数量$f2[i]$表示….只有$1$边的….数量。</p><p>两遍DFS解决，最后显然答案就是$\displaystyle\sum_{i = 1}^{n} f1[i] * f2[i]$。</p><h4 id="CF1156F-Card-Bag"><a href="#CF1156F-Card-Bag" class="headerlink" title="CF1156F Card Bag"></a><a href="https://codeforces.com/problemset/problem/1156/D" target="_blank" rel="noopener"><strong>CF1156F</strong> Card Bag</a></h4><p>期望DP。$f[i][j]$表示取到第$i$个，目前包里还有还有$j$个球。</p><p>注意要开个$f2$辅助$f$的转移，否则要枚举下一个在什么地方取，就是$O(n^3)$的。</p><h2 id="2019-5-3"><a href="#2019-5-3" class="headerlink" title="2019.5.3"></a>2019.5.3</h2><h4 id="CF15D-Map"><a href="#CF15D-Map" class="headerlink" title="CF15D Map"></a><a href="https://codeforces.com/problemset/problem/15/D" target="_blank" rel="noopener"><strong>CF15D</strong> Map</a></h4><p> 把每个矩形的代价丢进$set$里面，每次取出代价最小的。</p><p>再把因为这个矩形取了导致不能够取的矩形删掉，就可以了。</p><h2 id="2019-5-4"><a href="#2019-5-4" class="headerlink" title="2019.5.4"></a>2019.5.4</h2><p>luogu比赛正好和课外班撞了一大半。。。半个小时的时间只够打个$T1$了（艹要是我T2的倍增优化建边打出来了我就rk前10了w）</p><p>T2边过个几天再补（咕咕咕）</p><h4 id="洛谷P5343-【XR-1】分块"><a href="#洛谷P5343-【XR-1】分块" class="headerlink" title="洛谷P5343 【XR-1】分块"></a><a href="https://www.luogu.org/problemnew/show/P5343" target="_blank" rel="noopener"><strong>洛谷P5343</strong> 【XR-1】分块</a></h4><p>简单矩阵乘法。</p><p>很像<a href="https://codeforces.com/problemset/problem/1117/D" target="_blank" rel="noopener">CF1117D Magic Gems</a>，我的题解：<a href="https://dilute.xyz/2019/03/02/Solutions/Solution-CF1117D/">&gt;Here&lt;</a></p><p>把柿子改改就可以了。</p><h2 id="2019-5-6"><a href="#2019-5-6" class="headerlink" title="2019.5.6"></a>2019.5.6</h2><p>昨天回初中学校考试去了。。。</p><h4 id="CF269D-Maximum-Waterfall"><a href="#CF269D-Maximum-Waterfall" class="headerlink" title="CF269D Maximum Waterfall"></a><a href="https://codeforces.com/problemset/problem/15/D" target="_blank" rel="noopener"><strong>CF269D</strong> Maximum Waterfall</a></h4><p>用一个线段树维护一下每个点上最下面的节点，每次一直往下面加入线段。</p><p>每次分治一下+DP转移即可。</p><h4 id="CF513D2Constrained-Tree"><a href="#CF513D2Constrained-Tree" class="headerlink" title="CF513D2Constrained Tree"></a><a href="https://codeforces.com/contest/513/problem/D2" target="_blank" rel="noopener"><strong>CF513D2</strong>Constrained Tree</a></h4><p>简单构造。</p><p>直接按照先序遍历为$1…n$这个性质乱搞，每次取尽量少的点构造一棵树，如何还有不够的就在最后直接加</p><p>因为如果在最右边的一个节点的右子树上加，不管是先序还是后序，表现出来都是在序列最后加。</p><h4 id="CF431E-Chemistry-Experiment"><a href="#CF431E-Chemistry-Experiment" class="headerlink" title="CF431E Chemistry Experiment"></a><a href="https://codeforces.com/contest/431/problem/E" target="_blank" rel="noopener"><strong>CF431E</strong> Chemistry Experiment</a></h4><p>先离散化一波</p><p>然后直接大力二分 + 权值树状数组维护一波就行了。</p><h2 id="2019-5-7"><a href="#2019-5-7" class="headerlink" title="2019.5.7"></a>2019.5.7</h2><h4 id="洛谷P5344-【XR-1】逛森林"><a href="#洛谷P5344-【XR-1】逛森林" class="headerlink" title="洛谷P5344 【XR-1】逛森林"></a><a href="https://www.luogu.org/problemnew/show/P5344" target="_blank" rel="noopener"><strong>洛谷P5344</strong> 【XR-1】逛森林</a></h4><p>裸倍增优化建边</p><p>注意要用一个类似ST表的东西来让它的点数小一个$\log$</p><h2 id="2019-5-8"><a href="#2019-5-8" class="headerlink" title="2019.5.8"></a>2019.5.8</h2><h4 id="CF286D-Tourists"><a href="#CF286D-Tourists" class="headerlink" title="CF286D Tourists"></a><a href="http://codeforces.com/problemset/problem/286/D" target="_blank" rel="noopener"><strong>CF286D</strong> Tourists</a></h4><p>答案可以转换成很多个斜线和一个奇奇怪怪的矩形组成的图形的交</p><p>接下来用堆 + 单调栈维护一下即可。</p><h4 id="CF845E-Fire-in-the-City"><a href="#CF845E-Fire-in-the-City" class="headerlink" title="CF845E Fire in the City"></a><a href="http://codeforces.com/problemset/problem/845/E" target="_blank" rel="noopener"><strong>CF845E</strong> Fire in the City</a></h4><p>一个火区在一段时间后影响的时间是一个正方形，然后非常显然地想到二分答案</p><p>然后$check$里面把所有火区影响范围的边界弄出来，离散化一下，可以得到最上、最下、最左、最右的未着火区，然后就可以确定最后一个的位置了。</p><h2 id="2019-5-9"><a href="#2019-5-9" class="headerlink" title="2019.5.9"></a>2019.5.9</h2><h4 id="CF1117G-Recursive-Queries"><a href="#CF1117G-Recursive-Queries" class="headerlink" title="CF1117G Recursive Queries"></a><a href="http://codeforces.com/problemset/problem/1117/G" target="_blank" rel="noopener"><strong>CF1117G</strong> Recursive Queries</a></h4><p>我们令$rb[i]$为$i$右边的最近的比$a[i]$大的数字的位置，$lb[i]$就是在左边的…</p><p>考虑一个数字$i$会使$[i + 1, rb[i] - 1]$和$[lb[i] + 1, i]$区间内的元素的贡献+1（前提是$i$在范围询问内）</p><p>两端分开来算，分别从左到右和从右到左加贡献 + 询问，线段树维护即可。</p><h4 id="CF873E-Awards-For-Contestants"><a href="#CF873E-Awards-For-Contestants" class="headerlink" title="CF873E Awards For Contestants"></a><a href="http://codeforces.com/problemset/problem/873/E" target="_blank" rel="noopener"><strong>CF873E</strong> Awards For Contestants</a></h4><p>首先，暴力枚举第一个和第二个，显然前二个里面最优的解的数量封顶是$O(n^2)$的</p><p>接下来在前两个最优的情况下我们显然可以得到第三个的取值范围，就可以用$st$表维护差分最大值了。</p><h2 id="2019-5-10"><a href="#2019-5-10" class="headerlink" title="2019.5.10"></a>2019.5.10</h2><h4 id="CF257E-Greedy-Elevator"><a href="#CF257E-Greedy-Elevator" class="headerlink" title="CF257E Greedy Elevator"></a><a href="http://codeforces.com/problemset/problem/257/E" target="_blank" rel="noopener"><strong>CF257E</strong> Greedy Elevator</a></h4><p>按照题意模拟。</p><p>用一个$set$维护等电梯的和坐电梯的人即可。</p><h4 id="CF446C-DZY-Loves-Fibonacci-Numbers"><a href="#CF446C-DZY-Loves-Fibonacci-Numbers" class="headerlink" title="CF446C DZY Loves Fibonacci Numbers"></a><a href="http://codeforces.com/problemset/problem/446/C" target="_blank" rel="noopener"><strong>CF446C</strong> DZY Loves Fibonacci Numbers</a></h4><p>我们可以在线段树上的Lazy标记改成一个斐波那契数列的第一和第二项（斐波那契数列是可以直接相加的）</p><p>$pushdown$里面套一个矩阵乘法，就可以$O(n \log^2 n)$解决了。</p><h2 id="2019-5-11"><a href="#2019-5-11" class="headerlink" title="2019.5.11"></a>2019.5.11</h2><h4 id="CF455D-Serega-and-Fun"><a href="#CF455D-Serega-and-Fun" class="headerlink" title="CF455D Serega and Fun"></a><a href="http://codeforces.com/problemset/problem/445/D" target="_blank" rel="noopener"><strong>CF455D</strong> Serega and Fun</a></h4><p>分块。</p><p>每个块里开一个$deque$和一个桶，每次修改的时候瞎jb乱搞一下就行了。</p><h2 id="2019-5-12"><a href="#2019-5-12" class="headerlink" title="2019.5.12"></a>2019.5.12</h2><h4 id="CF515E-Drazil-and-Park"><a href="#CF515E-Drazil-and-Park" class="headerlink" title="CF515E Drazil and Park"></a><a href="http://codeforces.com/problemset/problem/515/E" target="_blank" rel="noopener"><strong>CF515E</strong> Drazil and Park</a></h4><p>套路性拆环，直接把序列倍长一遍就变成区间最大字段和问题了。</p><p>直接用线段树解决即可。</p><h2 id="2019-5-13"><a href="#2019-5-13" class="headerlink" title="2019.5.13"></a>2019.5.13</h2><h4 id="CF1158C-Permutation-recovery"><a href="#CF1158C-Permutation-recovery" class="headerlink" title="CF1158C Permutation recovery"></a><a href="http://codeforces.com/problemset/problem/1158/C" target="_blank" rel="noopener"><strong>CF1158C</strong> Permutation recovery</a></h4><p>这是$Sooke$验题的CF里的题</p><p>可以建图DFS过序过去，也可以树状数组乱搞。</p><h4 id="CF551E-GukiZ-and-GukiZiana"><a href="#CF551E-GukiZ-and-GukiZiana" class="headerlink" title="CF551E GukiZ and GukiZiana"></a><a href="http://codeforces.com/problemset/problem/551/E" target="_blank" rel="noopener"><strong>CF551E</strong> GukiZ and GukiZiana</a></h4><p>实名diss<a href="https://www.luogu.org/blog/zjj/cf551e-ti-jie-by-juruo" target="_blank" rel="noopener">洛谷上的第二篇题解</a>。。。代码是抄的，注释跟简单介绍分块基本没有区别$O(q \sqrt{n \log n})$被硬生生说成了$O(nq\log n)$不知道作者是怎么想的</p><p>就是分块 块内有序 查询的时候从左和右分别开始每个块内二分看是否存在要找的数。</p><p><del>似乎每块开个unordered_map就能去log了</del></p><h2 id="2019-5-16"><a href="#2019-5-16" class="headerlink" title="2019.5.16"></a>2019.5.16</h2><h4 id="CF786C-Till-I-Collapse"><a href="#CF786C-Till-I-Collapse" class="headerlink" title="CF786C Till I Collapse"></a><a href="http://codeforces.com/problemset/problem/786/C" target="_blank" rel="noopener"><strong>CF786C</strong> Till I Collapse</a></h4><p>我们用主席树上二分可以得到每个地点可以最多往左走到哪里</p><p>每次询问从右往左暴力跳就行了，因为最多跳$\frac ni$次，加起来就是$n \log n$加上主席树上二分就是两只$\log$的</p><h2 id="2019-5-17"><a href="#2019-5-17" class="headerlink" title="2019.5.17"></a>2019.5.17</h2><h4 id="CF348C-Subset-Sums"><a href="#CF348C-Subset-Sums" class="headerlink" title="CF348C Subset Sums"></a><a href="http://codeforces.com/problemset/problem/348/C" target="_blank" rel="noopener"><strong>CF348C</strong> Subset Sums</a></h4><p>把集合分成大小$&gt; \sqrt n$和大小$&lt; \sqrt n$的两种，加的时候大集合打标记 小集合暴力加，并且给所有大集合加上所对应的贡献。</p><p>查询的时候对于大集合，我们把它的标记和加小集合对它的贡献加起来就行了。</p><p>小集合照样暴力即可，注意要加上修改大集合对它的贡献。</p><h2 id="2019-5-18"><a href="#2019-5-18" class="headerlink" title="2019.5.18"></a>2019.5.18</h2><h4 id="CF1166E-The-LCMs-Must-be-Large"><a href="#CF1166E-The-LCMs-Must-be-Large" class="headerlink" title="CF1166E The LCMs Must be Large"></a><a href="http://codeforces.com/problemset/problem/1166/E" target="_blank" rel="noopener"><strong>CF1166E</strong> The LCMs Must be Large</a></h4><p><img src="https://dilute.xyz/images/spfa1.png" alt></p><p><img src="https://dilute.xyz/images/spfa2.png" alt></p><p>结束了？结束了。</p><p>orz $\color{black}s\color{red}{pfa}$</p><h4 id="CF650D-Zip-line"><a href="#CF650D-Zip-line" class="headerlink" title="CF650D Zip-line"></a><a href="http://codeforces.com/problemset/problem/650/D" target="_blank" rel="noopener"><strong>CF650D</strong> Zip-line</a></h4><p>发现答案只有可能原LIS + 1, LIS, LIS - 1中的一个</p><p>我们对于它是不是在原LIS节点作分类讨论，接下来用主席树维护即可。</p><h2 id="2019-5-21"><a href="#2019-5-21" class="headerlink" title="2019.5.21"></a>2019.5.21</h2><h4 id="CF911G-Mass-Change-Queries"><a href="#CF911G-Mass-Change-Queries" class="headerlink" title="CF911G Mass Change Queries"></a><a href="http://codeforces.com/problemset/problem/991/G" target="_blank" rel="noopener"><strong>CF911G</strong> Mass Change Queries</a></h4><p>线段树，$f[i]$表示在这个区间内，$i$全都变成了$f[i]$，可以将$f$认为是一种特殊的懒标。</p><p>每次下传的时候$t[lc(cur)].f[i] = t[cur].f[t[lc(cur)].f[i]]$即可，右儿子也是这样。</p><h4 id="CF240F-TorCoder"><a href="#CF240F-TorCoder" class="headerlink" title="CF240F TorCoder"></a><a href="http://codeforces.com/problemset/problem/240/F" target="_blank" rel="noopener"><strong>CF240F</strong> TorCoder</a></h4><p><a href="https://dilute.xyz/2019/06/03/Solutions/Solution-CF240F">直接丢篇完整题解好了</a></p><h2 id="2019-5-22"><a href="#2019-5-22" class="headerlink" title="2019.5.22"></a>2019.5.22</h2><h4 id="CF992E-Nastya-and-King-Shamans"><a href="#CF992E-Nastya-and-King-Shamans" class="headerlink" title="CF992E Nastya and King-Shamans"></a><a href="http://codeforces.com/problemset/problem/992/E" target="_blank" rel="noopener"><strong>CF992E</strong> Nastya and King-Shamans</a></h4><p>每次往后跳，直接跳到$s[j] &gt; 2s[i]$的最小的$j$</p><p>可以用线段树上二分实现。</p><h2 id="2019-5-24"><a href="#2019-5-24" class="headerlink" title="2019.5.24"></a>2019.5.24</h2><h4 id="CF1030F-Putting-Boxes-Together"><a href="#CF1030F-Putting-Boxes-Together" class="headerlink" title="CF1030F Putting Boxes Together"></a><a href="http://codeforces.com/problemset/problem/1030/F" target="_blank" rel="noopener"><strong>CF1030F</strong> Putting Boxes Together</a></h4><p>其实最终的决策就是一个带权带修中位数</p><p>然后用一个线段树维护即可。</p><h4 id="CF1051E-Vasya-and-Big-Integers"><a href="#CF1051E-Vasya-and-Big-Integers" class="headerlink" title="CF1051E Vasya and Big Integers"></a><a href="http://codeforces.com/problemset/problem/1051/E" target="_blank" rel="noopener"><strong>CF1051E</strong> Vasya and Big Integers</a></h4><p>求出LCP之后就可以比较两个的大小 然后就可以DP了</p><p><a href="https://dilute.xyz/2019/05/28/Solutions/Solution-CF1051E">完整题解</a></p><h2 id="2019-5-25"><a href="#2019-5-25" class="headerlink" title="2019.5.25"></a>2019.5.25</h2><h4 id="CF940F-Machine-Learning"><a href="#CF940F-Machine-Learning" class="headerlink" title="CF940F Machine Learning"></a><a href="http://codeforces.com/problemset/problem/940/F" target="_blank" rel="noopener"><strong>CF940F</strong> Machine Learning</a></h4><p>考虑带修莫队， 每次更新的时候分块$O(1)$修改。</p><p>每个询问的时候$O(\sqrt n)$查询即可。</p><h2 id="2019-5-28"><a href="#2019-5-28" class="headerlink" title="2019.5.28"></a>2019.5.28</h2><h4 id="CF749E-Inversions-After-Shuffle"><a href="#CF749E-Inversions-After-Shuffle" class="headerlink" title="CF749E Inversions After Shuffle"></a><a href="https://www.luogu.org/problemnew/show/CF749E" target="_blank" rel="noopener"><strong>CF749E</strong> Inversions After Shuffle</a></h4><p>对于每一个选择的区间，序列分成前面的，中间的，后面的三部分。</p><p>然后中间的每对数，贡献$\frac 12$，其他的每个逆序对贡献$1$，使用树状数组维护即可。</p><h4 id="CF916E-Jamie-and-Tree"><a href="#CF916E-Jamie-and-Tree" class="headerlink" title="CF916E Jamie and Tree"></a><a href="https://www.luogu.org/problemnew/show/CF916E" target="_blank" rel="noopener"><strong>CF916E</strong> Jamie and Tree</a></h4><h2 id="2019-5-29"><a href="#2019-5-29" class="headerlink" title="2019.5.29"></a>2019.5.29</h2><h4 id="CF1044D-Deduction-Queries"><a href="#CF1044D-Deduction-Queries" class="headerlink" title="CF1044D Deduction Queries"></a><a href="https://www.luogu.org/problemnew/show/CF1044D" target="_blank" rel="noopener"><strong>CF1044D</strong> Deduction Queries</a></h4><h2 id="2019-5-30"><a href="#2019-5-30" class="headerlink" title="2019.5.30"></a>2019.5.30</h2><h4 id="CF338E-Optimize"><a href="#CF338E-Optimize" class="headerlink" title="CF338E Optimize!"></a><a href="https://www.luogu.org/problemnew/show/CF338E" target="_blank" rel="noopener"><strong>CF338E</strong> Optimize!</a></h4><h2 id="2019-5-31"><a href="#2019-5-31" class="headerlink" title="2019.5.31"></a>2019.5.31</h2><h4 id="CF372D-Choosing-Subtree-is-Fun"><a href="#CF372D-Choosing-Subtree-is-Fun" class="headerlink" title="CF372D Choosing Subtree is Fun"></a><a href="https://www.luogu.org/problemnew/show/CF372D" target="_blank" rel="noopener"><strong>CF372D</strong> Choosing Subtree is Fun</a></h4><h2 id="2019-6-1"><a href="#2019-6-1" class="headerlink" title="2019.6.1"></a>2019.6.1</h2><h4 id="CF266E-More-Queries-to-Array…"><a href="#CF266E-More-Queries-to-Array…" class="headerlink" title="CF266E More Queries to Array…"></a><a href="https://www.luogu.org/problemnew/show/CF266E" target="_blank" rel="noopener"><strong>CF266E</strong> More Queries to Array…</a></h4><h2 id="2019-6-2"><a href="#2019-6-2" class="headerlink" title="2019.6.2"></a>2019.6.2</h2><h4 id="CF811E-Vladik-and-Entertaining-Flags"><a href="#CF811E-Vladik-and-Entertaining-Flags" class="headerlink" title="CF811E Vladik and Entertaining Flags"></a><a href="https://www.luogu.org/problemnew/show/CF811E" target="_blank" rel="noopener"><strong>CF811E</strong> Vladik and Entertaining Flags</a></h4><h2 id="2019-6-3"><a href="#2019-6-3" class="headerlink" title="2019.6.3"></a>2019.6.3</h2><h4 id="CF200A-Cinema"><a href="#CF200A-Cinema" class="headerlink" title="CF200A Cinema"></a><a href="https://www.luogu.org/problemnew/show/CF200A" target="_blank" rel="noopener"><strong>CF200A</strong> Cinema</a></h4><h4 id="CF1148F-Foo-Fighters"><a href="#CF1148F-Foo-Fighters" class="headerlink" title="CF1148F Foo Fighters"></a><a href="https://www.luogu.org/problemnew/show/CF1148F" target="_blank" rel="noopener"><strong>CF1148F</strong> Foo Fighters</a></h4><h4 id="CF1148E-Earth-Wind-and-Fire"><a href="#CF1148E-Earth-Wind-and-Fire" class="headerlink" title="CF1148E Earth Wind and Fire"></a><a href="https://www.luogu.org/problemnew/show/CF1148E" target="_blank" rel="noopener"><strong>CF1148E</strong> Earth Wind and Fire</a></h4><h2 id="2019-6-4"><a href="#2019-6-4" class="headerlink" title="2019.6.4"></a>2019.6.4</h2><h4 id="CF28D-Don’t-fear-DravDe-is-kind"><a href="#CF28D-Don’t-fear-DravDe-is-kind" class="headerlink" title="CF28D Don’t fear, DravDe is kind"></a><a href="https://www.luogu.org/problemnew/show/CF28D" target="_blank" rel="noopener"><strong>CF28D</strong> Don’t fear, DravDe is kind</a></h4><h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1153E Serval and Snake</title>
      <link href="/2019/04/14/Solutions/Solution-CF1153E/"/>
      <url>/2019/04/14/Solutions/Solution-CF1153E/</url>
      
        <content type="html"><![CDATA[<h2 id="有趣的交互题"><a href="#有趣的交互题" class="headerlink" title="有趣的交互题"></a>有趣的交互题</h2><p>我们考虑一件事情</p><p>如果我们询问的矩形中有一个端点</p><p>那么答案 $\mod 2 = 1$</p><p>否则答案 $\mod 2 = 0$</p><p>换句话说，就是如果询问到的答案$\mod 2 = 0$，那么这个矩形内要么没有端点，要么有两个端点</p><a id="more"></a><p>我们考虑</p><p>如果两个答案不在同一行</p><p>那么我们可以$O(n)$次询问找到这两行然后二分答案，这是非常简单易懂轻松愉快的</p><p>如果在同一行</p><p>那么他们肯定不在同一列</p><p>然后我们只需要找到他们中的一个，而且只需要二分一次就行了</p><p>因为两个在同一行，他们有一维坐标是一样的，如果二分两次的话被卡满就是$n + n + 2\log n = 2020$次询问，刚刚好爆掉（来自出题人的恶意）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ans[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d %d %d\n"</span>, x1, y1, x2, y2);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> inp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(query(cur, l, cur, mid) &amp; <span class="number">1</span>)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(query(l, cur, mid, cur) &amp; <span class="number">1</span>)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = inp();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = query(i, <span class="number">1</span>, i, n);</span><br><span class="line">        <span class="keyword">if</span>(num &amp; <span class="number">1</span>)</span><br><span class="line">            ans[++cnt] = <span class="built_in">std</span>::make_pair(i, solve1(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = query(<span class="number">1</span>, i, n, i);</span><br><span class="line">            <span class="keyword">if</span>(num &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">                    ans[++cnt] = <span class="built_in">std</span>::make_pair(solve2(i), i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans[++cnt] = <span class="built_in">std</span>::make_pair(ans[<span class="number">1</span>].first, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d\n"</span>, ans[<span class="number">1</span>].first, ans[<span class="number">1</span>].second, ans[<span class="number">2</span>].first, ans[<span class="number">2</span>].second);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 非传统题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF343D Water Tree</title>
      <link href="/2019/03/29/Solutions/Solution-CF343D/"/>
      <url>/2019/03/29/Solutions/Solution-CF343D/</url>
      
        <content type="html"><![CDATA[<h2 id="似乎莫得人是不用树剖的w"><a href="#似乎莫得人是不用树剖的w" class="headerlink" title="似乎莫得人是不用树剖的w"></a>似乎莫得人是不用树剖的w</h2><p><del>但是为什么的一只$\log$乱搞被树剖的两只$\log$爆踩啊</del></p><p><del>是因为我实现的太丑了吗</del></p><p>不管了直接讲做法好了</p><a id="more"></a><p>首先，我们考虑一个很显然的结论：</p><blockquote><p>如果我们对于节点$x$他上次被灌水的时间位$x$，上次被清除水的时间是$y$</p><p>那么若有$x &gt; y$则此时这个节点有水</p><p>否则这个节点没水</p></blockquote><p>然后我们再考虑如何维护$x$和$y​$</p><p>我们把两种修改分别讨论，分别用树上差分和$dfs$序维护，就可以愉快地以$O(n \log n)$的复杂度切掉此题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(a) (a &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(a) (a &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG_Tree</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SEG</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">int</span> lazy;</span><br><span class="line">    &#125;t[<span class="number">2000000</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        t[cur].max = <span class="built_in">std</span>::max(t[lc(cur)].max, t[rc(cur)].max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t[cur].lazy)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        t[lc(cur)].max = t[rc(cur)].max = t[lc(cur)].lazy = t[rc(cur)].lazy = t[cur].lazy;</span><br><span class="line">        t[cur].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        t[cur].l = l;</span><br><span class="line">        t[cur].r = r;</span><br><span class="line">        t[cur].max = <span class="number">0</span>;</span><br><span class="line">        t[cur].lazy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(lc(cur), l, mid);</span><br><span class="line">        build(rc(cur), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt; r || t[cur].r &lt; l)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)&#123;</span><br><span class="line">            t[cur].max = c;</span><br><span class="line">            t[cur].lazy = c;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(cur);</span><br><span class="line">        modify(lc(cur), l, r, c);</span><br><span class="line">        modify(rc(cur), l, r, c);</span><br><span class="line">        push_up(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt; r || t[cur].r &lt; l)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)</span><br><span class="line">            <span class="keyword">return</span> t[cur].max;</span><br><span class="line">        push_down(cur);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(query(lc(cur), l, r), query(rc(cur), l, r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t1, t2;</span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">500010</span>], size[<span class="number">500010</span>], head[<span class="number">500010</span>], nxt[<span class="number">1000010</span>], end[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> cou = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    nxt[++cou] = head[a];</span><br><span class="line">    head[a] = cou;</span><br><span class="line">    end[cou] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    dfn[cur] = ++idx;</span><br><span class="line">    size[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = head[cur]; x != <span class="number">-1</span>; x = nxt[x])</span><br><span class="line">        <span class="keyword">if</span>(end[x] != last)&#123;</span><br><span class="line">            dfs(end[x], cur);</span><br><span class="line">            size[cur] += size[end[x]];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = inp();</span><br><span class="line">        <span class="keyword">int</span> v = inp();</span><br><span class="line">        link(u, v);</span><br><span class="line">        link(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = inp();</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    t1.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    t2.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> op = inp();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = inp();</span><br><span class="line">            t1.modify(<span class="number">1</span>, dfn[x], dfn[x] + size[x] - <span class="number">1</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = inp();</span><br><span class="line">            t2.modify(<span class="number">1</span>, dfn[x], dfn[x], i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = inp();</span><br><span class="line">            <span class="keyword">int</span> a1 = t1.query(<span class="number">1</span>, dfn[x], dfn[x]);</span><br><span class="line">            <span class="keyword">int</span> a2 = t2.query(<span class="number">1</span>, dfn[x], dfn[x] + size[x] - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// printf("%d %d\n", a1, a2);</span></span><br><span class="line">            <span class="keyword">if</span>(a1 &gt; a2)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树上差分 </tag>
            
            <tag> DFS序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1117D Magic Gems</title>
      <link href="/2019/03/02/Solutions/Solution-CF1117D/"/>
      <url>/2019/03/02/Solutions/Solution-CF1117D/</url>
      
        <content type="html"><![CDATA[<h2 id="有趣的矩阵乘法"><a href="#有趣的矩阵乘法" class="headerlink" title="有趣的矩阵乘法"></a>有趣的矩阵乘法</h2><p>（为方便，下文中“大号宝石”代指连续的$m$个分裂出来的宝石，“小号宝石”代指未分裂的单个宝石）</p><p>首先，我们观察这题，考虑$DP​$，设状态$f_i​$表示已经取了$i​$个单元的方案数的不难推出一个朴素的$O(n^2) DP​$方程$f_i = \displaystyle\sum_{i - j \geq m} f_j  +1​$（可以理解成上一个大号宝石放的位置，最后一个$1​$即为全部用小号宝石填满的方案）</p><p>我们再仔细看看这个式子，加个前缀和，不难优化到$O(n)$，然而数据范围$n \leq 10^{18}$，这让我们考虑$O(\log n)$级别的算法，我们接下来考虑矩阵乘法优化这个式子。</p><a id="more"></a><p>显然，这个式子跟满足$i - j \geq m​$的$j​$有关，但是这些数字的数量是$n​$级别的，我们考虑将$\displaystyle\sum_{i - j \geq m} f_j​$变形，变成$\displaystyle\sum_{j = 1}^{i} f_j - \sum_{j = i - m}^{j &lt; i} f_j​$ 这样只要我们维护一下$\displaystyle\sum_{j = 1}^{i} f_j​$就可以把需要维护的值的数量降到$m​$级别。</p><p>接下来直接在矩阵的第一行的第$j (1 \leq j \leq m) ​$ 位放上$f_{i - j}​$，然后第$m + 1​$位维护$\displaystyle\sum_{j = 1}^{i} f_j​$，第$m + 2​$位再弄个$1​$，瞎构造一通转移矩阵，就可以愉快的套矩阵快速幂板子了，最终复杂度$O(m^3 \log n)​$。</p><p>（转移的矩阵的具体构造建议看代码）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        Square <span class="keyword">operator</span> *(Square b)&#123;</span><br><span class="line">            Square ans;</span><br><span class="line">            <span class="built_in">memset</span>(ans.num, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans.num));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= len; k++)&#123;</span><br><span class="line">            ans.num[i][j] += num[i][k] * b.num[k][j];</span><br><span class="line">            ans.num[i][j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">            ans.len = len;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n = inp();</span><br><span class="line">    <span class="keyword">int</span> m = inp() - <span class="number">1</span>;</span><br><span class="line">    Square a, b;</span><br><span class="line">    a.len = m + <span class="number">2</span>;</span><br><span class="line">    b.len = m + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a.num, <span class="number">0</span>, <span class="keyword">sizeof</span>(a.num));</span><br><span class="line">    a.num[<span class="number">1</span>][m + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    a.num[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    a.num[<span class="number">1</span>][m + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(b.num, <span class="number">0</span>, <span class="keyword">sizeof</span>(b.num));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        b.num[i][m + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    b.num[m + <span class="number">1</span>][m + <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    b.num[m + <span class="number">2</span>][m + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    b.num[m + <span class="number">2</span>][m + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">        b.num[i - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        b.num[i][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    b.num[m + <span class="number">2</span>][<span class="number">1</span>] = b.num[m + <span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// n -= 2;</span></span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">            a = a * b;</span><br><span class="line">        b = b * b;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf("%lld\n", a.num[1][1]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf("%lld\n", (a * (b * b) * b * b).num[1][1]);</span></span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     printf("%lld\n", a.num[1][1]);</span></span><br><span class="line">    <span class="comment">//     a = a * b;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.num[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF452F Permutation</title>
      <link href="/2019/02/26/Solutions/Solution-CF452F/"/>
      <url>/2019/02/26/Solutions/Solution-CF452F/</url>
      
        <content type="html"><![CDATA[<h2 id="又双叒叕是题外话"><a href="#又双叒叕是题外话" class="headerlink" title="又双叒叕是题外话"></a>又双叒叕是题外话</h2><p>今天模拟考是原题大战。</p><p>$T1​$是这题。<br>$T2$是某次$CF\ Div1\ E$题。<br>$T3​$反正是某道神仙题。</p><p><del>像我这样的菜鸡只能来做做<strong>相对</strong>可做的T1</del></p><p><del>虽然只是相对可做但是还是被全场切穿了啊喂</del></p><p><del>内心OS：这个不订正的理由真的nice</del></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们看到题面要求求的三元组，然后瞎变形一下</p><script type="math/tex; mode=display">\begin{aligned}a_j - a_i &= a_k - a_i\\a_i + a_k &= 2 a_j \\a_k &= 2a_j - a_i\\\end{aligned}</script><p>这样子，我们开始试图枚举$j$，之后我们就有一个美妙的性质</p><blockquote><p>在$j$确定的情况下，对于一个$a_i$有对应的$a_j$可以组成三元组当且仅当</p><ul><li>$2a_j - a_i$存在（废话）</li><li>$2a_j - a_i$与$a_j$在$a_i$的不同侧</li></ul></blockquote><p>（如果第二点看不懂可以直接看下面的进一步推导）</p><p>我们用$s_i$表示$i$这个数在$j$左边的位置有没有出现过</p><p>那么我们可以把上面的两点东西给弄出来，那么就是</p><p>$\forall\ 1 \leq 2a_j - a_i \leq n, s_{a_i} \neq s_{2a_j - a_i}​$ </p><p>变换一下，变成不能组成三元组的条件，那就是</p><p>$\forall\ 1 \leq 2a_j - a_i \leq n, s_{a_i} = s_{2a_j - a_i}$ </p><p>表示在图上，那就可以画成这样↓</p><p><img src="http://dilute.coding.me/images/1.png" alt></p><p>（就是红色部分和绿色部分是对称的）<br>（反正这个意思感性理解一下）</p><p>好，然后我们接下来可以愉快地对$s$进行哈希了。</p><p>我们接下来考虑如何动态地维护$s$的哈希数组</p><p>现在的目标就是：资瓷单点修改和区间查询（正反都要）</p><p>实际上一个线段树就可以解决了</p><p>每个节点维护正反两个哈希值</p><p>就可以轻松写意地切掉此题。</p><p>这是我在模拟考时候写的代码，丑的一批。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(a) (a &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(a) (a &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(a, b) ((a) + (b) &gt;= mod ? (a) + (b) - mod : (a) + (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> minus(a, b) ((a) &lt; (b) ? (a) - (b) + mod : (a) - (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(a, b) ((a) * (ll)(b) % mod)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">int</span> powmod[<span class="number">300010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> rev;</span><br><span class="line"></span><br><span class="line">    SEG <span class="keyword">operator</span> + (<span class="keyword">const</span> SEG &amp;b) <span class="keyword">const</span> &#123; <span class="comment">// 为了方便查询的时候我把push_up给直接写成这种形式了</span></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">-1</span>)  <span class="comment">// (SEG)&#123;-1, -1, -1, -1&#125;  代表空的一段</span></span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(b.l == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> (SEG)&#123;l, r, sum, rev&#125;;</span><br><span class="line">        <span class="keyword">return</span> (SEG)&#123;l, b.r, add(mul(sum, powmod[b.r - b.l + <span class="number">1</span>]), b.sum), add(mul(b.rev, powmod[r - l + <span class="number">1</span>]), rev)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG_Tree</span>&#123;</span></span><br><span class="line">    SEG t[<span class="number">2400000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        t[cur] = t[lc(cur)] + t[rc(cur)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        t[cur].l = l;</span><br><span class="line">        t[cur].r = r;</span><br><span class="line">        t[cur].sum = t[cur].rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            t[cur].sum = t[cur].rev = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(lc(cur), l, mid);</span><br><span class="line">        build(rc(cur), mid + <span class="number">1</span>, r);</span><br><span class="line">        push_up(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pos, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l == t[cur].r)&#123;</span><br><span class="line">            t[cur].sum = t[cur].rev = c;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt;= t[lc(cur)].r)</span><br><span class="line">            modify(lc(cur), pos, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            modify(rc(cur), pos, c);</span><br><span class="line">        push_up(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SEG <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt; r || t[cur].r &lt; l)</span><br><span class="line">            <span class="keyword">return</span> (SEG)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// printf("[%d, %d], query(%d, %d), &#123;%d, %d&#125;\n", t[cur].l, t[cur].r, l, r, t[cur].sum, t[cur].rev);</span></span><br><span class="line">        <span class="keyword">if</span>(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)</span><br><span class="line">            <span class="keyword">return</span> t[cur];</span><br><span class="line">        <span class="keyword">return</span> query(lc(cur), l, r) + query(rc(cur), l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = inp();</span><br><span class="line">    powmod[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        powmod[i] = (powmod[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">    t.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">bool</span> flg = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        t.modify(<span class="number">1</span>, a[i], <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// printf("--------------------\na[i] = %d\n", a[i]);</span></span><br><span class="line">        <span class="keyword">if</span>((a[i] &lt;&lt; <span class="number">1</span>) - <span class="number">1</span> &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; <span class="number">1</span> &amp;&amp; t.query(<span class="number">1</span>, <span class="number">1</span>, a[i] - <span class="number">1</span>).sum != t.query(<span class="number">1</span>, a[i] + <span class="number">1</span>, (a[i] &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>).rev)&#123;</span><br><span class="line">                flg = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; n &amp;&amp; t.query(<span class="number">1</span>, a[i] + <span class="number">1</span>, n).rev != t.query(<span class="number">1</span>, (a[i] &lt;&lt; <span class="number">1</span>) - n, a[i] - <span class="number">1</span>).sum)&#123;</span><br><span class="line">                flg = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flg)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解P2892 追捕盗贼</title>
      <link href="/2019/02/21/Solutions/Solution-Luogu2892/"/>
      <url>/2019/02/21/Solutions/Solution-Luogu2892/</url>
      
        <content type="html"><![CDATA[<h3 id="本篇题解讲述的为非完美做法，但是可以骗到96分"><a href="#本篇题解讲述的为非完美做法，但是可以骗到96分" class="headerlink" title="本篇题解讲述的为非完美做法，但是可以骗到96分"></a>本篇题解讲述的为非完美做法，但是可以骗到96分</h3><p>说实话我在网上找了好久结果都是这个$O(n^2)$的非正解树型$DP$</p><p>听说有个$O(N)​$的正解在某篇论文里？</p><p>算了反正我也看不懂</p><p>所以我接下来就介绍一下这个$O(n^2)$的树型$DP$吧QwQ</p><p>顺手丢一下我学习的这篇<a href="https://www.cnblogs.com/qilinart2/articles/3416266.html" target="_blank" rel="noopener">blog​</a>吧</p><a id="more"></a><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>首先我们先用$f[i]$表示占领以$i$为根的子树所需要的人数</p><p>然后我们可以很显然地列出一个方程$f[u] = \max\{f[v]\}$</p><p>然后我们还要特判一下，如果有多个$f[v] = max\{f[v]\}$，那么得$f[u]$得再加上1</p><p>因为在我们进行每一个子树的占领的时候除了最后一个，必须得有一个人待在root处（具体可以看后面的代码）</p><h2 id="构造方案"><a href="#构造方案" class="headerlink" title="构造方案"></a>构造方案</h2><p>首先，我们预处理$n$次，分别以1~n为根，接下来就可以确定一个答案最小的根。</p><p>确认根之后，我们显然要先向根丢一个人，然后以为前面所说，我们得先把$f[v]$不是最大的$v$给先处理掉，然后再做$f[v]$最大的$v$。</p><p>而我们访问一棵子树的顺序如下：</p><ul><li>在$u$节点放一个警探</li><li>将$u$节点的其中一个警探走向$v$节点（为了防止目标待在$u \rightarrow v$的边上赖着不走）</li><li>递归做$v$节点</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">20010</span>];</span><br><span class="line"><span class="keyword">int</span> end[<span class="number">20010</span>];</span><br><span class="line"><span class="keyword">char</span> type[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> num1[<span class="number">100000</span>], num2[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cou = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    nxt[++cou] = head[a];</span><br><span class="line">    head[a] = cou;</span><br><span class="line">    end[cou] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> mt = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = head[cur]; x != <span class="number">-1</span>; x = nxt[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(end[x] != last)&#123;</span><br><span class="line">            dfs(end[x], cur);</span><br><span class="line">            <span class="keyword">if</span>(f[end[x]] &gt; max)&#123;</span><br><span class="line">                max = f[end[x]];</span><br><span class="line">                mt = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f[end[x]] == max)</span><br><span class="line">                mt = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mt)</span><br><span class="line">        f[cur] = max + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f[cur] = max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> mt = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = head[cur]; x != <span class="number">-1</span>; x = nxt[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(end[x] != last)&#123;</span><br><span class="line">            dfs(end[x], cur);</span><br><span class="line">            <span class="keyword">if</span>(f[end[x]] &gt; max)&#123;</span><br><span class="line">                max = f[end[x]];</span><br><span class="line">                mt = <span class="literal">false</span>;</span><br><span class="line">                pos = end[x];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f[end[x]] == max)</span><br><span class="line">                mt = <span class="literal">true</span>;</span><br><span class="line">            degree++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf("%d %d pos = %d\n", cur, last, pos);</span></span><br><span class="line">    <span class="keyword">if</span>(degree == <span class="number">0</span>)&#123;</span><br><span class="line">        type[++cnt] = <span class="string">'B'</span>;</span><br><span class="line">        num1[cnt] = cur;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = head[cur]; x != <span class="number">-1</span>; x = nxt[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(end[x] != pos &amp;&amp; end[x] != last)&#123;</span><br><span class="line">            type[++cnt] = <span class="string">'L'</span>;</span><br><span class="line">            num1[cnt] = cur;</span><br><span class="line">            type[++cnt] = <span class="string">'M'</span>;</span><br><span class="line">            num1[cnt] = cur;</span><br><span class="line">            num2[cnt] = end[x];</span><br><span class="line">            dfs2(end[x], cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    type[++cnt] = <span class="string">'M'</span>;</span><br><span class="line">    num1[cnt] = cur;</span><br><span class="line">    num2[cnt] = pos;</span><br><span class="line">    dfs2(pos, cur);</span><br><span class="line">    <span class="keyword">if</span>(mt)</span><br><span class="line">        f[cur] = max + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f[cur] = max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = inp();</span><br><span class="line">        <span class="keyword">int</span> v = inp();</span><br><span class="line">        link(u, v);</span><br><span class="line">        link(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dfs(i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(f[i] &lt; min)&#123;</span><br><span class="line">            min = f[i];</span><br><span class="line">            root = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(root, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, min, cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"L %d\n"</span>, root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(type[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, num1[i]);</span><br><span class="line">        <span class="keyword">if</span>(type[i] == <span class="string">'M'</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, num2[i]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 骗分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1111C Creative Snap</title>
      <link href="/2019/02/12/Solutions/Solution-CF1111C/"/>
      <url>/2019/02/12/Solutions/Solution-CF1111C/</url>
      
        <content type="html"><![CDATA[<h2 id="简单递归"><a href="#简单递归" class="headerlink" title="简单递归"></a>简单递归</h2><p>首先我们如果要消灭一段区间$[l, r]$，我们可以有三种选择：</p><ul><li>如果$[l, r]​$区间内没人，那么直接花费$A​$的代价将这段摧毁</li><li>如果$r  &gt; l​$（即这段区间长度$&gt;2​$），可以选择把它切割成$\left[ l, \lfloor \frac{l + r}2\rfloor\right]​$ $\left[\lceil \frac{l + r}2\rceil, r\right]​$两段</li><li>如果$[l, r]$区间内有人，直接花费$b (r - l + 1)x$的代价将其摧毁。</li></ul><a id="more"></a><p>那么我们可以直接递归寻找对于每个区间的最优解</p><p>但是如果暴力找，那么是$O(2^n)​$的。</p><p>然后我们可以发现一个很显然的结论，就是若一个区间内没人，那么第一种方案是肯定最优的。</p><p>可以理解成动态开点线段树上的$DP​$</p><p>将这个优化加上去之后复杂度就是正确的QwQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">int</span> neg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">            neg = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> neg * sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n, k, a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="built_in">std</span>::upper_bound(pos + <span class="number">1</span>, pos + k + <span class="number">1</span>, r) - <span class="built_in">std</span>::lower_bound(pos + <span class="number">1</span>, pos + k + <span class="number">1</span>, l);</span><br><span class="line">    <span class="comment">// printf("cnt [%d, %d] = %d\n", l, r, cnt);</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; cnt != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (r - l + <span class="number">1</span>) * cnt * b;</span><br><span class="line">    <span class="keyword">return</span> (cnt == <span class="number">0</span>) ? a : <span class="built_in">std</span>::min((r - l + <span class="number">1</span>) * cnt * b, solve(l, mid) + solve(mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = inp();</span><br><span class="line">    k = inp();</span><br><span class="line">    a = inp();</span><br><span class="line">    b = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        pos[i] = inp();</span><br><span class="line">    <span class="built_in">std</span>::sort(pos + <span class="number">1</span>, pos + k + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, solve(<span class="number">1</span>, <span class="number">1</span> &lt;&lt; n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P5174 圆点</title>
      <link href="/2019/01/28/Solutions/Solution-Luogu5174/"/>
      <url>/2019/01/28/Solutions/Solution-Luogu5174/</url>
      
        <content type="html"><![CDATA[<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>我本来自己想到的的做法是跟别的大多数题解一样的</p><p>但是$LJC00118$大仙跟我讲了他的做法，据说常数更小一些，于是我就过来发（水）题（社）解（区）了（分）。</p><a id="more"></a><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>首先，我们看到圆上整点，我们可以发现圆上整点的集合就是满足$x, y$都为整数，且$x^2 + y^2 \leq r^2$的点的集合，那么这题要求的东西就可以表示成<br>$\displaystyle\sum_{i = 1}^{\sqrt r}\sum_{i^2 + j^2 \leq r} i^2 + j^2$<br>表达不太规范，反正意思对就行QwQ</p><p>我们把这个式子给化一下</p><p>令$j​$的上界为$maxj​$<br>$ \displaystyle\sum_{i= 1}^{\sqrt r} \left(\sum_{j = 1}^{maxj} j^2\right) + i^2 * maxj ​$</p><p>$ \displaystyle\sum_{i = 1}^{\sqrt r} \frac{maxj(maxj + 1)(2maxj + 1)}{6} + i^2 * maxj$</p><p>然后我们瞪一下这个式子，显然可以发现$maxj​$是单调下降的</p><p>然后我们存一下$maxj​$，然后一遍枚举$i​$一边算$maxj​$就可以做了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            sum *= a;</span><br><span class="line">            sum %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        a %= mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">ll inv6;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n * (n + <span class="number">1</span>) % mod * ((n &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>) % mod) * inv6 % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inv6 = powmod(<span class="number">6</span>, mod - <span class="number">2</span>);</span><br><span class="line">    ll r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;r);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll num = <span class="built_in">sqrt</span>(r) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i * i &lt;= r; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i * i + num * num &gt; r)</span><br><span class="line">            num--;</span><br><span class="line">        ans += i * i % mod * num % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        ans += sum(num);</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    ans %= mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PKUWC2019游记</title>
      <link href="/2019/01/20/Other/PKUWC2019-Journey/"/>
      <url>/2019/01/20/Other/PKUWC2019-Journey/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="$Day\ 0$"></a>$Day\ 0$</h2><p>早上八点的飞机从杭州飞到广东中山纪念。</p><p>飞机上跟旁边的$sjn$神犇聊了一会之后开始颓废，后来敲了$fhq\ Treap$、最大流、费用流三个板子。</p><p>到了广东之后做了3个小时的公交车</p><p>到了中山纪念之后觉得宿舍略破，不过至少有电QwQ</p><p>试了个机，T1水题，T2据说是去年PKUSC的D1T2，想出了DP的状态定义不会转移，结果后来Sooke教我了一下，感觉不是特别想敲=-=</p><p>试完机之后还有蛮长的一段时间吃饭，于是我们就打了一盘狼人杀（法官真好玩）</p><p>饭菜一般般，坐我旁边的Sooke想找人面基，但是最后也就来的路上遇到了bztQwQ</p><p>晚上吃完饭，又来了一盘狼人杀（我还是法官）（双预言家真好玩）</p><p>现在是晚上7点，我躺在床上跟LJC00118一起写游记</p><p>真是充（颓）实（废）的一天</p><a id="more"></a><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="$Day\ 1$"></a>$Day\ 1$</h2><p>还是起床，吃饭，吃完早饭睡了个回炉觉然后去吃中饭</p><p>进考场，打开OJ，登录，看题。</p><p>第一题看上去像个状压，一时没想出来，于是我先打了个暴力，拿了26分之后再花30min写了个链的情况</p><p>现在得分40分，看看旁边的人，似乎没有A掉的，于是我开始想52分的部分分。</p><p>我觉得这个部分分不简单，于是我开始去肝$T3$，试图从T3拿个$30$~$40​$分，结果事实告诉我，我大错特错了。</p><p>我原以为3个小时的时间够我写+调了，然后我最后死在了我没打过斗地主</p><p>我以为不同长度的顺子可以接在一起=-=</p><p>我花了3个小时写T3，结果获得了0分的好成绩</p><p>九条可怜我***</p><p>$Day\ 1$总分$40 + 0 + 0 = 40\ pts$</p><p>出考场的瞬间发现T1是道签到傻逼题，</p><p>确确实实地感觉到了考场上智商$&gt;&gt;= 1$的$DEBUFF​$</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="$Day\ 2$"></a>$Day\ 2$</h2>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎写 </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fhq Treap与区间操作</title>
      <link href="/2019/01/16/Notes/fhq-Treap/"/>
      <url>/2019/01/16/Notes/fhq-Treap/</url>
      
        <content type="html"><![CDATA[<p>​        前段时间在机房里几个大爷的墙裂安利下学了发$fhq\ treap$ 于是就顺带着把$fhq\ treap$的区间操作给学了（比$Splay$的好理解多了）</p><p>似乎这么一点字太少了？那我放张图=-=</p><p><img src="dilute.coding.me/images/wxw_walking.gif" alt></p><a id="more"></a><h2 id="Ⅰ前置芝士-——-fhq-Treap-（非旋Treap）"><a href="#Ⅰ前置芝士-——-fhq-Treap-（非旋Treap）" class="headerlink" title="Ⅰ前置芝士 —— fhq Treap （非旋Treap）"></a>Ⅰ前置芝士 —— fhq Treap （非旋Treap）</h2><p><del>我这篇文章是来讲区间操作的</del></p><p><del>不是来教你fhq treap的</del></p><p><del>所以你如果不会fhq treap的话自己找别的讲稿把</del></p><p><del>其实主要是因为我自己一大半也是感性理解的啦</del></p><p><del>好吧还是贴个代码把</del></p><p>咳咳咳，没错，所以这个部分就是让你们来背代码的</p><h4 id="merge"><a href="#merge" class="headerlink" title="$merge$"></a>$merge$</h4><p>$merge(a, b)$的作用就是把根为b的树向根为a的树合并，并且返回合并出来的树的根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">if</span>(t[a].w &gt; t[b].w)&#123;</span><br><span class="line">        t[a].rc = merge(t[a].rc, b);</span><br><span class="line">        push_up(a);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t[b].lc = merge(a, t[b].lc);</span><br><span class="line">        push_up(b);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恩，就这么短。</p><h4 id="split"><a href="#split" class="headerlink" title="$split$"></a>$split$</h4><p>$split(a, b, c, d)$的作用是把根为a的子树分裂成两棵树$c, d$，并且$c$子树中是前$b$个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="number">0</span>)&#123;</span><br><span class="line">        a = b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= t[t[cur].lc].size)&#123;</span><br><span class="line">        b = cur;</span><br><span class="line">        split(t[cur].lc, k, a, t[b].lc);</span><br><span class="line">        push_up(b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = cur;</span><br><span class="line">        split(t[cur].rc, k - t[t[cur].lc].size - <span class="number">1</span>, t[a].rc, b);</span><br><span class="line">        push_up(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他核心操作？$\tan 90^{\text{o}}$。</p><p>因为$fhq\ treap$ 的核心操作就这俩玩意儿。</p><h2 id="Ⅱ-如何操作"><a href="#Ⅱ-如何操作" class="headerlink" title="Ⅱ 如何操作"></a>Ⅱ 如何操作</h2><p>显然，如果你要对一个区间进行操作，你就得先从它的根节点开始搞事情</p><p>那么你如何获得它的根节点呢？</p><p>如果你要操作一个$[l, r]$的区间</p><p>不管你怎么操作</p><p>肯定存在一个很方便的办法：弄出来一个表示$[l, r]$这个区间的子树。</p><p>说到子树，如果你学懂了$fhq$，那么你肯定能想到$split$操作</p><p><del>说到split，我就想到了唐僧与世俗split开去西天取经，明年年初，中美合拍，文体两开花，关注，谢谢支持。</del></p><p>在前一行，你什么都没看到，恩，就这样。</p><p>（瞬间正经）好，我们考虑如何$split$出来表示$[l , r]$区间的子树。</p><p>首先，我们首先$split$出来一个$size$为$l - 1$的子树，那剩下了第二棵子树，那么第二棵子树代表的显然就是$[l, n]$，然后你再$split$出来一个$size$为$r - l + 1$的子树，那么你这次$split$出来的子树代表的区间就是$[l, r]$啦</p><p>操作完之后我们就会得到3棵子树，你在第二棵上面做玩你想要的操作之后把子树$merge$回去就行了</p><p>比方说区间翻转的代码长这样↓</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    split(root, l - <span class="number">1</span>, x, y);</span><br><span class="line">    <span class="keyword">int</span> rt = y;</span><br><span class="line">    split(rt, r - l + <span class="number">1</span>, y, z);</span><br><span class="line">    t[y].lazy ^= <span class="number">1</span>;</span><br><span class="line">    root = merge(x, merge(y, z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于区间翻转的操作我会在下面讲↓</p><h2 id="Ⅲ-例题"><a href="#Ⅲ-例题" class="headerlink" title="Ⅲ 例题"></a>Ⅲ 例题</h2><h4 id="洛谷P3391-【模板】文艺平衡树（Splay）"><a href="#洛谷P3391-【模板】文艺平衡树（Splay）" class="headerlink" title="洛谷P3391 【模板】文艺平衡树（Splay）"></a>洛谷P3391 【模板】文艺平衡树（Splay）</h4><p>原题：<a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">&gt;Here&lt;</a></p><p>这边的区间翻转我们应当用打懒标的方式实现，然后每次操作的时候记得$pushdown$一下就行啦</p><p>怎么得到区间刚刚已经讲过了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fhq_Treap</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> lc;</span><br><span class="line">        <span class="keyword">int</span> rc;</span><br><span class="line">        <span class="keyword">bool</span> lazy;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">    &#125;t[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = cnt = <span class="number">0</span>;</span><br><span class="line">        t[<span class="number">0</span>].lc = t[<span class="number">0</span>].rc = t[<span class="number">0</span>].lazy = t[<span class="number">0</span>].size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        t[cur].size = t[t[cur].lc].size + t[t[cur].rc].size + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t[cur].lazy)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">std</span>::swap(t[cur].lc, t[cur].rc);</span><br><span class="line">        t[t[cur].lc].lazy ^= <span class="number">1</span>;</span><br><span class="line">        t[t[cur].rc].lazy ^= <span class="number">1</span>;</span><br><span class="line">        t[cur].lazy = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">        push_down(cur);</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>)&#123;</span><br><span class="line">            x = y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[t[cur].lc].size &gt;= k)&#123;</span><br><span class="line">            y = cur;</span><br><span class="line">            split(t[cur].lc, k, x, t[y].lc);</span><br><span class="line">            push_up(y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = cur;</span><br><span class="line">            split(t[cur].rc, k - t[t[cur].lc].size - <span class="number">1</span>, t[x].rc, y);</span><br><span class="line">            push_up(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        push_down(x);</span><br><span class="line">        push_down(y);</span><br><span class="line">        <span class="keyword">if</span>(t[x].w &gt; t[y].w)&#123;</span><br><span class="line">            t[x].rc = merge(t[x].rc, y);</span><br><span class="line">            push_up(x);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t[y].lc = merge(x, t[y].lc);</span><br><span class="line">            push_up(y);</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        split(root, l - <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">int</span> rt = y;</span><br><span class="line">        split(rt, r - l + <span class="number">1</span>, y, z);</span><br><span class="line">        t[y].lazy ^= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf("finished split phase.\n");</span></span><br><span class="line">        <span class="comment">// printf("%d %d, %d\n", x, y, z);</span></span><br><span class="line">        rt = merge(y, z);</span><br><span class="line">        <span class="comment">// print(rt);</span></span><br><span class="line">        root = merge(x, rt);</span><br><span class="line">        <span class="comment">// printf("completed reverse.\n");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        t[++cnt].lazy = <span class="literal">false</span>;</span><br><span class="line">        t[cnt].size = <span class="number">1</span>;</span><br><span class="line">        t[cnt].w = rand();</span><br><span class="line">        t[cnt].v = x;</span><br><span class="line">        t[cnt].lc = t[cnt].rc = <span class="number">0</span>;</span><br><span class="line">        root = merge(root, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        push_down(cur);</span><br><span class="line">        print(t[cur].lc);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, t[cur].v);</span><br><span class="line">        print(t[cur].rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t.init();</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">int</span> m = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        t.insert(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = inp();</span><br><span class="line">        <span class="keyword">int</span> r = inp();</span><br><span class="line">        <span class="comment">// t.print(t.root);</span></span><br><span class="line">        <span class="comment">// putchar('\n');</span></span><br><span class="line">        t.reverse(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    t.print(t.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SP4350-QMAX3VN-Gia-tri-lon-nhat-3"><a href="#SP4350-QMAX3VN-Gia-tri-lon-nhat-3" class="headerlink" title="SP4350 QMAX3VN - Giá trị lớn nhất 3"></a>SP4350 QMAX3VN - Giá trị lớn nhất 3</h4><p>原题：<a href="https://www.spoj.com/problems/QMAX3VN/" target="_blank" rel="noopener">&gt;Here&lt;</a></p><p><del>这题luogu上面没法用C艹交</del></p><p><del>但是fhq treap 这种一堆取址的东西用C弄超级麻烦</del></p><p><del>于是我贡献了大量的CE与UKE</del></p><p>好的，这题要求资瓷插入以及查询区间最大值</p><p>然后插入的话我们split两棵子树，$merge$的时候把新加的元素当做一棵子树并在中间就行了</p><p>节点上维护区间最大值就OK了</p><p>还是很简单的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    ll neg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">            neg = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum * neg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fhq_Treap</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">        ll max;</span><br><span class="line">        ll lc;</span><br><span class="line">        ll rc;</span><br><span class="line">        ll size;</span><br><span class="line">        ll v;</span><br><span class="line">        ll w;</span><br><span class="line">    &#125;t[<span class="number">200010</span>];</span><br><span class="line">    ll cnt, root;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = cnt = <span class="number">0</span>;</span><br><span class="line">        t[<span class="number">0</span>] = &#123;-INF, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">create</span><span class="params">(ll v)</span></span>&#123;</span><br><span class="line">        ll v0 = <span class="built_in">std</span>::max(v, <span class="number">0l</span>l);</span><br><span class="line">        t[++cnt] = &#123;v, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, v, rand()&#125;;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll cur)</span></span>&#123;</span><br><span class="line">        t[cur].max = <span class="built_in">std</span>::max(t[cur].v, <span class="built_in">std</span>::max(t[t[cur].lc].max, t[t[cur].rc].max));</span><br><span class="line">        t[cur].size = t[t[cur].lc].size + t[t[cur].rc].size + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf("cur = %lld, max = %lld\n", cur, t[cur].max);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">merge</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">if</span>(t[a].w &gt; t[b].w)&#123;</span><br><span class="line">            t[a].rc = merge(t[a].rc, b);</span><br><span class="line">            push_up(a);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t[b].lc = merge(a, t[b].lc);</span><br><span class="line">            push_up(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(ll cur, ll k, ll &amp;a, ll &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>)&#123;</span><br><span class="line">            a = b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= t[t[cur].lc].size)&#123;</span><br><span class="line">            b = cur;</span><br><span class="line">            split(t[cur].lc, k, a, t[b].lc);</span><br><span class="line">            push_up(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = cur;</span><br><span class="line">            split(t[cur].rc, k - t[t[cur].lc].size - <span class="number">1</span>, t[a].rc, b);</span><br><span class="line">            push_up(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll pos, ll v)</span></span>&#123;</span><br><span class="line">        ll x, y;</span><br><span class="line">        split(root, pos - <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="comment">// printf("Insert x = %lld, y = %lld\n", x, y);</span></span><br><span class="line">        root = merge(merge(x, create(v)), y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(ll pos)</span></span>&#123;</span><br><span class="line">        ll x, y, z;</span><br><span class="line">        split(root, pos - <span class="number">1</span>, x, y);</span><br><span class="line">        split(y, <span class="number">1</span>, y, z);</span><br><span class="line">        root = merge(x, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prll</span><span class="params">(ll cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        prll(t[cur].lc);</span><br><span class="line">        <span class="comment">// printf("t[%lld] v = %lld ls= %lld rs= %lld sum= %lld tot= %lld lc= %lld rc= %lld\n", cur, t[cur].v, t[cur].ls, t[cur].rs, t[cur].sum, t[cur].tot, t[cur].lc, t[cur].rc);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"t[%lld] = lc = %lld, rc = %lld, max = %lld, v = %lld\n"</span>, cur, t[cur].lc, t[cur].rc, t[cur].max, t[cur].v);</span><br><span class="line">        prll(t[cur].rc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll l, ll r)</span></span>&#123;</span><br><span class="line">        ll x, y, z;</span><br><span class="line">        split(root, l - <span class="number">1</span>, x, y);</span><br><span class="line">        split(y, r - l + <span class="number">1</span>, y, z);</span><br><span class="line">        <span class="comment">// prll(y);</span></span><br><span class="line">        ll ret = t[y].max;</span><br><span class="line">        root = merge(merge(x, y), z);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        root = merge(root, create(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t.init();</span><br><span class="line">    ll m = inp();</span><br><span class="line">    <span class="comment">// printf("%d\n", m);</span></span><br><span class="line">    <span class="comment">// t.prll(t.root);</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> type = getchar();</span><br><span class="line">        <span class="keyword">while</span>(type != <span class="string">'A'</span> &amp;&amp; type != <span class="string">'Q'</span>)</span><br><span class="line">            type = getchar();</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">'A'</span>)&#123;</span><br><span class="line">            ll x = inp();</span><br><span class="line">            ll pos = inp();</span><br><span class="line">            t.insert(pos, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll l = inp();</span><br><span class="line">            ll r = inp();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t.query(l, r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf("i = %lld, finished %c\n", i, type);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SP4487-GSS6-Can-you-answer-these-queries-VI"><a href="#SP4487-GSS6-Can-you-answer-these-queries-VI" class="headerlink" title="SP4487 GSS6 - Can you answer these queries VI"></a>SP4487 GSS6 - Can you answer these queries VI</h4><p>原题：<a href="https://www.spoj.com/problems/GSS6/" target="_blank" rel="noopener">&gt;Here&lt;</a></p><p>这题就比较毒瘤啦</p><p>资瓷区间查询最大子段和，插入，删除，修改。</p><p>区间最大字段和的话我们可以参照线段树做法，一个节点上维护左端点开始的，右端点开始的还有整个的最大字段和，以及区间的和。</p><p>$pushup$因为两段元素中间还多了个自己这个节点，所以会麻烦不少</p><p>删除的时候只要$split$出来之后中间那段不$merge$回去就行了</p><p>修改的时候只要把中间那段修改权值一下就行了</p><p>只是写完之后修锅要好长时间呢…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">int</span> neg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">            neg = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum * neg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fhq_Treap</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls;</span><br><span class="line">        <span class="keyword">int</span> rs;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">int</span> tot;</span><br><span class="line">        <span class="keyword">int</span> lc;</span><br><span class="line">        <span class="keyword">int</span> rc;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">    &#125;t[<span class="number">200010</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt, root;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = cnt = <span class="number">0</span>;</span><br><span class="line">        t[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, -INF, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v0 = <span class="built_in">std</span>::max(v, <span class="number">0l</span>l);</span><br><span class="line">        t[++cnt] = &#123;v0, v0, v, v, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, v, rand()&#125;;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].lc == <span class="number">0</span> &amp;&amp; t[cur].rc == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> v2 = <span class="built_in">std</span>::max(t[cur].v, <span class="number">0l</span>l);</span><br><span class="line">            t[cur].sum = t[cur].tot = t[cur].v;</span><br><span class="line">            t[cur].ls = t[cur].rs = v2;</span><br><span class="line">            t[cur].size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        t[cur].tot = t[t[cur].lc].tot + t[t[cur].rc].tot + t[cur].v;</span><br><span class="line">        t[cur].ls = <span class="built_in">std</span>::max(t[t[cur].lc].tot + t[cur].v + t[t[cur].rc].ls, t[t[cur].lc].ls);</span><br><span class="line">        t[cur].rs = <span class="built_in">std</span>::max(t[t[cur].rc].tot + t[cur].v + t[t[cur].lc].rs, t[t[cur].rc].rs);</span><br><span class="line"></span><br><span class="line">        t[cur].sum = <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(t[t[cur].lc].sum, t[t[cur].rc].sum), t[t[cur].lc].rs + t[cur].v + t[t[cur].rc].ls);</span><br><span class="line">        t[cur].size = t[t[cur].lc].size + t[t[cur].rc].size + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf("push up %lld | max&#123;%lld %lld %lld&#125; = %d\n", cur, t[t[cur].lc].sum, t[t[cur].rc].sum, t[t[cur].lc].rs + t[cur].v + t[t[cur].rc].ls, t[cur].sum);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">if</span>(t[a].w &gt; t[b].w)&#123;</span><br><span class="line">            t[a].rc = merge(t[a].rc, b);</span><br><span class="line">            push_up(a);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t[b].lc = merge(a, t[b].lc);</span><br><span class="line">            push_up(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>)&#123;</span><br><span class="line">            a = b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= t[t[cur].lc].size)&#123;</span><br><span class="line">            b = cur;</span><br><span class="line">            split(t[cur].lc, k, a, t[b].lc);</span><br><span class="line">            push_up(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = cur;</span><br><span class="line">            split(t[cur].rc, k - t[t[cur].lc].size - <span class="number">1</span>, t[a].rc, b);</span><br><span class="line">            push_up(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        split(root, pos - <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="comment">// printf("Insert x = %lld, y = %lld\n", x, y);</span></span><br><span class="line">        root = merge(merge(x, create(v)), y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        split(root, pos - <span class="number">1</span>, x, y);</span><br><span class="line">        split(y, <span class="number">1</span>, y, z);</span><br><span class="line">        <span class="keyword">int</span> v0 = <span class="built_in">std</span>::max(v, <span class="number">0l</span>l);</span><br><span class="line">        t[y] = &#123;v0, v0, v, v, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, v, t[y].w&#125;;</span><br><span class="line">        root = merge(merge(x, y), z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        split(root, pos - <span class="number">1</span>, x, y);</span><br><span class="line">        split(y, <span class="number">1</span>, y, z);</span><br><span class="line">        root = merge(x, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        print(t[cur].lc);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"t[%lld] v = %lld ls= %lld rs= %lld sum= %lld tot= %lld lc= %lld rc= %lld\n"</span>, cur, t[cur].v, t[cur].ls, t[cur].rs, t[cur].sum, t[cur].tot, t[cur].lc, t[cur].rc);</span><br><span class="line">        print(t[cur].rc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        split(root, l - <span class="number">1</span>, x, y);</span><br><span class="line">        split(y, r - l + <span class="number">1</span>, y, z);</span><br><span class="line">        <span class="comment">// print(y);</span></span><br><span class="line">        <span class="keyword">int</span> ret = t[y].sum;</span><br><span class="line">        root = merge(merge(x, y), z);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        root = merge(root, create(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t.init();</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        t.build(inp());</span><br><span class="line">    <span class="keyword">int</span> m = inp();</span><br><span class="line">    <span class="comment">// printf("%d\n", m);</span></span><br><span class="line">    <span class="comment">// t.print(t.root);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> type = getchar();</span><br><span class="line">        <span class="keyword">while</span>(type != <span class="string">'I'</span> &amp;&amp; type != <span class="string">'D'</span> &amp;&amp; type != <span class="string">'R'</span> &amp;&amp; type != <span class="string">'Q'</span>)</span><br><span class="line">            type = getchar();</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">'I'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = inp();</span><br><span class="line">            <span class="keyword">int</span> x = inp();</span><br><span class="line">            t.insert(pos, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">'D'</span>)&#123;</span><br><span class="line">            t.del(inp());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">'R'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = inp();</span><br><span class="line">            <span class="keyword">int</span> x = inp();</span><br><span class="line">            t.modify(pos, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = inp();</span><br><span class="line">            <span class="keyword">int</span> r = inp();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t.query(l, r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf("i = %lld, finished %c\n", i, type);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NOI2005-维护数列"><a href="#NOI2005-维护数列" class="headerlink" title="[NOI2005]维护数列"></a>[NOI2005]维护数列</h4><p>原题：<a href="https://www.luogu.org/problemnew/show/P2042" target="_blank" rel="noopener">&gt;Here&lt;</a></p><p>这题可以认为就是前三题加起来了</p><p>不过有一点要注意</p><p>在维护最大字段和的时候如果左右子树是反的那么会导致错误</p><p>所以我们不能像我给的文艺平衡树板子那样子写区间翻转</p><p>具体怎么做还是看代码把（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">int</span> neg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">            neg = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum * neg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fhq_Treap</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls;</span><br><span class="line">        <span class="keyword">int</span> rs;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">int</span> tot;</span><br><span class="line">        <span class="keyword">int</span> lc;</span><br><span class="line">        <span class="keyword">int</span> rc;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> lazy;</span><br><span class="line">        <span class="keyword">bool</span> reverse;</span><br><span class="line">    &#125;t[<span class="number">5000010</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt, root;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = cnt = <span class="number">0</span>;</span><br><span class="line">        t[<span class="number">0</span>] = (T)&#123;<span class="number">0</span>, <span class="number">0</span>, -INF, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -INF, <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v0 = <span class="built_in">std</span>::max(v, <span class="number">0</span>);</span><br><span class="line">        t[++cnt] = (T)&#123;v0, v0, v, v, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, v, rand(), -INF, <span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[cur].lc == <span class="number">0</span> &amp;&amp; t[cur].rc == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> v2 = <span class="built_in">std</span>::max(t[cur].v, <span class="number">0</span>);</span><br><span class="line">            t[cur].sum = t[cur].tot = t[cur].v;</span><br><span class="line">            t[cur].ls = t[cur].rs = v2;</span><br><span class="line">            t[cur].size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        t[cur].tot = t[t[cur].lc].tot + t[t[cur].rc].tot + t[cur].v;</span><br><span class="line">        t[cur].ls = <span class="built_in">std</span>::max(t[t[cur].lc].tot + t[cur].v + t[t[cur].rc].ls, t[t[cur].lc].ls);</span><br><span class="line">        t[cur].rs = <span class="built_in">std</span>::max(t[t[cur].rc].tot + t[cur].v + t[t[cur].lc].rs, t[t[cur].rc].rs);</span><br><span class="line"></span><br><span class="line">        t[cur].sum = <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(t[t[cur].lc].sum, t[t[cur].rc].sum), t[t[cur].lc].rs + t[cur].v + t[t[cur].rc].ls);</span><br><span class="line">        t[cur].size = t[t[cur].lc].size + t[t[cur].rc].size + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf("push up %d | max&#123;%d %d %d&#125; = %d\n", cur, t[t[cur].lc].sum, t[t[cur].rc].sum, t[t[cur].lc].rs + t[cur].v + t[t[cur].rc].ls, t[cur].sum);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[cur].lazy != -INF)&#123;</span><br><span class="line"><span class="keyword">int</span> v0 = <span class="built_in">std</span>::max(t[cur].lazy, <span class="number">0</span>);</span><br><span class="line">t[t[cur].lc].ls = t[t[cur].lc].rs = v0 * t[t[cur].lc].size;</span><br><span class="line">t[t[cur].rc].ls = t[t[cur].rc].rs = v0 * t[t[cur].rc].size;</span><br><span class="line">t[t[cur].lc].sum = <span class="built_in">std</span>::max(t[cur].lazy, t[cur].lazy * t[t[cur].lc].size);</span><br><span class="line">t[t[cur].rc].sum = <span class="built_in">std</span>::max(t[cur].lazy, t[cur].lazy * t[t[cur].rc].size);</span><br><span class="line"></span><br><span class="line">t[t[cur].lc].tot = t[cur].lazy * t[t[cur].lc].size;</span><br><span class="line">t[t[cur].rc].tot = t[cur].lazy * t[t[cur].rc].size;</span><br><span class="line"></span><br><span class="line">t[t[cur].lc].lazy = t[cur].lazy; </span><br><span class="line">t[t[cur].rc].lazy = t[cur].lazy;</span><br><span class="line">t[t[cur].lc].v = t[t[cur].rc].v = t[cur].lazy;</span><br><span class="line"></span><br><span class="line">t[cur].lazy = -INF;</span><br><span class="line">t[cur].reverse = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t[cur].reverse)&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(t[t[cur].lc].lc, t[t[cur].lc].rc);</span><br><span class="line">        <span class="built_in">std</span>::swap(t[t[cur].rc].lc, t[t[cur].rc].rc);</span><br><span class="line">        <span class="built_in">std</span>::swap(t[t[cur].lc].ls, t[t[cur].lc].rs);</span><br><span class="line">        <span class="built_in">std</span>::swap(t[t[cur].rc].ls, t[t[cur].rc].rs);</span><br><span class="line">t[t[cur].lc].reverse ^= <span class="number">1</span>;</span><br><span class="line">        t[t[cur].rc].reverse ^= <span class="number">1</span>;</span><br><span class="line">        t[cur].reverse = <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">        t[<span class="number">0</span>] = (T)&#123;<span class="number">0</span>, <span class="number">0</span>, -INF, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -INF, <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        push_down(a);</span><br><span class="line">        push_down(b);</span><br><span class="line">        <span class="keyword">if</span>(t[a].w &gt; t[b].w)&#123;</span><br><span class="line">            t[a].rc = merge(t[a].rc, b);</span><br><span class="line">            push_up(a);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t[b].lc = merge(a, t[b].lc);</span><br><span class="line">            push_up(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>)&#123;</span><br><span class="line">            a = b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(cur);</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= t[t[cur].lc].size)&#123;</span><br><span class="line">            b = cur;</span><br><span class="line">            split(t[cur].lc, k, a, t[b].lc);</span><br><span class="line">            push_up(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = cur;</span><br><span class="line">            split(t[cur].rc, k - t[t[cur].lc].size - <span class="number">1</span>, t[a].rc, b);</span><br><span class="line">            push_up(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        split(root, pos, x, y);</span><br><span class="line">        root = merge(merge(x, rt), y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> len, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        split(root, pos - <span class="number">1</span>, x, y);</span><br><span class="line">        split(y, len, y, z);</span><br><span class="line">        t[y].ls = t[y].rs = <span class="built_in">std</span>::max(v, <span class="number">0</span>) * t[y].size;</span><br><span class="line">        t[y].tot = t[y].size * v;</span><br><span class="line">    t[y].sum = <span class="built_in">std</span>::max(v, v * t[y].size);</span><br><span class="line">    t[y].lazy = v;</span><br><span class="line">    t[y].v = v;</span><br><span class="line">        root = merge(merge(x, y), z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        split(root, pos - <span class="number">1</span>, x, y);</span><br><span class="line">        split(y, len, y, z);</span><br><span class="line">        root = merge(x, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        push_down(cur);</span><br><span class="line">        print(t[cur].lc);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"t[%d] v = %d ls= %d rs= %d sum= %d tot= %d lc= %d rc= %d\n"</span>, cur, t[cur].v, t[cur].ls, t[cur].rs, t[cur].sum, t[cur].tot, t[cur].lc, t[cur].rc);</span><br><span class="line">        print(t[cur].rc);</span><br><span class="line">        push_up(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        split(root, l - <span class="number">1</span>, x, y);</span><br><span class="line">        split(y, len, y, z);</span><br><span class="line">        <span class="comment">// print(y);</span></span><br><span class="line">        <span class="keyword">int</span> ret = t[y].tot;</span><br><span class="line">        root = merge(merge(x, y), z);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        root = merge(root, create(x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    split(root, pos - <span class="number">1</span>, x, y);</span><br><span class="line">    split(y, len, y, z);</span><br><span class="line">    t[y].reverse ^= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::swap(t[y].lc, t[y].rc);</span><br><span class="line">    <span class="built_in">std</span>::swap(t[y].ls, t[y].rs);</span><br><span class="line">    root = merge(merge(x, y), z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t.init();</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">int</span> m = inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        t.build(inp());</span><br><span class="line">    <span class="comment">// printf("%d\n", m);</span></span><br><span class="line">    <span class="comment">// t.print(t.root);</span></span><br><span class="line">    <span class="keyword">char</span> type[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, type);</span><br><span class="line"><span class="keyword">if</span>(type[<span class="number">0</span>] == <span class="string">'I'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> pos = inp();</span><br><span class="line"><span class="keyword">int</span> cnt = inp();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> rt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">rt = t.merge(rt, t.create(inp()));</span><br><span class="line">            t.insert(pos, rt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type[<span class="number">0</span>] == <span class="string">'D'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = inp();</span><br><span class="line">            <span class="keyword">int</span> len = inp();</span><br><span class="line">t.del(l, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type[<span class="number">0</span>] == <span class="string">'R'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = inp();</span><br><span class="line">            <span class="keyword">int</span> len = inp();</span><br><span class="line">            t.reverse(pos, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; type[<span class="number">2</span>] == <span class="string">'K'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = inp();</span><br><span class="line">            <span class="keyword">int</span> len = inp();</span><br><span class="line">            <span class="keyword">int</span> x = inp();</span><br><span class="line">            t.modify(pos, len, x);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(type[<span class="number">0</span>] == <span class="string">'G'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> pos = inp();</span><br><span class="line"><span class="keyword">int</span> len = inp();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.query(pos, len));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.t[t.root].sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// t.print(t.root);</span></span><br><span class="line">        <span class="comment">// putchar('\n');</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅳ-与其他相似算法的比较"><a href="#Ⅳ-与其他相似算法的比较" class="headerlink" title="Ⅳ 与其他相似算法的比较"></a>Ⅳ 与其他相似算法的比较</h2><h4 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h4><p>Splay的作用跟$fhq\ Treap$差不多，都是可以维护区间操作，但是个人认为$fhq$优于$Splay$，理由有二</p><ul><li>好写，代码短</li><li>易于理解</li></ul><p>而且，$fhq$的常数跟$Splay$差不多</p><p>但是$fhq$的缺点也是显著，就是不能写LCT。</p><h4 id="其他平衡树"><a href="#其他平衡树" class="headerlink" title="其他平衡树"></a>其他平衡树</h4><p>不得不说$fhq$和$Splay$两个可以维护区间操作的平衡树在常数方面完全可以以变态大的常数打爆其他平衡树（甚至包括$set$）</p><p>所以，如果不写区间操作，$set$都比$fhq$快。</p><p>完结撒花～～</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷4142 洞穴遇险</title>
      <link href="/2019/01/10/Solutions/Solution-Luogu4142/"/>
      <url>/2019/01/10/Solutions/Solution-Luogu4142/</url>
      
        <content type="html"><![CDATA[<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>我们模拟赛考了这题。</p><p>模拟赛大概还剩一个半小时的时候，我想出了这题，并且说</p><blockquote><p>“要是我这没A掉，我就不交卷了”</p></blockquote><p>于是我就没有A掉。</p><p>其实赛后半个小时左右就调出来了（我才不会告诉你我比赛的时候那个建模是有锅的呢）</p><a id="more"></a><h2 id="大思路"><a href="#大思路" class="headerlink" title="大思路"></a>大思路</h2><p>首先考试的时候去做另外两题</p><p>我另外两题暴力刚敲完，旁边的$Isonan$爷大吼一声</p><blockquote><p>A了！</p></blockquote><p>于是我一惊，$Isonan$爷固然巨，但是考试才过了1个小时，这题似乎不难，我开始考虑正解。</p><p>我看到这$n = 50$的数据规模，我意识到这题正解估计就是网络流之类的解法</p><p>看到这个神奇的$L$字形，我们就可以往奇偶分层方面想。</p><h2 id="鬼畜建模"><a href="#鬼畜建模" class="headerlink" title="鬼畜建模"></a>鬼畜建模</h2><p>首先，我们马上可以想到把$x + y$为奇数的有权的点给拎出来，称为a类点</p><p>然后把剩下来无点权的点分类</p><p>如果它在偶数行，称为b类点</p><p>否则称为c类点</p><p>那么一个3*3的矩阵分类之后长这样↓</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span></span><br><span class="line">|c|a|c|</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span></span><br><span class="line">|a|b|a|</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span></span><br><span class="line">|c|a|c|</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span></span><br></pre></td></tr></table></figure><p>然后显然，贪心地想，一个L字形必须得放在有点权的A类点上</p><p>那么感性理解一下，一个L字形肯定是由一个a一个b一个c组成的</p><p>然后继续感性理解，我们可以弄出来一个类似带权三分图匹配（大雾）之类的东西</p><p>具体是这样的</p><ul><li><p>源点向源点2 连边 流量$m$费用0（最多放$m$个石头）</p></li><li><p>源点2 向 $b$连边，流量$1$ 费用$0$</p></li><li><p>将$a$拆点</p></li><li><p>$b$ 向 $a$入点连边，流量$1$ 费用$0$</p></li><li><p>$a$ 入点向 $a$ 出点连边，流量$1​$，费用为该点的点权</p></li><li><p>$a$ 出点向 $c$ 连边，流量$1$，费用$0$</p></li><li><p>$c$ 向汇点连边，流量$1$，费用$0$</p></li><li><p>最后跑最大费用最大流即可。</p></li></ul><p>由于我以前有个假的解法，导致我的$b$和$c$类点也拆了点，所以可以不用在意，意思对就行。</p><h2 id="需要注意的一个坑"><a href="#需要注意的一个坑" class="headerlink" title="需要注意的一个坑"></a>需要注意的一个坑</h2><p>每次增广之后都应该重新统计一遍答案，因为$m$的流量不一定要流满。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>具体的还是上代码吧。</p><p>实现的比较丑，轻喷。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i, j) ((i - 1) * n + j)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">int</span> neg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">neg = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">sum = ((sum &lt;&lt; <span class="number">3</span>) + (sum &lt;&lt; <span class="number">1</span>)) + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> neg * sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> opt[<span class="number">10</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">int</span> end[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> prev1[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> prev2[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">bool</span> inq[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">bool</span> dag[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> Cou = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">// printf("linked %d and %d\n", a, b);</span></span><br><span class="line">nxt[++Cou] = head[a];</span><br><span class="line">head[a] = Cou;</span><br><span class="line">end[Cou] = b;</span><br><span class="line">value[Cou] = v;</span><br><span class="line">cost[Cou] = c;</span><br><span class="line"></span><br><span class="line">nxt[++Cou] = head[b];</span><br><span class="line">head[b] = Cou;</span><br><span class="line">end[Cou] = a;</span><br><span class="line">value[Cou] = <span class="number">0</span>;</span><br><span class="line">cost[Cou] = -c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="keyword">int</span> n = inp();</span><br><span class="line"><span class="keyword">int</span> m = inp();</span><br><span class="line">    <span class="keyword">int</span> k = inp();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            w[i][j] = inp();</span><br><span class="line">            sum += w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = inp();</span><br><span class="line">        <span class="keyword">int</span> y = inp();</span><br><span class="line">        dag[x][y] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    link(s, <span class="number">200001</span>, m, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">200000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                link(get(i, j), get(i, j) + (n * n), <span class="number">1</span>, -w[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j &gt; <span class="number">1</span>)</span><br><span class="line">                        link(get(i, j) + (n * n), get(i, j - <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; n)</span><br><span class="line">                        link(get(i, j) + (n * n), get(i, j + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">1</span>)</span><br><span class="line">                        link(get(i, j) + (n * n), get(i - <span class="number">1</span>, j), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; n)</span><br><span class="line">                        link(get(i, j) + (n * n), get(i + <span class="number">1</span>, j), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(dag[i][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                link(get(i, j), get(i, j) + (n * n), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    link(get(i, j) + (n * n), e, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    link(<span class="number">200001</span>, get(i, j), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + opt[u][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + opt[u][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(tx &lt; <span class="number">1</span> || tx &gt; n || ty &lt; <span class="number">1</span> || ty &gt; n)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        link(get(i, j) + (n * n), get(tx, ty), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f = INF;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(f &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        q[<span class="number">1</span>] = s;</span><br><span class="line">        <span class="keyword">int</span> qf = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> qe = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(qf &lt;= qe)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = q[qf++];</span><br><span class="line">            inq[u] = <span class="literal">false</span>;</span><br><span class="line">            sum -= dis[u];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = head[u]; x != <span class="number">-1</span>; x = nxt[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(value[x] &gt; <span class="number">0</span> &amp;&amp; dis[end[x]] &gt; dis[u] + cost[x])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(inq[end[x]])</span><br><span class="line">                        sum -= dis[end[x]];</span><br><span class="line">                    dis[end[x]] = dis[u] + cost[x];</span><br><span class="line">                    prev1[end[x]] = u;</span><br><span class="line">                    prev2[end[x]] = x;</span><br><span class="line">                    sum += dis[end[x]];</span><br><span class="line">                    <span class="keyword">if</span>(!inq[end[x]])&#123;</span><br><span class="line">                    q[++qe] = end[x];</span><br><span class="line">                        inq[end[x]] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= 20; i++)</span></span><br><span class="line">        <span class="comment">//     printf("%d ", dis[i]);</span></span><br><span class="line">        <span class="comment">// putchar('\n');</span></span><br><span class="line"><span class="keyword">if</span>(dis[e] == dis[<span class="number">200002</span>])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> delta = f;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = e; i != s; i = prev1[i])&#123;</span><br><span class="line">            <span class="comment">// printf("%d&lt;-(%d)--", i % (n * n), value[prev2[i]]);</span></span><br><span class="line">delta = <span class="built_in">std</span>::min(delta, value[prev2[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// putchar('\n');</span></span><br><span class="line">f -= delta;</span><br><span class="line">flow += delta;</span><br><span class="line">ans += delta * dis[e];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = e; i != s; i = prev1[i])&#123;</span><br><span class="line">value[prev2[i]] -= delta;</span><br><span class="line">value[prev2[i] ^ <span class="number">1</span>] += delta;</span><br><span class="line">&#125;</span><br><span class="line">        ret = <span class="built_in">std</span>::min(ret, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, sum + ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈珂朵莉树</title>
      <link href="/2019/01/10/Notes/Chtholly-Tree/"/>
      <url>/2019/01/10/Notes/Chtholly-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Ⅰ-什么是珂朵莉？"><a href="#Ⅰ-什么是珂朵莉？" class="headerlink" title="Ⅰ 什么是珂朵莉？"></a>Ⅰ 什么是珂朵莉？</h2><p>珂朵莉是世界上最幸福的女孩，没有之一，不接受任何反驳。</p><p><img src="../../../../../images/Chtholly.jpg" alt></p><a id="more"></a><h2 id="Ⅱ-什么是珂朵莉树？"><a href="#Ⅱ-什么是珂朵莉树？" class="headerlink" title="Ⅱ 什么是珂朵莉树？"></a>Ⅱ 什么是珂朵莉树？</h2><p>珂朵莉树又称<code>ODT</code>，是一种基于$std::set$ 的数据结构，复杂度其实是假的，但是在数据随机的时候可以有很好的表现。</p><p>但是珂朵莉树的使用局限性较大，非常好卡，而且如果没有<strong>区间赋值</strong>操作的话，那就是毫无用武之地。</p><p>说白了就是用$set$维护一段连续的相同元素。</p><h2 id="Ⅲ-珂朵莉树的实现"><a href="#Ⅲ-珂朵莉树的实现" class="headerlink" title="Ⅲ 珂朵莉树的实现"></a>Ⅲ 珂朵莉树的实现</h2><h4 id="1-定义节点"><a href="#1-定义节点" class="headerlink" title="1.定义节点"></a>1.定义节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">mutable</span> ll v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; b.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node&gt; s;</span><br></pre></td></tr></table></figure><p>我来解释一下各部分吧。</p><p>$l, r$很显然就是这个区间的左右端点。</p><p>$v$很显然就是这个区间共同的权值。</p><p>顺便说一下$mutable$，这是个黑科技，可以让你对着迭代器直接修改里面不影响顺序的值。</p><p>然后下面那个重载运算符就是拿来为了让它在$set$里面的顺序是对的。</p><p>哦对，为了方便，我一般习惯加上这么一句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter std::set<span class="meta-string">&lt;Node&gt;::iterator</span></span></span><br></pre></td></tr></table></figure><p>看后面代码的时候自行脑补一下吧QwQ</p><h4 id="2-建树"><a href="#2-建树" class="headerlink" title="2.建树"></a>2.建树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    s.insert((Node)&#123;i, i, a[i]&#125;);</span><br></pre></td></tr></table></figure><p>应该不用我多讲，就是把每个点当做一个连续的段暴力插入就行了。</p><h4 id="3-核心操作1-split"><a href="#3-核心操作1-split" class="headerlink" title="3.核心操作1 $split$"></a>3.核心操作1 $split$</h4><p>$split$操作，顾名思义，就是把原来一段的一个区间分成两段。</p><p>一般而言，$split$操作都要返回切成的两块区间的右边那段的$iterator$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iter <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    iter it = s.lower_bound((Node)&#123;pos, pos, <span class="number">-1</span>&#125;); <span class="comment">// 找到它的后一个</span></span><br><span class="line">    <span class="keyword">if</span> (it != s.end() &amp;&amp; it-&gt;l == pos) <span class="comment">// 如果根本无需删除，直接return</span></span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    it--; <span class="comment">// 因为找到的是我们需要split的后一个，所以应当分离</span></span><br><span class="line">    Node ins = *it; <span class="comment">// 先把我们要删掉的节点存储好</span></span><br><span class="line">    s.erase(it); <span class="comment">// 分离 = 删除 + 2 * 插入</span></span><br><span class="line">    s.insert((Node)&#123;ins.l, pos - <span class="number">1</span>, ins.v&#125;);</span><br><span class="line">    <span class="keyword">return</span> s.insert((Node)&#123;pos, ins.r, ins.v&#125;).first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人认为注释里面应该写的比较清楚了QwQ</p><p>这应该是最难懂的部分了，如果这部分看懂了接下来的就不难了。</p><h4 id="4-核心操作2-assign"><a href="#4-核心操作2-assign" class="headerlink" title="4.核心操作2 $assign$"></a>4.核心操作2 $assign$</h4><p>$assign$操作虽然有个很好听的名字：推平一段区间</p><p>但是实际上，就是个区间赋值。</p><p>那为什么说$assign$操作也是珂朵莉树的核心操作呢？</p><p>因为珂朵莉树的复杂度是由它保证的。</p><p>一次$assign$操作就会是$set$的规模大幅度减少，而且保证数据随机的情况下，$assign$操作出现的概率不小，而且一次的范围也很大，会让$set$的规模一直在一个很小的范围里。（毕竟人家$split$一次才多一个，$assign$一下直接一段区间就推平了）</p><p>给上代码～</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;</span><br><span class="line">    iter it_r = split(r + <span class="number">1</span>);</span><br><span class="line">    iter it_l = split(l);</span><br><span class="line">    s.erase(it_l, it_r); <span class="comment">// 这样子就可以erase一个区间了</span></span><br><span class="line">    s.insert((Node)&#123;l, r, v&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别短小精悍有木有？</p><h2 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h2><p>我们这边就以珂朵莉树公认模板题$Willem, Chtholly\ and\ Seniorious$来做例子了</p><p>原题传送门：<a href="http://codeforces.com/problemset/problem/896/C" target="_blank" rel="noopener">&gt;Here&lt;</a></p><h4 id="5-区间加"><a href="#5-区间加" class="headerlink" title="5.区间加"></a>5.区间加</h4><p>暴力加。</p><p>把两端$split$出来，然后，把中间的所有$iterator$里的$v$全都加上$c$。</p><p>然后我们之前假的$mutable$标记就可以用上了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll l, ll r, ll c)</span></span>&#123;</span><br><span class="line">    iter it_r = split(r + <span class="number">1</span>);</span><br><span class="line">    iter it_l = split(l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(iter it = it_l; it != it_r; it++)</span><br><span class="line">        it-&gt;v += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>又一个一个for循环解决的操作</del></p><p>接下来的操作就可以体现出珂朵莉树的强大了。</p><h4 id="6-求-displaystyle-sum-i-l-r-a-i-x"><a href="#6-求-displaystyle-sum-i-l-r-a-i-x" class="headerlink" title="6.求$\displaystyle\sum_{i = l}^{r} a_i^x$"></a>6.求$\displaystyle\sum_{i = l}^{r} a_i^x$</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll x, ll y)</span></span>&#123;</span><br><span class="line">    iter it_l = split(l);</span><br><span class="line">    iter it_r = split(r + <span class="number">1</span>);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(iter it = it_l; it != it_r; it++)&#123;</span><br><span class="line">        ans += (ll)(it-&gt;r - it-&gt;l + <span class="number">1</span>) * powmod(it-&gt;v, x, y);</span><br><span class="line">        ans %= y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速幂大家应该都会，<del>应该不会有人没学快速幂就来学这种DL数据结构吧</del>，我就不贴了。</p><p>恩，就是这么暴力，把每段区间取出来，把每个元素的$x$次方算出来，乘上这个连续段的长度，加起来，显然就是答案了。</p><h4 id="7-区间第k大"><a href="#7-区间第k大" class="headerlink" title="7.区间第k大"></a>7.区间第k大</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span>&#123;</span></span><br><span class="line">    ll len;</span><br><span class="line">    ll v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node2 a, Node2 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">k_query</span><span class="params">(ll l, ll r, ll k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node2&gt; q;</span><br><span class="line">    q.clear();</span><br><span class="line">    iter it_l = split(l);</span><br><span class="line">    iter it_r = split(r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(iter it = it_l; it != it_r; it++)</span><br><span class="line">        q.push_back((Node2)&#123;it-&gt;r - it-&gt;l + <span class="number">1</span>, it-&gt;v&#125;);</span><br><span class="line">    <span class="built_in">std</span>::sort(q.begin(), q.end(), cmp);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node2&gt;::iterator it = q.begin(); it != q.end(); it++)&#123;</span><br><span class="line">        sum += it-&gt;len;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= k)</span><br><span class="line">            <span class="keyword">return</span> it-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个稍微复杂一点，但是实际上还是暴力。</p><p>把所有元素取出来，记录一下每个元素出现的数量。</p><p>然后把元素排个序，就可以愉快的找到第$k$大了。</p><p>至此，$CF896C$的所有操作都讲完了。</p><p>这边我顺便贴一下$CF896C$的完整代码把</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter std::set<span class="meta-string">&lt;Node&gt;::iterator</span></span></span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">ll seed, vmax;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ret = seed;</span><br><span class="line">    seed = (seed * <span class="number">7</span> + <span class="number">13</span>) % <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ll l;</span><br><span class="line">    ll r;</span><br><span class="line">    <span class="keyword">mutable</span> ll v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; b.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">iter <span class="title">split</span><span class="params">(ll pos)</span></span>&#123;</span><br><span class="line">    iter it = s.lower_bound((Node)&#123;pos, pos, <span class="number">-1</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span> (it != s.end() &amp;&amp; it-&gt;l == pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    it--;</span><br><span class="line">    Node ins = *it;</span><br><span class="line">    s.erase(it);</span><br><span class="line">    s.insert((Node)&#123;ins.l, pos - <span class="number">1</span>, ins.v&#125;);</span><br><span class="line">    <span class="keyword">return</span> s.insert((Node)&#123;pos, ins.r, ins.v&#125;).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(ll l, ll r, ll v)</span></span>&#123;</span><br><span class="line">    iter it_l = split(l), it_r = split(r + <span class="number">1</span>);</span><br><span class="line">    s.erase(it_l, it_r);</span><br><span class="line">    s.insert((Node)&#123;l, r, v&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            sum *= a;</span><br><span class="line">            sum %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        a %= mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll l, ll r, ll x, ll y)</span></span>&#123;</span><br><span class="line">    iter it_l = split(l);</span><br><span class="line">    iter it_r = split(r + <span class="number">1</span>);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(iter it = it_l; it != it_r; it++)&#123;</span><br><span class="line">        <span class="comment">// prllf("[%d %d] -&gt; %d\n", it-&gt;l, it-&gt;r, it-&gt;v);</span></span><br><span class="line">        ans += (ll)(it-&gt;r - it-&gt;l + <span class="number">1</span>) * powmod(it-&gt;v, x, y);</span><br><span class="line">        ans %= y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll l, ll r, ll c)</span></span>&#123;</span><br><span class="line">    iter it_l = split(l);</span><br><span class="line">    iter it_r = split(r + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(iter it = it_l; it != it_r; it++)&#123;</span><br><span class="line">        <span class="comment">// Node ins = *it;</span></span><br><span class="line">        <span class="comment">// ins.v += c;</span></span><br><span class="line">        <span class="comment">// s.erase(it);</span></span><br><span class="line">        <span class="comment">// s.insert(ins);</span></span><br><span class="line">        <span class="comment">// it = s.find(ins);</span></span><br><span class="line">        it-&gt;v += c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span>&#123;</span></span><br><span class="line">    ll len;</span><br><span class="line">    ll v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node2 a, Node2 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">k_query</span><span class="params">(ll l, ll r, ll k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node2&gt; q;</span><br><span class="line">    q.clear();</span><br><span class="line">    iter it_l = split(l);</span><br><span class="line">    iter it_r = split(r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(iter it = it_l; it != it_r; it++)</span><br><span class="line">        q.push_back((Node2)&#123;it-&gt;r - it-&gt;l + <span class="number">1</span>, it-&gt;v&#125;);</span><br><span class="line">    <span class="built_in">std</span>::sort(q.begin(), q.end(), cmp);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node2&gt;::iterator it = q.begin(); it != q.end(); it++)&#123;</span><br><span class="line">        sum += it-&gt;len;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= k)</span><br><span class="line">            <span class="keyword">return</span> it-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = rnd() % vmax + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        s.insert((Node)&#123;i, i, a[i]&#125;);</span><br><span class="line">    s.insert((Node)&#123;n + <span class="number">1</span>, n + <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        ll type = (rnd() % <span class="number">4</span>) + <span class="number">1</span>;</span><br><span class="line">        ll l = (rnd() % n) + <span class="number">1</span>;</span><br><span class="line">        ll r = (rnd() % n) + <span class="number">1</span>;</span><br><span class="line">        ll x, y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)</span><br><span class="line">            <span class="built_in">std</span>::swap(l, r);</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">3</span>)</span><br><span class="line">            x = (rnd() % (r - l + <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = (rnd() % vmax) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">4</span>)</span><br><span class="line">            y = (rnd() % vmax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</span><br><span class="line">            modify(l, r, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</span><br><span class="line">            assign(l, r, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, k_query(l, r, x));</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, query(l, r, x, y));</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>为什么感觉一大半代码都是随机数生成器的</del></p><h2 id="Ⅳ-可以使用珂朵莉树的其他题目"><a href="#Ⅳ-可以使用珂朵莉树的其他题目" class="headerlink" title="Ⅳ 可以使用珂朵莉树的其他题目"></a>Ⅳ 可以使用珂朵莉树的其他题目</h2><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><blockquote><p>给定一个仅包含小写字母的字符串。</p><p>资瓷区间排序</p><p>求$m$次排序之后的字符串。</p></blockquote><p>这题的正常做法是线段树维护一个桶，然后在排序的时候进行26次的查询与修改。</p><p>这样的话虽然理论复杂度是$O(n \log n)$的，但是带一个$26$的大常数，极易造成卡常。</p><p>如果使用珂朵莉树的话，我们可以用类似这种线段树的做法，查询每个字母出现的数量，再进行26次区间修改操作。</p><p>于是我们可以发现，一次排序之后，这一段区间最后只会被分成$26$个$set$中元素，规模完全可以接受。</p><p>实测在数据随机的情况下，珂朵莉树暴打$O(n \log * 26)$的标算。</p><p>（这是我们某次模拟赛的题目）</p><p>（结果标算T飞了，时限开到7s都拯救不了，而某位dalao同学<code>spfa</code>使用珂朵莉树A了，A了就算了，还快的飞起，于是该同学之后不久改名叫做<code>Chtholly_Tree</code>，并留下一句名言：）</p><blockquote><p>模拟赛使我相信珂学。</p></blockquote><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p><a href="https://codeforces.com/problemset/problem/915/E" target="_blank" rel="noopener">&gt;Here&lt;</a></p><blockquote><p>一个长度为$10^9$的0-1串，初始值全为$1$</p><p>资瓷区间修改为0或者为1</p><p>求每次修改之后$1$的个数。</p></blockquote><p>这道题目正统做法是动态开点线段树。</p><p>但是显然区间修改让我们往珂朵莉树方面去想</p><p>我们只需要让珂朵莉树资瓷$assign$还有区间求和就行了</p><h2 id="Ⅴ-总结-珂朵莉树的优缺点"><a href="#Ⅴ-总结-珂朵莉树的优缺点" class="headerlink" title="Ⅴ 总结-珂朵莉树的优缺点"></a>Ⅴ 总结-珂朵莉树的优缺点</h2><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>码量小</li><li>易于理解</li><li>能够资瓷大量操作</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>使用局限性较大</li><li>容易被卡</li></ul><p>珂朵莉树的功能极其强大，可以说只要可以暴力做的它都能做，但是只要没有区间复制操作，那么它比暴力还多只$\log$，而且只要出题人有这个心，完全可以把你卡满，但是它作为一种骗分技巧还是非常实用的，很重要的是它学起来很简单，而且大概$10min$（也许更短？）就可以敲完。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1096G Lucky Tickets</title>
      <link href="/2018/12/29/Solutions/Solution-CF1096G/"/>
      <url>/2018/12/29/Solutions/Solution-CF1096G/</url>
      
        <content type="html"><![CDATA[<p>其实我很想吐槽这题</p><p>我比赛的时候疯狂$\text{WA on test 16}​$</p><p>然后死活找不出来哪儿错了</p><p>我觉得我数组开小了</p><p>于是我开到$MLE$都没有过掉</p><p>最后一看</p><p>被一个<code>n = 2</code>的点卡掉了……</p><p>才出4题，罚时爆炸，上黄失败，掉分哭唧唧</p><a id="more"></a><p>首先我们看到题，我们可以想到一个朴素的$DP$方法：</p><p>我们用$f[i][j]$来表示在前$i$个里面取到和为$j$的方案数</p><p>然后我们可以列出$DP$方程，即$f[i][j] = \displaystyle\sum_{u = 1}^{k} f[i - 1][j - d[u]]$</p><p>那么显然，答案就是$\displaystyle \sum_{i = 1}^{n * 5}f[\frac{n}{2}][i] $</p><p><del>然而这个朴素的DP是$O(n^2)$的</del></p><p>我们考虑如何优化这个$DP$方程</p><p>我们想想看卷积的公式</p><p>$c[i] = \displaystyle \sum_{j = 0}^{i} a[j] * b[i - j]$</p><p>我们再试着改写一下原来的$DP$方程</p><p>我们令$g[u]$为$1$当且仅当$u \in d$，否则$g[u] = 0$</p><p>那么式子就可以改写成</p><p>$f[i][j] = \displaystyle\sum_{u = 1}^{j} f[i - 1][j - u] * g[u]$</p><p>我一看，这下子$f[i]$不就是$f[i - 1]$和$g$这两个多项式的卷积了吗</p><p>我们再考虑$f[0]$，显然$f[0] = \{1, 0, 0, 0… \}$</p><p>然后我们发现任何多项式乘上$f[0]$都等于它本身</p><p>于是我们发现最终的答案就是$g$这个多项式的$\frac{n}{2}$次幂</p><p>然后我们就可以愉快的用多项式快速幂解决这个问题了</p><p>注意多项式的长度要动态开，否则会T飞～</p><p>这里我用的是$NTT$，毕竟模数是$998244353$，取模比起$FFT$方便不少…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// o^r^z w^x^w</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            sum *= a;</span><br><span class="line">            sum %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        a %= mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">8000010</span>], num[<span class="number">8000010</span>];</span><br><span class="line"><span class="keyword">int</span> len, r[<span class="number">8000010</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8000010</span>], b[<span class="number">8000010</span>], c[<span class="number">8000010</span>];</span><br><span class="line"><span class="keyword">int</span> wn[<span class="number">8000010</span>];</span><br><span class="line"><span class="keyword">int</span> invlim;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(a, b) ((a) + (b) &gt;= mod ? (a) + (b) - mod : (a) + (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mine(a, b) ((a) &lt; (b) ? (a) - (b) + mod : (a) - (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(a, b) ((ll)(a) * (ll)(b) % mod)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; r[i])</span><br><span class="line">            <span class="built_in">std</span>::swap(a[i], a[r[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">wn[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        wn[<span class="number">1</span>] = powmod(G, (mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">            wn[j] = mul(wn[j - <span class="number">1</span>], wn[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += i &lt;&lt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> *L = a + j;</span><br><span class="line">            <span class="keyword">int</span> *R = L + i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> t = mul(wn[k], R[k]);</span><br><span class="line">R[k] = mine(L[k], t);</span><br><span class="line">                L[k] = add(L[k], t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">std</span>::reverse(a + <span class="number">1</span>, a + len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            a[i] = mul(a[i], invlim);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(len &lt;= n)</span><br><span class="line">        len &lt;&lt;= <span class="number">1</span>, lg++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (lg - <span class="number">1</span>));</span><br><span class="line">    invlim = powmod(len, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inp() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = inp();</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = inp();</span><br><span class="line">        g[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pownum = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(num, g, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    init(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">while</span>(pownum)&#123;</span><br><span class="line">        <span class="comment">// printf("%d\n", pownum);</span></span><br><span class="line">        <span class="keyword">if</span>(pownum &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxw = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5000000</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(g[i] &gt; <span class="number">0</span>)</span><br><span class="line">                    maxw = i;</span><br><span class="line">            init(maxw &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            ntt(g, <span class="number">1</span>);</span><br><span class="line">            ntt(num, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)</span><br><span class="line">                num[i] = mul(num[i], g[i]);</span><br><span class="line">            ntt(g, <span class="number">-1</span>);</span><br><span class="line">            ntt(num, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5000000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(g[i] &gt; <span class="number">0</span>)</span><br><span class="line">                maxw = i;</span><br><span class="line">        init(maxw &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        ntt(g, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)</span><br><span class="line">            g[i] = mul(g[i], g[i]);</span><br><span class="line">        ntt(g, <span class="number">-1</span>);</span><br><span class="line">        pownum &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)</span><br><span class="line">        ans = add(ans, mul(num[i], num[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 数论，数学 </tag>
            
            <tag> NTT </tag>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1095D Circular Dance</title>
      <link href="/2018/12/28/Solutions/Solution-CF1095D/"/>
      <url>/2018/12/28/Solutions/Solution-CF1095D/</url>
      
        <content type="html"><![CDATA[<p>我们令$fa[i]$为$i$直接连向的点</p><p>那么显然，$fa[i] \in \{a_{i, 1}, a_{i, 2}\}​$</p><p>假设$a_{i, 1}$为$fa[i]$，那么$a_{2, i} \in \{ a_{fa[i], 1}, a_{fa[i], 2} \}$</p><p>否则肯定有$a_{2, i} \not\in \{ a_{fa[i], 1}, a_{fa[i], 2} \}$</p><p>所以，如果有$a_{2, i} \in \{ a_{fa[i], 1}, a_{fa[i], 2} \}$，那么$fa[i] = a_{i, 1}$，否则$fa[i] = a_{i, 2}$</p><a id="more"></a><p>按照这个模拟即可</p><p>接下来送上代码</p><p>最后还有一点</p><p>在<code>n = 3</code>的时候上述方法是不适用的。</p><p>但是显然，<code>n = 3</code> 的时候随便输出一个环都能是答案</p><p>但是用这个方法可能构造出一个$n \leq 2$的环……</p><p>反正这个特判不加会$\color{red}\text{WA on test 13}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> a2[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">rel</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">// 判断b是否有 b ∈ &#123; a_&#123;a1&#125;, a_&#123;a2&#125; &#125;</span></span><br><span class="line">    <span class="keyword">return</span> (b == a1[a] || b == a2[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inp();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1 2 3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a1[i] = inp();</span><br><span class="line">        a2[i] = inp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rel(a1[i], a2[i]))</span><br><span class="line">            fa[i] = a1[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fa[i] = a2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(fa[cur] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, cur);</span><br><span class="line">        cur = fa[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P5003 跳舞的线-乱拐弯</title>
      <link href="/2018/11/21/Solutions/Solution-Luogu5003/"/>
      <url>/2018/11/21/Solutions/Solution-Luogu5003/</url>
      
        <content type="html"><![CDATA[<h2 id="一道有点套路化的网格图上-DP-QwQ"><a href="#一道有点套路化的网格图上-DP-QwQ" class="headerlink" title="一道有点套路化的网格图上$DP$QwQ"></a>一道有点套路化的网格图上$DP$QwQ</h2><p>我们用$f_{min}[i][j][0]$表示线头在$(i, j)$这个点的时候，线的方向朝<strong>下</strong>，我们能取到的最小的拐弯次数、用$f_{min}[i][j][1]$表示线头在$(i, j)$这个点的时候，显得方向朝<strong>右</strong>，能够取到的<strong>最小</strong>的拐弯次数</p><p>同理，我们用$f_{max}[i][j][0]$与$f_{max}[i][j][1]$表示线头在$(i, j)$位置是线朝下和朝右能够取到的<strong>最大</strong>的拐弯次数。</p><p>接下来，对于有障碍的点，我们直接不处理</p><p>显然，答案分别为$\max(f_{max}[n][m][0], f_{max}[n][m][1])$与$\min(f_{min}[n][m][0], f_{min}[n][m][1])$</p><a id="more"></a><p>接下来，我们就可以写出状态转移方程辣</p><p>$f_{min}[i][j][0] = \min(f_{min}[i - 1][j][0], f_{min}[i - 1][j][1] + 1)$<br>$f_{min}[i][j][1] = \min(f_{min}[i][j - 1][1], f_{min}[i][j - 1][0] + 1)$</p><p>$f_{max}[i][j][0] = \max(f_{max}[i - 1][j][0], f_{max}[i - 1][j][1] + 1)$<br>$f_{max}[i][j][1] = \max(f_{max}[i][j - 1][1], f_{max}[i][j - 1][0] + 1)$</p><p>注意初始化，$f_{min}$初始化为$\inf$，$f_{max}$初始化为-1，注意边界~~</p><p>上代码QwQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sooke bless me.</span></span><br><span class="line"><span class="comment">// LJC00118 bless me.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">int</span> Neg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">Neg = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">Sum = ((Sum &lt;&lt; <span class="number">3</span>) + (Sum &lt;&lt; <span class="number">1</span>)) + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Neg * Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f_max[<span class="number">1010</span>][<span class="number">1010</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> f_min[<span class="number">1010</span>][<span class="number">1010</span>][<span class="number">3</span>]; </span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = Inp();</span><br><span class="line"><span class="keyword">int</span> m = Inp();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">f_max[i][j][<span class="number">0</span>] = f_max[i][j][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">f_min[i][j][<span class="number">0</span>] = f_min[i][j][<span class="number">1</span>] = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][j] == <span class="string">'#'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>)&#123;</span><br><span class="line">f_max[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = f_max[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">f_min[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = f_min[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">f_min[i][j][<span class="number">0</span>] = <span class="built_in">std</span>::min(f_min[i - <span class="number">1</span>][j][<span class="number">0</span>], f_min[i - <span class="number">1</span>][j][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">f_min[i][j][<span class="number">1</span>] = <span class="built_in">std</span>::min(f_min[i][j - <span class="number">1</span>][<span class="number">1</span>], f_min[i][j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">f_max[i][j][<span class="number">0</span>] = <span class="built_in">std</span>::max(f_max[i - <span class="number">1</span>][j][<span class="number">0</span>], f_max[i - <span class="number">1</span>][j][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">f_max[i][j][<span class="number">1</span>] = <span class="built_in">std</span>::max(f_max[i][j - <span class="number">1</span>][<span class="number">1</span>], f_max[i][j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">std</span>::min(f_min[n][m][<span class="number">0</span>], f_min[n][m][<span class="number">1</span>]) == INF)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>, <span class="built_in">std</span>::max(f_max[n][m][<span class="number">0</span>], f_max[n][m][<span class="number">1</span>]) - <span class="number">1</span>, <span class="built_in">std</span>::min(f_min[n][m][<span class="number">0</span>], f_min[n][m][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1070H BerOS File Suggestion</title>
      <link href="/2018/11/19/Solutions/Solution-CF1070H/"/>
      <url>/2018/11/19/Solutions/Solution-CF1070H/</url>
      
        <content type="html"><![CDATA[<p>对于这题，看到字符串匹配，第一反应想到字符串hash，同时看到$len \leq 8 $ ，考虑对于先给出的$n$个字符串，$O(len^2)$枚举它的子串，将其加入$map$中，但是要注意如果一个然后对于每个字符串，我们都统计一下它最后一次出现在哪里（于是就可以顺便判一下重）</p><p>然后我们在询问的时候，就可以直接输出这个字符串对应的出现次数以及最后一处出现的位置啦QwQ</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sooke bless me.</span></span><br><span class="line"><span class="comment">// LJC00118 bless me.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">int</span> Neg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">Neg = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">Sum = ((Sum &lt;&lt; <span class="number">3</span>) + (Sum &lt;&lt; <span class="number">1</span>)) + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Neg * Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Cnt; <span class="comment">// 出现次数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Ans; <span class="comment">// 最后一次出现位置</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = Inp();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line"><span class="keyword">int</span> Len = s[i].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Len; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt;= Len - j; u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Ans[s[i].substr(u, j)] != i)&#123;</span><br><span class="line">Cnt[s[i].substr(u, j)]++;</span><br><span class="line">Ans[s[i].substr(u, j)] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = Inp();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, Cnt[str]);</span><br><span class="line"><span class="keyword">if</span>(Cnt[str] == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s[Ans[str]] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P3022 [USACO11OPEN]奇数度Odd degrees</title>
      <link href="/2018/11/18/Solutions/Solution-Luogu3022/"/>
      <url>/2018/11/18/Solutions/Solution-Luogu3022/</url>
      
        <content type="html"><![CDATA[<p>我感觉思路<a href="https://www.luogu.org/blog/deemoender-XFZaifish/solution-p3022" target="_blank" rel="noopener">隔壁题解</a>给的不够清楚啊……</p><p>感觉我无法直接理解<a href="https://www.luogu.org/blog/deemoender-XFZaifish/solution-p3022" target="_blank" rel="noopener">隔壁dalao的</a>“正经的图上神搜”啊……</p><p>那本蒟蒻就补充一下吧QwQ</p><a id="more"></a><p>这题的思路是这样的：</p><p>我们先不考虑断边，而是考虑连尽量多的边</p><p>继续考虑，对于每一个点，我们都考虑，对于它搜索过来的边（下文称其为“入边”），我们要不要连上，如果需要，那么我们的$Dfs()$函数返回值为$true$，否则为$true$</p><p>再考虑入边之外的其他点。对于深搜搜到每一个点的时候，我们都考虑与它相邻且未被搜索的点，如果对于这些点，需要连上“入边”，我们就把当前搜索的这个点的度加上1</p><p>在搜索完与它相邻的点之后，我们看一看这个点的度，如果它已经是奇数度的话，我们就不需要连上它的入边了（$return$ $false$），否则则需要连上入边，我们需要将当前这个点的入边加入答案，然后$return$ $true$</p><p>对于主函数，我们只需要将每个联通块都搜一遍即可QwQ，最后还有一点需要注意的，就是我们需要在搜索到每一个联通块的时候，如果发现一开始$Dfs$的返回值就是$true$了，但是！这个点没有入边，所以就无解辣QwQ</p><p>最后放上<del>与隔壁大佬超级像的</del>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sooke bless me.</span></span><br><span class="line"><span class="comment">// LJC00118 bless me.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">int</span> Neg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">Neg = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">Sum = ((Sum &lt;&lt; <span class="number">3</span>) + (Sum &lt;&lt; <span class="number">1</span>)) + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Neg * Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Head[<span class="number">50010</span>], Next[<span class="number">400010</span>], End[<span class="number">400010</span>];</span><br><span class="line"><span class="keyword">bool</span> Used[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">int</span> Ans[<span class="number">50010</span>], Index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Cou = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">Next[++Cou] = Head[a];</span><br><span class="line">Head[a] = Cou;</span><br><span class="line">End[Cou] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> Cur, <span class="keyword">int</span> Edge)</span></span>&#123;</span><br><span class="line">Used[Cur] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> Degree = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = Head[Cur]; x != <span class="number">-1</span>; x = Next[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(Used[End[x]])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(Dfs(End[x], x))</span><br><span class="line">Degree++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Degree % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">Ans[++Index] = (Edge + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(Head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Head)); </span><br><span class="line"><span class="keyword">int</span> n = Inp();</span><br><span class="line"><span class="keyword">int</span> m = Inp();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a = Inp();</span><br><span class="line"><span class="keyword">int</span> b = Inp();</span><br><span class="line">Link(a, b);</span><br><span class="line">Link(b, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!Used[i])</span><br><span class="line"><span class="keyword">if</span>(Dfs(i, <span class="number">-1</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::sort(Ans + <span class="number">1</span>, Ans + Index + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, Index);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Index; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%d"</span>, Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我来了，我出锅了，我走了——NOIp2018游记</title>
      <link href="/2018/11/18/Other/NOIp2018-Journey/"/>
      <url>/2018/11/18/Other/NOIp2018-Journey/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-（不想算）"><a href="#Day-（不想算）" class="headerlink" title="Day （不想算）"></a>Day （不想算）</h2><p>将RP耗尽在了初赛QwQ</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>教练说这天Openday，随便打游戏，于是上午随手把最大流、费用流、树剖三个听说可能会考的板子给敲了一遍于是就去跟同学颓了一天的LOL</p><a id="more"></a><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>来到学车中学，开考前随便跟同学奶了奶算法</p><p>照例解压，深吸一口气，打开题目。</p><p>看到T1，第一眼：卧槽这是什么玩意儿</p><p>第二眼：完了这是D1T1吗我要爆零了</p><p>第三眼（仔细一看）：这题好像有点眼熟？</p><p>第四眼：这不是我们模拟赛做过的某题的弱化版吗？</p><p>然而由于我太蒻了，我不会模拟赛的那道神仙题，于是找起了规律</p><p>我觉得可能跟差分有关系，于是就试着把数组的差分数据加起来，结果发现除了样例什么都过不了</p><p>于是我试着把最后一位加了上去，然后发现所有数据都大了一倍</p><p>于是我把答案除了个2，不管怎么证明，就去看T2了</p><p>看完题目，我开始大胆猜测：答案肯定是原先给出的集合的子集</p><p>然后xjb推了一番，采用显然法，得出一个数可以去掉当且仅当它可以被比他小的数表示出来</p><p>于是打了个好像是背包的奇怪DP，乱搞了一通，水过了大样例，就去看T3了</p><p>瞅了一眼T3，想到了一个$O(n^2)$的做法，结果正准备开始写的时候发现把题目重新看了一遍，卧槽，这路径不能重合的啊</p><p>之后，花了大概半个小时左右敲了$m = 1$的找直径和一条链的二分答案</p><p>估计得分 100 + 100 + 40 = 240 pts</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>保持心态，一路上只是奶奶算法而已</p><p>正当大家奶的正欢时，一道响亮的声音划过长空</p><p>杨英豪：“我奶今年T1动态仙人掌，T2树链剖分套主席树套珂朵莉树，T3动态DP！”</p><p>大家也只是笑笑，没当真</p><p>进考场</p><p>开考，照例解压，看T1</p><p>看了看，先花了10分钟把树的情况贪心敲完了</p><p>接下来开始想基环树</p><p>于是我画了一草稿纸的基环树</p><p>终于发现其实只要枚举断那条边其实就可以了</p><p>看T2,一看，n这么小，m这么大，理所当然想到对每一列进行状压，于是画了30min敲了一个状压</p><p>然后一看，卧槽，除了$n = 2$的数据啥都过不了</p><p>接下来头铁手玩杠了一波$n = m = 3$的样例，结果发现状压就是过不了的</p><p>（手玩 + 找状压错误原因花费40min）</p><p>结果发现在$n \geq 3$，会出现这种毒瘤情况：</p><p><img src="https://s1.ax1x.com/2018/11/18/izz9jH.png" alt></p><p>恩，我没办法解决，敲暴力……</p><p>这暴力还真是难敲……</p><p>敲完暴力，顺手打了几个表，离考试结束只有一个小时多一些了</p><p>然后开始写T3，一看</p><p>世界沉默了。。。</p><p>这TM不就是动态DP吗！！！</p><p>（心中开始疯狂诅咒杨英豪）</p><p>手速爆发写了个$O(n^2)$树状DP</p><p>瞪了一眼数据约定，写了个只有一个深度$\leq$ 300且其中一个询问为<code>1 1</code>的从询问点向根更新的$O(\texttt{深度})$算法，打文件，交卷。</p><p>估计得分 100 + 50 + 52 = 202 pts</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>开始讨论题目，发现</p><p>卧槽D1T2我的统计方案数是阶乘级的？会挂？</p><p>卧槽D1T3其实二分 + 树状DP其实就能过了？</p><p>卧槽D2T1我的复杂度会变成$O(n^2 \log n)$？</p><p>各种爆炸之后……</p><p>$luogu$估分 100 + 70 + 40 + 76 + 55 + 52 = 393 pts</p><p>作为一个初三党，第一次参加NOIp，感觉心态上还是出了点问题……</p><p><strong>明年再战吧</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dilute.zibi = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a>Day 11</h2><p>成绩出了……</p><p>$CCF$数据竟然有100 + 90 + 40 + 88 + 50 + 52 = 420 pts</p><p>这次$CCF$真的是用脚造的数据啊QwQ</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1077C Good Array</title>
      <link href="/2018/11/17/Solutions/Solution-CF1077C/"/>
      <url>/2018/11/17/Solutions/Solution-CF1077C/</url>
      
        <content type="html"><![CDATA[<p>显然，我们可以发现一个序列是“好的”当且仅当这个序列中的最大值等于这个序列中的其他数之和相加，所以我们只需要保证序列单调递减，同时维护一下这个序列里面元素之和我们就可以$O(1)$判断一个序列是不是“好的”序列（$a_1 = Sum - a_1$）</p><p>由于题目要求求出去掉哪些元素之后，这个序列会变为一个“好的”序列，所以我们只需要把原序列排序之后再按照刚刚说过的办法$O(1)$判断，只需要吧把原序列之中的$Sum$减去我们需要去掉的元素即可</p><p>还有一点需要注意，我们需要特判去掉第一个的情况，这样删去后最大值就是原先的次大数，即$a_2$</p><p>上代码QwQ</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sooke bless me.</span></span><br><span class="line"><span class="comment">// LJC00118 bless me.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">int</span> Neg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">Neg = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">Sum = ((Sum &lt;&lt; <span class="number">3</span>) + (Sum &lt;&lt; <span class="number">1</span>)) + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Neg * Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll x;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">&#125;s[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ans[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = Inp();</span><br><span class="line">ll Sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">s[i].x = Inp();</span><br><span class="line">Sum += s[i].x;</span><br><span class="line">s[i].k = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::sort(s + <span class="number">1</span>, s + n + <span class="number">1</span>, Cmp);</span><br><span class="line"><span class="keyword">int</span> Cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(Sum - s[<span class="number">1</span>].x - s[<span class="number">2</span>].x == s[<span class="number">2</span>].x) <span class="comment">// 特判去掉1的情况</span></span><br><span class="line">Ans[++Cnt] = s[<span class="number">1</span>].k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Sum - s[<span class="number">1</span>].x - s[i].x == s[<span class="number">1</span>].x)</span><br><span class="line">Ans[++Cnt] = s[i].k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Cnt; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1068B LCM</title>
      <link href="/2018/11/17/Solutions/Solution-CF1068B/"/>
      <url>/2018/11/17/Solutions/Solution-CF1068B/</url>
      
        <content type="html"><![CDATA[<p><del>第一篇题解</del></p><p>我们都知道$lcm(a, b) = \frac{a * b}{\gcd(a, b)}$</p><p>∴ $\frac{lcm(a, b)}{a} = \frac{\frac{a * b}{\gcd(a, b)}}{a} = \frac{b}{\gcd(a, b)}$</p><p>题目的意思就被我们转化成了求$\frac{b}{\gcd(a, b)}$的种类数</p><p>又∵b是一个确定的数</p><p>∴$\frac{b}{\gcd(a, b)}$的种类数就等于$\gcd(a, b)$的种类数</p><p>由于$a$的范围在$[1, 10^{18}]$范围内，所以$\gcd(a, b)$的种类数就等于b的因数个数。</p><p>因数个数就可以$O(\sqrt n)$求辣QwQ</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sooke bless me.</span></span><br><span class="line"><span class="comment">// LJC00118 bless me.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Inp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line">ll Neg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">Neg = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line">ll Sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">Sum = ((Sum &lt;&lt; <span class="number">3</span>) + (Sum &lt;&lt; <span class="number">1</span>)) + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Neg * Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll n = Inp();</span><br><span class="line">ll qn = <span class="built_in">sqrt</span>(n);</span><br><span class="line">ll Ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= qn; i++)&#123;</span><br><span class="line">ll Cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">n /= i;</span><br><span class="line">Cnt++;</span><br><span class="line">&#125;</span><br><span class="line">Ans *= Cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">Ans *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论，数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P2547 [AHOI2004]DNA变异</title>
      <link href="/2018/10/24/Solutions/Solution-Luogu2547/"/>
      <url>/2018/10/24/Solutions/Solution-Luogu2547/</url>
      
        <content type="html"><![CDATA[<p>首先我作为一个蒟蒻，拿到字符串题，首先看看能不能无脑哈希</p><p>然后于是我们就发现了一个绝妙的做法：暴力枚举每个字符串能够转换成的字符串</p><p>于是我们就获得了$O(N * 8^4)$的优秀复杂度</p><p>显然会T飞QwQ</p><p>我们考虑再这个基础上进行优化</p><a id="more"></a><p>我们会发现如果我们$O(8^4)$枚举的话，其中有一大部分枚举出来的状态都是重复的</p><p>那么我们思考：这其中有多少个状态是有用的呢</p><p>首先我们假设我们将$s_a, s_b$交换，$s_c, s_d$互换（$a,b,c,d\in [1, 8] $, $a \neq b \neq c \neq d$）同时我们令$a &lt; b $ 且 $c &lt; d$</p><p>那么我们会发现最终只有$C_8^4 * 3$种可能是可行的</p><p>所以我们只需要把这些预处理出来，那么我们在后面枚举的时候只需要在这些状态中取就行了</p><p>最终复杂度$O(N <em> C_8^4 </em> 3 * 8)$，（最后的8是Hash的复杂度）佐以优秀的常数便可AC此题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sooke bless me.</span></span><br><span class="line"><span class="comment">// LJC00118 bless me.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> Neg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">Neg = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">Sum = ((Sum &lt;&lt; <span class="number">3</span>) + (Sum &lt;&lt; <span class="number">1</span>)) + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Neg * Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">bool</span> Used[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> cg[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">Sum &lt;&lt;= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>:&#123;</span><br><span class="line">Sum += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>:&#123;</span><br><span class="line">Sum += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>:&#123;</span><br><span class="line">Sum += <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Hsh[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> sa[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> sb[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> C_swap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> n = Inp();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i], Hsh[i] = Hash(s[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt; <span class="number">8</span>; j1++)&#123;</span><br><span class="line">Used[j1] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j2 = j1 + <span class="number">1</span>; j2 &lt; <span class="number">8</span>; j2++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Used[j2])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">Used[j2] = <span class="literal">true</span>;</span><br><span class="line">sa[++C_swap] = j1;</span><br><span class="line">sb[C_swap] = j2;</span><br><span class="line">Used[j2] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">Used[j1] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> Ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C_swap; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = j + <span class="number">1</span>; u &lt;= C_swap; u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sa[j] == sa[u] || sb[j] == sb[u] || sa[j] == sb[u] || sb[j] == sa[u])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s[i];</span><br><span class="line">swap(s2[sa[j]], s2[sb[j]]);</span><br><span class="line">swap(s2[sa[u]], s2[sb[u]]);</span><br><span class="line">cg[Hash(s2)] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line"><span class="keyword">if</span>(cg[Hsh[j]])</span><br><span class="line">Ans++, cg[Hsh[j]] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记-最小费用最大流</title>
      <link href="/2018/10/01/Notes/min-cost-max-flow/"/>
      <url>/2018/10/01/Notes/min-cost-max-flow/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>某天我看到了memset0巨佬怒切17道网络流神仙题的时候，我顿时准备去做做看网络流24题<del>以满足我内心的抖M之魂</del></p><p>于是，我这个蒟蒻看到某道<a href="https://www.luogu.org/problemnew/show/P4012" target="_blank" rel="noopener">费用流神题</a>的时候，一脸懵逼地看着“费用流”的标签，决心去学一学这玩意</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>最小费用最大流（费用流）是在最大流的基础上，要求我们取到的总共需要的费用最小化。</p><p>同时每个边所消耗的费用都是与它这条边的流量成正比的</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们看一看增广路做最大流的做法（以Dinic为例）</p><p>首先，我们通过BFS确定是否拥有一条从源点流向汇点的增广路径，如果存在，说明当前搜到的不是最优解，继续进行，如果没有，退出程序</p><p>然后，如果我们要保证这条路径需要的费用最小化（将BFS改为SPFA，将DFS改为记录路径），便可以保证在我们搜到最优解的时候保证我们在保证流量最大的同时保证费用最小</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>$tan90^{O}$</p><p>这种一个“感性理解”解决的东西需要严格证明吗？</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sooke bless me.</span></span><br><span class="line"><span class="comment">// LJC00118 bless me.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">int</span> Neg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">            Neg = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        Sum = ((Sum &lt;&lt; <span class="number">3</span>) + (Sum &lt;&lt; <span class="number">1</span>)) + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Neg * Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Head[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> End[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> Value[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> Cost[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> Dis[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> Prev1[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> Prev2[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">bool</span> Inq[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> Cou = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    Next[++Cou] = Head[a];</span><br><span class="line">    Head[a] = Cou;</span><br><span class="line">    End[Cou] = b;</span><br><span class="line">    Value[Cou] = v;</span><br><span class="line">    Cost[Cou] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Head));</span><br><span class="line">    <span class="keyword">int</span> n = Inp();</span><br><span class="line">    <span class="keyword">int</span> m = Inp();</span><br><span class="line">    <span class="keyword">int</span> s = Inp();</span><br><span class="line">    <span class="keyword">int</span> e = Inp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = Inp();</span><br><span class="line">        <span class="keyword">int</span> b = Inp();</span><br><span class="line">        <span class="keyword">int</span> v1 = Inp();</span><br><span class="line">        <span class="keyword">int</span> v2 = Inp();</span><br><span class="line">        Link(a, b, v1, v2);</span><br><span class="line">        Link(b, a, <span class="number">0</span>, -v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f = INF;</span><br><span class="line">    <span class="keyword">while</span>(f &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(Inq, <span class="literal">false</span>, <span class="keyword">sizeof</span>(Inq));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            Dis[i] = INF;</span><br><span class="line">        Dis[s] = <span class="number">0</span>;</span><br><span class="line">        q[<span class="number">5000</span>] = s;</span><br><span class="line">        <span class="keyword">int</span> qf = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">int</span> qe = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(qf &lt;= qe)&#123; <span class="comment">// SPFA（因为会有负权所以用SPFA）</span></span><br><span class="line">            <span class="keyword">int</span> u = q[qf++];</span><br><span class="line">            Inq[u] = <span class="literal">false</span>;</span><br><span class="line">            Sum -= Dis[u];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = Head[u]; x != <span class="number">-1</span>; x = Next[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(Value[x] &gt; <span class="number">0</span> &amp;&amp; Dis[End[x]] &gt; Dis[u] + Cost[x])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Inq[End[x]])</span><br><span class="line">                        Sum -= Dis[End[x]];</span><br><span class="line">                    Dis[End[x]] = Dis[u] + Cost[x];</span><br><span class="line">                    Prev1[End[x]] = u;</span><br><span class="line">                    Prev2[End[x]] = x;</span><br><span class="line">                    Sum += Dis[End[x]];</span><br><span class="line">                    <span class="keyword">if</span>(!Inq[End[x]])&#123;</span><br><span class="line">                    q[++qe] = End[x];</span><br><span class="line">                        Inq[End[x]] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Dis[e] == INF)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> Delta = f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = e; i != s; i = Prev1[i])</span><br><span class="line">            Delta = min(Delta, Value[Prev2[i]]);</span><br><span class="line">        f -= Delta;</span><br><span class="line">        Flow += Delta;</span><br><span class="line">        Ans += Delta * Dis[e];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = e; i != s; i = Prev1[i])&#123;</span><br><span class="line">            Value[Prev2[i]] -= Delta;</span><br><span class="line">            Value[Prev2[i] ^ <span class="number">1</span>] += Delta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, Flow, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记-单调队列</title>
      <link href="/2018/09/27/Notes/dandiao-queue/"/>
      <url>/2018/09/27/Notes/dandiao-queue/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单调队列一种非常经典的将O(n^2)的DP优化的O(n log n)的方式，在一个点可以更新一个范围的时候可以发挥很大作用。</p><p>记得当年NOIp2017我考PJ（那年的T4考到了单调队列），当时还不会，在考后听教练讲了一遍之后仍旧处于懵逼状态，大概1个月前照着题解打了一遍，但是到了现在已经忘得差不多了QwQ，于是写了一遍优化过的多重背包来练练手。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>普及考完之后，我问Sooke大仙（如果T4开了longlong他就AK了）T4的做法，他跟我说：单调队列</p><p>我：（懵逼）单调队列是个啥子玩意儿</p><p>Sooke：</p><blockquote><p>单调队列是一个队列，它具有单调性</p></blockquote><p>是不是还是听不懂？那么我解释一下。</p><p>单调队列是一个队列（这不是废话吗QwQ），它里面的元素满足一个性质：</p><p>对于$i&lt;j$，一定满足$v_i &lt; v_j$ 并且 $k_i &lt; k_j$（v为一个点的DP值， k为点在DP数组中的位置）</p><p>这就是单调队列（你问它跟DP有设么关系？看下面的吧QwQ）</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>对于一个单调队列，你会发现如果一个要队中状态无法更关心当前扫到的这个状态，那么它也无法更新后面扫到的状态，（这个很容易证明）那么我们可以把这个状态丢掉，在通过这是最优的状态（队首元素）更新当前状态之后，将当前的状态加入队列然后继续往下扫</p><p>综上所述，一个比较精简的单调队列程序的核心部分就应该长成这样(伪代码)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(当前状态无用)</span><br><span class="line">        qf++;</span><br><span class="line">    <span class="keyword">while</span>(如果加入当前状态会使队列不满足单调性)</span><br><span class="line">    qe--;</span><br><span class="line">    q[++qe] = 当前状态;</span><br><span class="line">    <span class="keyword">if</span>(q[qf] 更优于 f[i])</span><br><span class="line">更新f[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.org/problemnew/show/P3957" target="_blank" rel="noopener">洛谷P3957 NOIP2017普及组T4 跳房子</a></p><p>我们看到这题之后，我们马上可以想到二分答案，在二分答案的Check()中可以加上一个DP</p><p>这题显然对于一个机器人的状态，它可以更新一个范围，所以大力套上单调队列即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> di[<span class="number">500100</span>];</span><br><span class="line"><span class="keyword">int</span> xi[<span class="number">500100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">500100</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">1000100</span>];</span><br><span class="line"><span class="keyword">int</span> qf, qe;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(f[q[qe]] &lt;= f[x] &amp;&amp; qe &gt;= qf)</span><br><span class="line">qe--;</span><br><span class="line">q[++qe] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> Min, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">f[i] = <span class="number">-1000000000000000000</span>;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">qf = <span class="number">1</span>;</span><br><span class="line">qe = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> kk = <span class="number">0</span>;</span><br><span class="line">q[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(di[i] - di[kk] &gt;= Min &amp;&amp; kk &lt; i)</span><br><span class="line">Push(kk++);</span><br><span class="line"><span class="keyword">while</span>(di[i] - di[q[qf]] &gt; Max &amp;&amp; qf &lt;= qe)</span><br><span class="line">qf++; <span class="comment">// 把不符合区间的给出队</span></span><br><span class="line"><span class="keyword">if</span>(qf &gt; qe || f[q[qf]] == <span class="number">-1000000000000000000</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">f[i] = f[q[qf]] + xi[i];</span><br><span class="line"><span class="keyword">if</span>(f[i] &gt;= k)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fopen</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"jump.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"jump.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//fopen();</span></span><br><span class="line"><span class="comment">//freopen("jump10.in", "r", stdin);</span></span><br><span class="line">di[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %lld"</span>, &amp;n, &amp;d, &amp;k);</span><br><span class="line"><span class="keyword">int</span> maxd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sumx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;di[i], &amp;xi[i]);</span><br><span class="line"><span class="keyword">if</span>(xi[i] &gt; <span class="number">0</span>)</span><br><span class="line">sumx += xi[i];</span><br><span class="line"><span class="keyword">if</span>(di[i] &gt; maxd)</span><br><span class="line">maxd = di[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sumx &lt; k)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = maxd;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(check((d - mid &gt; <span class="number">1</span> ? d - mid : <span class="number">1</span>), d+mid))</span><br><span class="line">r = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭十三中冠军联赛S1 Extra Round 题解</title>
      <link href="/2018/09/26/Solutions/Solution-S1ExtraRound/"/>
      <url>/2018/09/26/Solutions/Solution-S1ExtraRound/</url>
      
        <content type="html"><![CDATA[<h3 id="texttt-Writer：世界最蒻Dilute"><a href="#texttt-Writer：世界最蒻Dilute" class="headerlink" title="\texttt{ Writer：世界最蒻Dilute}"></a><script type="math/tex">\texttt{ Writer：世界最蒻Dilute}</script></h3><h2 id="texttt-A-某脱碳甲醛的电磁炮题"><a href="#texttt-A-某脱碳甲醛的电磁炮题" class="headerlink" title="\texttt{ \#A 某脱碳甲醛的电磁炮题}"></a><script type="math/tex">\texttt{ \#A 某脱碳甲醛的电磁炮题}</script></h2><script type="math/tex; mode=display">\texttt{ 出题人 Dilute}​</script><p>电流公式$I=\frac{U}{R}$大家都知道（不知道的话在题面中也给出了）</p><p>所以直接输出就可以了（ps：C++中除法自动向下取整）</p><a id="more"></a><p><em>std by Dilute</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> U, R;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;U, &amp;R);</span><br><span class="line">    <span class="keyword">int</span> Ans = U / R;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="texttt-B-黑子的瞬移范围"><a href="#texttt-B-黑子的瞬移范围" class="headerlink" title="\texttt{ \#B 黑子的瞬移范围}"></a><script type="math/tex">\texttt{ \#B 黑子的瞬移范围}</script></h2><script type="math/tex; mode=display">\texttt{ 出题人 SLYZ\_0120}​</script><p>跟上一题差不多，但是坑点有二：</p><ul><li><p>1.此题给定的是直径d而非半径r</p></li><li><p>2.保留3位输出需使用printf的%.3lf（具体看std）</p></li></ul><p><em>std by SLYZ_0120</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="keyword">double</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf"</span>,d*d*<span class="number">3.1415926</span>/<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="texttt-C-末日的时候有空吗？在干什么？可以来AK吗？"><a href="#texttt-C-末日的时候有空吗？在干什么？可以来AK吗？" class="headerlink" title="\texttt{ \#C 末日的时候有空吗？在干什么？可以来AK吗？}"></a><script type="math/tex">\texttt{ \#C 末日的时候有空吗？在干什么？可以来AK吗？}</script></h2><script type="math/tex; mode=display">\texttt{ 出题人 Dilute}​</script><blockquote><p>这可能是整场比赛代码最长的题？QwQ</p></blockquote><p>由题目我们经过一番思考我们会想出来一个策略：先从较弱（即消耗法力值较小）的“兽”开始打，打倒无法再打下去为止</p><p>由此我们可以对表示$w_i$的序列排序再从前往后做即可</p><p><em>std by Dilute</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">sort(w+<span class="number">1</span>, w+n+<span class="number">1</span>); <span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">m -= w[i]; <span class="comment">// 消耗掉该“兽”所需要的法力值</span></span><br><span class="line"><span class="keyword">if</span>(m &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, i - <span class="number">1</span>); <span class="comment">// 如果法力值耗尽，那么应该在第i - 1只“兽”就停止</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, n); <span class="comment">// 如果一直到最后都没有耗尽法力，那么久表示可以将所有“兽”杀死</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>我珂美如画！</code></p><h2 id="texttt-D-打怪升级"><a href="#texttt-D-打怪升级" class="headerlink" title="\texttt{ \#D 打怪升级}"></a><script type="math/tex">\texttt{ \#D 打怪升级}</script></h2><script type="math/tex; mode=display">\texttt{ 出题人 SLYZ\_0120}</script><p>我们直接按照题意，模拟桐人和亚丝娜打怪升级的过程</p><p>教大家一个指令 $pow(a, b)$可以表示$a^b$即$a$的$b$次方</p><p><em>std by SLYZ_0120</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans += <span class="built_in">pow</span>(<span class="number">2</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="texttt-E-结构体排序"><a href="#texttt-E-结构体排序" class="headerlink" title="\texttt{ \#E 结构体排序}"></a><script type="math/tex">\texttt{ \#E 结构体排序}</script></h2><script type="math/tex; mode=display">\texttt{ 出题人 bh1234666}​</script><h4 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h4><p>我们进行多次排序，首先以$a$为关键字，排序完成之后对于a相等的几个进行第二次排序，最后输出即可</p><p><em>std by bh1234666</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">paixu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">&#125;a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(paixu x,paixu y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp2</span><span class="params">(paixu x,paixu y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].a,&amp;a[i].b);</span><br><span class="line">    sort(a,a+n,cmp1);</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i].a!=a[flag].a)</span><br><span class="line">        &#123;</span><br><span class="line">            sort(a+flag,a+i,cmp2);</span><br><span class="line">            flag=i;</span><br><span class="line">        &#125;</span><br><span class="line">    sort(a+flag,a+i,cmp2);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a[i].a,a[i].b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h4><p>其实只用一次排序就行了QwQ（只要在Cmp加入$a$相等的情况即可）</p><p><em>std by Dilute</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;Num[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.a == b.a)</span><br><span class="line"><span class="keyword">return</span> a.b &lt; b.b;</span><br><span class="line"><span class="keyword">return</span> a.a &lt; b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;Num[i].a, &amp;Num[i].b);</span><br><span class="line">sort(Num + <span class="number">1</span>, Num + n + <span class="number">1</span>, Cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Num[i].a, Num[i].b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="texttt-F-诡异的字符"><a href="#texttt-F-诡异的字符" class="headerlink" title="\texttt{ \#F 诡异的字符}"></a><script type="math/tex">\texttt{ \#F 诡异的字符}</script></h2><script type="math/tex; mode=display">\texttt{ 出题人 bh1234666}</script><p>这题非常不常规……（但是并不能改变这是道大水题的事实QwQ）</p><p>这题要求输出的字符串中有两个问题：</p><ul><li><p>1.反斜杠<code>\</code>这个字符在C++中是转义符，如果单单一个<code>\</code>在字符串中会将后面的字符转义，从而导致我们不想要的效果，所以我们需要打两个<code>\</code>让<code>\</code>将自己转义（反斜杠转义后便是一个正常的字符）便可</p></li><li><p>2.双引号<code>&quot;</code>，如果你打在引号中的话程序会认为你这个引号是一个字符串的结尾从而导致问题，我们只要手动在定义字符串后将应该是<code>&quot;</code>的那个字符用ASCII码调整成双引号即可</p></li></ul><p><em>std by bh1234666</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> a[]=<span class="string">"!@#$%^&amp;*()[]&#123;&#125;;:' \\|,&lt;.&gt;/?`~-_=+`~"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[<span class="number">17</span>]=<span class="number">34</span>; <span class="comment">// 双引号的ASC码为34</span></span><br><span class="line">    <span class="comment">// 上面那行中的34等价于'"'</span></span><br><span class="line">    <span class="built_in">puts</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="texttt-G-身份证号"><a href="#texttt-G-身份证号" class="headerlink" title="\texttt{ \#G 身份证号}"></a><script type="math/tex">\texttt{ \#G 身份证号}</script></h2><script type="math/tex; mode=display">\texttt{ 出题人 bh1234666}​</script><p>不难得出字符串7~10位为年份，11~12位为月份，13~14位为日期，那么把前面六位读进垃圾桶，再读进四位，输出刚刚读进的四位，输出空格，读进两位，输出刚刚读进的两位，再空格，最后读进两位，输出两位就行了</p><p><em>std by bh1234666</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%*c%*c%*c%*c%*c%*c%c"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本场比赛的出题人们</p><blockquote><p><a href="https://www.luogu.org/space/show?uid=36362" target="_blank" rel="noopener">Dilute</a> 卢景行<br><a href="https://www.luogu.org/space/show?uid=36363" target="_blank" rel="noopener">SLYZ_0120</a> 杨茗<br><a href="https://www.luogu.org/space/show?uid=48978" target="_blank" rel="noopener">bh1234666</a> 包涵</p></blockquote></blockquote><p>最后，我想说</p><h1 id="哦景真老师你真是太帅了！"><a href="#哦景真老师你真是太帅了！" class="headerlink" title="哦景真老师你真是太帅了！"></a>哦景真老师你真是太帅了！</h1><h1 id="哦景真老师你真是太帅了！-1"><a href="#哦景真老师你真是太帅了！-1" class="headerlink" title="哦景真老师你真是太帅了！"></a>哦景真老师你真是太帅了！</h1><h1 id="哦景真老师你真是太帅了！-2"><a href="#哦景真老师你真是太帅了！-2" class="headerlink" title="哦景真老师你真是太帅了！"></a>哦景真老师你真是太帅了！</h1><h1 id="QwQ"><a href="#QwQ" class="headerlink" title="QwQ"></a>QwQ</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P4819 [中山市选]杀人游戏</title>
      <link href="/2018/08/29/Solutions/Solution-Luogu4819/"/>
      <url>/2018/08/29/Solutions/Solution-Luogu4819/</url>
      
        <content type="html"><![CDATA[<p>首先我们考虑一件事：如果存在一个人，使任何一个人都不认识，我们称这种人为“孤独”的人，那么警察只能通过调查他来取得他的身份。</p><p>然后对于一个不“孤独”的人，我们发现他们肯定至少被一个那些“孤独”的人直接或间接的认识。</p><p>所以我们得出结论：只要统计“孤独”的人的数量即可。</p><hr><p>你照着这么做，就可以获得<code>100 mod 10分</code>的好成绩。</p><a id="more"></a><p>那么为什么这不对呢？假设a认识b，就相当于在一个图中从a点向b点连一条边，这样就会造成一个问题：在这张图中会出现环</p><p>于是一旦出现环，我们就会发现只要调查环中的一个人，就可以知道环中所有人的身份，但是有可能环中每一个人都不被“孤独”的人间接认识，那么这样，我们可以使用Tarjan缩点，将一个环缩成一个点再进行一开始的算法。</p><hr><p>你照着这么做，就可以获得<code>21分</code>的好成绩</p><hr><p>那么这次问题又出在哪儿了呢？</p><p>我们考虑以下情况</p><p>输入数据：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">100 </span><span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>如果按照我们原来的思路，那么我们的程序会输出0，但是实际上可能会怎样呢？</p><blockquote><p>警察来到了一个神奇的地方，这里的人们“鸡犬相闻，而民老死不相往来”（大雾），说白了就是谁都不认识</p><p>警察调查了前99个人，发现这99个人里面谁都不是杀手。</p><p>正在警察准备调查第100个人时，突然发现只剩一个人了，<strong>但是前99个人都不是杀手，所以最后一个人肯定是杀手，不用去调查了</strong></p></blockquote><p>我们瞎算一通，发现出现这种情况的概率是1%，所以我们原来的程序错了！</p><p>那怎么办呢？</p><p>对于一个入度为0的点，如果它在缩点前是一个点而不是一个环，并且<strong>与它相连的点入度都不为1（也就是说不调查这个人不会影响其他人的身份是否明了）</strong>，那么这个点就可以不调查，但是<strong>只允许不调查1个这样的点</strong>（原因前面已经讲过了）</p><hr><p>你照着这么做，就可以A了。</p><p>接下来上代码QAQ</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 2000010</span></span><br><span class="line"><span class="keyword">int</span> Dfn[MAXN];</span><br><span class="line"><span class="keyword">int</span> Low[MAXN];</span><br><span class="line"><span class="keyword">int</span> Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> Top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Point[MAXN];</span><br><span class="line"><span class="keyword">bool</span> Ins[MAXN];</span><br><span class="line"><span class="keyword">int</span> Index;</span><br><span class="line"><span class="keyword">int</span> Head[MAXN];</span><br><span class="line"><span class="keyword">int</span> End[MAXM];</span><br><span class="line"><span class="keyword">int</span> Next[MAXM];</span><br><span class="line"><span class="keyword">int</span> Head2[MAXN];</span><br><span class="line"><span class="keyword">int</span> End2[MAXM];</span><br><span class="line"><span class="keyword">int</span> Next2[MAXM];</span><br><span class="line"><span class="keyword">bool</span> Used[MAXN];</span><br><span class="line"><span class="keyword">int</span> Dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> Degree[MAXN];</span><br><span class="line"><span class="keyword">int</span> Cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Cou_p[MAXN]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> Cur)</span></span>&#123; <span class="comment">// 以烈焰净化一切的环！（大雾） </span></span><br><span class="line">Dfn[Cur] = Low[Cur] = ++Index;</span><br><span class="line">Ins[Cur] = <span class="literal">true</span>;</span><br><span class="line">Stack[++Top] = Cur; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = Head[Cur]; x != <span class="number">-1</span>; x = Next[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(Dfn[End[x]] == <span class="number">-1</span>)&#123;</span><br><span class="line">Tarjan(End[x]);</span><br><span class="line"><span class="keyword">if</span>(Low[End[x]] &lt; Low[Cur])</span><br><span class="line">Low[Cur] = Low[End[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Ins[End[x]] &amp;&amp; Dfn[End[x]] &lt; Low[Cur])</span><br><span class="line">Low[Cur] = Dfn[End[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Dfn[Cur] == Low[Cur])&#123;</span><br><span class="line">Cnt++;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">Cou_p[Cnt]++;</span><br><span class="line">Point[Stack[Top]] = Cnt;</span><br><span class="line">Ins[Stack[Top]] = <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(Stack[Top--] != Cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Cou = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">// 连边 </span></span><br><span class="line">Next[++Cou] = Head[a];</span><br><span class="line">Head[a] = Cou;</span><br><span class="line">End[Cou] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Cou2 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Relink</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">// 重连边 </span></span><br><span class="line">Next2[++Cou2] = Head2[a];</span><br><span class="line">Head2[a] = Cou2;</span><br><span class="line">End2[Cou2] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Single</span><span class="params">(<span class="keyword">int</span> xx)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = Head2[xx]; x != <span class="number">-1</span>; x = Next2[x])</span><br><span class="line"><span class="keyword">if</span>(Degree[End2[x]] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(Head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Head));</span><br><span class="line"><span class="built_in">memset</span>(Head2, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Head2));</span><br><span class="line"><span class="built_in">memset</span>(Dfn, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Dfn));</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">Link(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(Dfn[i] == <span class="number">-1</span>)</span><br><span class="line">Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 重建图 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = Head[i]; x != <span class="number">-1</span>; x = Next[x])</span><br><span class="line"><span class="keyword">if</span>(Point[i] != Point[End[x]])&#123;</span><br><span class="line">Relink(Point[i], Point[End[x]]);</span><br><span class="line">Degree[Point[End[x]]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> Have_one = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Cnt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!Have_one &amp;&amp; Cou_p[i] == <span class="number">1</span> &amp;&amp; Degree[i] == <span class="number">0</span> &amp;&amp; Single(i)) <span class="comment">// 是否可以使用“排除法” </span></span><br><span class="line">Have_one = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(Degree[i] == <span class="number">0</span>)</span><br><span class="line">Ans++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Have_one) Ans--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6lf"</span>, <span class="number">1.0</span> - (<span class="keyword">double</span>)Ans / (<span class="keyword">double</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tarjan </tag>
            
            <tag> 缩点 </tag>
            
            <tag> 拓扑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF702E Analysis of Pathes in Functional Graph</title>
      <link href="/2018/08/21/Solutions/Solution-CF702E/"/>
      <url>/2018/08/21/Solutions/Solution-CF702E/</url>
      
        <content type="html"><![CDATA[<h2 id="一道非常好的练倍增的题目"><a href="#一道非常好的练倍增的题目" class="headerlink" title="一道非常好的练倍增的题目"></a>一道非常好的练倍增的题目</h2><p>思路很简单，就是倍增处理出每个点往后$2^i$个点的路径权值和与最小值，同时要注意一下$k​$要用<code>longlong</code>存，否则会挂掉</p><p>如果不会倍增的右转百度找其他博客去吧……我这里就不赘述了</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Son[<span class="number">100010</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans[<span class="number">100010</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> Min[<span class="number">100010</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Solve1</span><span class="params">(<span class="keyword">int</span> Cur, <span class="keyword">long</span> <span class="keyword">long</span> k)</span></span>&#123; <span class="comment">// 求出Cur向后k条路径的权值和</span></span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> xx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">1</span>; <span class="comment">// 由于2 ^ xx 会爆int，所以应当开一个变量专门存</span></span><br><span class="line"><span class="keyword">while</span>(x &lt;= k)</span><br><span class="line">xx++, x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">xx--;</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> Ans[Cur][xx] + Solve1(Son[Cur][xx], k - x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve2</span><span class="params">(<span class="keyword">int</span> Cur, <span class="keyword">long</span> <span class="keyword">long</span> k)</span></span>&#123; <span class="comment">// 求出Cur向后k条路径的权值最小值</span></span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">int</span> xx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">1</span>; <span class="comment">// 与上面同理</span></span><br><span class="line"><span class="keyword">while</span>(x &lt;= k)</span><br><span class="line">xx++, x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">xx--;</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> min(Min[Cur][xx], Solve2(Son[Cur][xx], k - x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %I64d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Son[i][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;Ans[i][<span class="number">0</span>]), Min[i][<span class="number">0</span>] = Ans[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">40</span>; t++) <span class="comment">// 预处理出第2^i辈儿子</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">Son[i][t] = Son[Son[i][t<span class="number">-1</span>]][t<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">40</span>; t++) <span class="comment">// 预处理往后$2^i$个点的路径权值之和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">Ans[i][t] = Ans[i][t<span class="number">-1</span>] + Ans[Son[i][t<span class="number">-1</span>]][t<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">40</span>; t++) <span class="comment">// 预处理往后$2^i$个点的路径权值最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">Min[i][t] = min(Min[i][t<span class="number">-1</span>], Min[Son[i][t<span class="number">-1</span>]][t<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d %d\n"</span>, Solve1(i, k), Solve2(i, k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P3045 [USACO12FEB]牛券Cow Coupons</title>
      <link href="/2018/08/03/Solutions/Solution-Luogu3045/"/>
      <url>/2018/08/03/Solutions/Solution-Luogu3045/</url>
      
        <content type="html"><![CDATA[<h2 id="欧洲退火！"><a href="#欧洲退火！" class="headerlink" title="欧洲退火！"></a>欧洲退火！</h2><p>没错你没有看错这么一道Heap的题我拿出了退火来做！</p><p>那么模拟退火的基本思路这里不讲了如果要看右转<a href="https://www.luogu.org/problemnew/show/P1337" target="_blank" rel="noopener">P1337</a>去看。</p><p>废话不多说，上思路</p><a id="more"></a><p>这个思路有些类似<a href="https://www.luogu.org/problemnew/show/P1337" target="_blank" rel="noopener">P2503</a>的思路，基本的操作就是_“交换”_，在这道题里就是把一个在以前的最优解中，把一个<strong>用了</strong>优惠券的牛的优惠券转而用到另一只<strong>没有用</strong>优惠券的牛身上。</p><p>而至于估价的话我们就采用贪心，直接取最便宜的几头牛就是了。</p><blockquote><p>但是你会惊奇的发现如果这样你会死活调不出来，在WA与TLE之间挣扎，只有62分。</p><p>而且SA的过程中已经没有什么可以优化了，于是我们只能考虑在SA的过程外优化</p><p><del>自然而然</del>联想到可以用一个错的离谱的贪心来选择初始状态</p></blockquote><p>在这里我选用的是以$p_i + c_i$为关键字进行升序排序，于是就A了</p><p><a href="https://www.luogu.org/record/show?rid=9245158" target="_blank" rel="noopener">AC记录</a></p><p>接下来上代码吧2333<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">&#125;s[<span class="number">60000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123; <span class="comment">// 错误贪心排序</span></span><br><span class="line"><span class="keyword">return</span> (a.p + a.c) &lt; (b.p + b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Cpn[<span class="number">60000</span>]; <span class="comment">// 维护当前每头牛有没有用优惠券</span></span><br><span class="line"><span class="keyword">int</span> Usc[<span class="number">60000</span>];  <span class="comment">// 用了优惠券的牛</span></span><br><span class="line"><span class="keyword">int</span> Duc[<span class="number">60000</span>];  <span class="comment">// 没有用优惠券的牛</span></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Calc</span><span class="params">()</span></span>&#123; <span class="comment">// 为当前状态估价</span></span><br><span class="line"><span class="keyword">int</span> Num[<span class="number">60000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">Num[i] = Cpn[i] ? s[i].c : s[i].p;</span><br><span class="line">sort(Num+<span class="number">1</span>, Num+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> Ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Res = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; Res &lt;= m &amp;&amp; i &lt;= n; i++)&#123;</span><br><span class="line">Res += (<span class="keyword">long</span> <span class="keyword">long</span>)Num[i];</span><br><span class="line">Ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Res &lt;= m) <span class="keyword">return</span> Ans;</span><br><span class="line"><span class="keyword">return</span> Ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> Temp = <span class="number">2000</span>; Temp &gt;= <span class="number">1</span>; Temp *= <span class="number">0.9</span>)&#123; <span class="comment">// 退火</span></span><br><span class="line"><span class="keyword">int</span> x = rand() % k + <span class="number">1</span>; <span class="comment">// 在用了优惠券的牛里面选一头</span></span><br><span class="line"><span class="keyword">int</span> y = rand() % (n - k) + <span class="number">1</span>; <span class="comment">// 在没用……</span></span><br><span class="line">swap(Usc[x], Duc[y]);</span><br><span class="line">Cpn[Usc[x]] = <span class="literal">true</span>;</span><br><span class="line">Cpn[Duc[y]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> Nxt = Calc();</span><br><span class="line">        <span class="keyword">int</span> Del = Nxt - Ans; </span><br><span class="line">        <span class="keyword">if</span>(Del &gt; <span class="number">0</span>)</span><br><span class="line">            Ans = Nxt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(-(<span class="keyword">double</span>)Del / Temp) * RAND_MAX * <span class="number">2</span> &lt; rand())&#123; <span class="comment">// 有概率接受一个更差解</span></span><br><span class="line">        swap(Usc[x], Duc[y]);</span><br><span class="line">Cpn[Usc[x]] = <span class="literal">true</span>;</span><br><span class="line">Cpn[Duc[y]] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">srand(<span class="number">20050426</span> + <span class="number">20031119</span>); <span class="comment">// LJC00118 + Saofish的生日 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %lld"</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;s[i].p, &amp;s[i].c);</span><br><span class="line">sort(s+<span class="number">1</span>, s+n+<span class="number">1</span>, cmp); <span class="comment">// 玄学排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123; <span class="comment">// 默认将前k个设为用了优惠券的</span></span><br><span class="line">Usc[i] = i;</span><br><span class="line">Cpn[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = k+<span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 其余的不用</span></span><br><span class="line">Duc[i - k] = i;</span><br><span class="line">Cpn[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">Ans = Calc(); <span class="comment">// 为初始状态估价</span></span><br><span class="line">SA(); <span class="comment">// 退火</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骗分 </tag>
            
            <tag> 模拟退火 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P4267 [USACO18FEB]Taming the Herd</title>
      <link href="/2018/07/31/Solutions/Solution-Luogu4267/"/>
      <url>/2018/07/31/Solutions/Solution-Luogu4267/</url>
      
        <content type="html"><![CDATA[<h2 id="竟然没有人写题解2333那本蒟蒻就来-H-2O-一篇吧"><a href="#竟然没有人写题解2333那本蒟蒻就来-H-2O-一篇吧" class="headerlink" title="竟然没有人写题解2333那本蒟蒻就来$H_2O$一篇吧"></a>竟然没有人写题解2333那本蒟蒻就来$H_2O$一篇吧</h2><p>首先，看完题面不难想到DP，之后再看数据范围考虑$O(N^3)$DP，之后瞎搞一通可以想到</p><blockquote><p>$f[i][j]$表示在前$i$个里面经历$k$次出逃可以取到最少的修改数</p><p>那么接下来我们就发现$f[i][j]$可以影响的范围为$f[u][j+1]$($i &lt; u ≤n$)，然后我们就可以写出如下的程序：</p></blockquote><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Num[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> Cnt[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">110</span>][<span class="number">110</span>]; <span class="comment">// dp数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)); <span class="comment">// f数组初值极大</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Num[i]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Cnt[i][j]表示如果第i天出逃那么到第j天如果改成输入的序列需要修改的次数</span></span><br><span class="line"><span class="comment">     * 这里我们把Cnt预处理以下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> Cou = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Num[j] != j - i)</span><br><span class="line">Cou++;</span><br><span class="line">Cnt[i][j] = Cou;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = i+<span class="number">1</span>; u &lt;= n; u++) <span class="comment">// 枚举f[i][j]可以更新的状态</span></span><br><span class="line"><span class="keyword">if</span>(f[u][j] &gt; f[i][j<span class="number">-1</span>] + Cnt[i+<span class="number">1</span>][u]) <span class="comment">// 如果更优</span></span><br><span class="line">f[u][j] = f[i][j<span class="number">-1</span>] + Cnt[i+<span class="number">1</span>][u];</span><br><span class="line">    <span class="comment">// 不难看出答案就是f[n][1]……f[n][n]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P1704 寻找最优美做题曲线</title>
      <link href="/2018/04/09/Solutions/Solution-Luogu1704/"/>
      <url>/2018/04/09/Solutions/Solution-Luogu1704/</url>
      
        <content type="html"><![CDATA[<h2 id="暴力赛高！暴力是全世界最最最（以下省略2147483647个人最）NB的算法！"><a href="#暴力赛高！暴力是全世界最最最（以下省略2147483647个人最）NB的算法！" class="headerlink" title="暴力赛高！暴力是全世界最最最（以下省略2147483647个人最）NB的算法！"></a>暴力赛高！暴力是全世界最最最（以下省略2147483647个人最）<strong>NB</strong>的算法！</h2><h3 id="AC记录"><a href="#AC记录" class="headerlink" title="AC记录"></a><a href="https://www.luogu.org/record/show?rid=6705503" target="_blank" rel="noopener">AC记录</a></h3><p>这里似乎没有朴素的算法啊（啊当然Pascal不算哈）</p><p>我开始做题的时候还专门为了求稳去学习了一下$nlogn$的最长上升子序列呢</p><p>其实我们会发现，暴力的时间复杂度其实根本不是$O(n^2)$，就让我们来分析一下暴力的时间复杂度。</p><a id="more"></a><p>首先，读入，时间复杂度$O(n+k$)，即$O(n)$；</p><p>接下来，对必须做题的时间排序，复杂度$O(nlogn)$；</p><p>再下去，对每段进行最长上升子序列，在一般情况下$c_i$平均分布，复杂度为$O((n/k)^2 * k)$，即$O(n^2/k)$，但是，在某些奇葩的数据下，会出现这个复杂度退化为$O(n^2)$的情况，显然，这道题并没有这样的数据（啊当然NOIP的话你是可以看看CCF会不会出这种毒瘤数据，但是这种一般的题目出题人都是直接敲个随机生成就走人的）（不要问我为什么因为我自己出题就是这么干的）。</p><p>综上所述，暴力的时间复杂度为$O(n^2/k)$，似乎AC并没有多少问题。。。</p><p>上代码，具体的问题就看代码辣~~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; // 万能头文件 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">// sort需要的比较函数 </span></span><br><span class="line"><span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Num[<span class="number">1100000</span>]; <span class="comment">// 题面中的c </span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1100000</span>];   <span class="comment">// 最长上升子序列的数组 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="comment">// Get(l,r)表示从Num[l+1~r-1]这段的最长上升子序列 </span></span><br><span class="line"><span class="keyword">int</span> Lbound = Num[l]; <span class="comment">// 表示左边的边界，如果数要被放进最长上升子序列中必须要大于这个边界 </span></span><br><span class="line"><span class="keyword">int</span> Rbound = Num[r]; <span class="comment">// 表示右边的边界，如果数要被放进最长上升子序列中必须要小于这个边界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l+<span class="number">1</span>; i &lt; r; i++)&#123; <span class="comment">// O(n^2)最长上升子序列应该不用我多说了吧 </span></span><br><span class="line"><span class="keyword">if</span>(Num[i] &gt; Lbound &amp;&amp; Num[i] &lt; Rbound)&#123; <span class="comment">// 判定这个数是否符合在两个边界之间的条件 </span></span><br><span class="line">f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = l+<span class="number">1</span>; j &lt; i; j++)&#123; <span class="comment">// 这里注意不要把l和r扫进去，会死得很惨 </span></span><br><span class="line"><span class="keyword">if</span>(f[j] + <span class="number">1</span> &gt; f[i] &amp;&amp; Num[j] &lt; Num[i]) f[i] = f[j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l+<span class="number">1</span>; i &lt; r; i++)&#123; <span class="comment">// 这个时候也是同理，别把l和r扫进去 </span></span><br><span class="line"><span class="keyword">if</span>(f[i] &gt; Ans)</span><br><span class="line">Ans = f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)); </span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="comment">//----------开始读入------------- </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">int</span> OI[<span class="number">500000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;OI[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(OI+<span class="number">1</span>, OI+k+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Num[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------读入结束-------------- </span></span><br><span class="line">Num[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 注意一下这句话，因为我们要保证在0~第一个必须做题的天之内左边界为无限小 </span></span><br><span class="line"><span class="keyword">int</span> Ans = k + Get(<span class="number">0</span>, OI[<span class="number">1</span>]); <span class="comment">// 特判一下从0~c[1]之间的这段 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123; <span class="comment">// 扫一遍所有区间 </span></span><br><span class="line">Ans += Get(OI[i], OI[i+<span class="number">1</span>]); <span class="comment">// 加上这个区间的最长上升子序列长度 </span></span><br><span class="line"><span class="keyword">if</span>(Num[OI[i]] &gt;= Num[OI[i+<span class="number">1</span>]])&#123; <span class="comment">// 特判：如果后面一个节点和前面一个节点并不严格单调，则无解 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"impossible"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Num[n+<span class="number">1</span>] = <span class="number">2147483647</span>;  <span class="comment">// 和上面的同理（n+1是为了把最后一天扫进去） </span></span><br><span class="line">Ans += Get(OI[k], n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(OI[<span class="number">1</span>] == <span class="number">0</span>) Ans--; <span class="comment">// 对于第七组数据的特判，看讨论里面所以加的，但是似乎是数据出错了。。。 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans); <span class="comment">// 直接输出答案 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 骗分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P1396 营救</title>
      <link href="/2018/03/23/Solutions/Solution-Luogu1396/"/>
      <url>/2018/03/23/Solutions/Solution-Luogu1396/</url>
      
        <content type="html"><![CDATA[<h2 id="令人智熄的二分操作"><a href="#令人智熄的二分操作" class="headerlink" title="令人智熄的二分操作"></a>令人智熄的二分操作</h2><p><a href="https://www.luogu.org/record/show?rid=6347426" target="_blank" rel="noopener">AC记录</a></p><p>_要看正常的解法请看其他题解_</p><p>而且还蛮快的。。。</p><p>其实，这是非常奇葩的一个想法</p><p>总体思路就是：二分答案</p><p>你没听错，二分答案</p><p>我们从题面中可以看到，其实这道题的拥挤度也就$10000$而已，所以我们就会发现二分似乎可以？？？</p><p>存图存完之后直接二分，二分的$Check()$里面打一个$BFS$，来求能否通往终点，就好了</p><p>具体的东西就上代码来看吧</p><a id="more"></a><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; // 万能头文件 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 邻接表存图 </span></span><br><span class="line"><span class="comment">// 由于是无向图，所以这些数组要开大一倍，我就是这么被坑掉了10分 </span></span><br><span class="line"><span class="keyword">int</span> End[<span class="number">50100</span>]; <span class="comment">// End[i]表示第i条边的终点 </span></span><br><span class="line"><span class="keyword">int</span> Value[<span class="number">50100</span>]; <span class="comment">// Value[i]表示第i条边的边权 </span></span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">50100</span>]; <span class="comment">// Next[i]表示第i条边的下一条边 </span></span><br><span class="line"><span class="keyword">int</span> Head[<span class="number">10100</span>]; <span class="comment">// Head[i]表示第i个点的第一条便</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> q[<span class="number">50100</span>]; <span class="comment">// BFS的队列 </span></span><br><span class="line"><span class="keyword">int</span> n, m, s, t; <span class="comment">// 如题意 </span></span><br><span class="line"><span class="keyword">int</span> qf, qe; <span class="comment">// BFS队列的队首、队尾 </span></span><br><span class="line"><span class="keyword">bool</span> Used[<span class="number">10100</span>]; <span class="comment">// BFS，表示是否到过这个点 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(Used, <span class="literal">false</span>, <span class="keyword">sizeof</span>(Used)); <span class="comment">// 朴实无华的BFS </span></span><br><span class="line">qf = qe = <span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>] = s;</span><br><span class="line">Used[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(qf &lt;= qe)&#123;</span><br><span class="line"><span class="keyword">int</span> xx = Head[q[qf]];</span><br><span class="line"><span class="keyword">while</span>(xx != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!Used[End[xx]] &amp;&amp; Value[xx] &lt;= x)&#123; <span class="comment">// 拓展 </span></span><br><span class="line">q[++qe] = End[xx];</span><br><span class="line">Used[End[xx]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">xx = Next[xx]; </span><br><span class="line">&#125;</span><br><span class="line">qf++; <span class="comment">// 出队 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Used[t]; <span class="comment">// 返回终点有没有到过 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(Next, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Next));</span><br><span class="line"><span class="built_in">memset</span>(Head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Head));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123; <span class="comment">// 读入、存图 </span></span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">Value[i*<span class="number">2</span>] = c;</span><br><span class="line">End[i*<span class="number">2</span>] = b;</span><br><span class="line">Next[i*<span class="number">2</span>] = Head[a];</span><br><span class="line">Head[a] = i*<span class="number">2</span>;</span><br><span class="line">Value[i*<span class="number">2</span>+<span class="number">1</span>] = c; <span class="comment">// 由于是无向图，所以要存两次 </span></span><br><span class="line">End[i*<span class="number">2</span>+<span class="number">1</span>] = a;</span><br><span class="line">Next[i*<span class="number">2</span>+<span class="number">1</span>] = Head[b];</span><br><span class="line">Head[b] = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(c &gt; r)</span><br><span class="line">r = c; <span class="comment">// 生成一个值等于所有最高拥挤度的r，方便二分 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------读入完毕---------------</span></span><br><span class="line"><span class="comment">// ------------二分开始--------------- </span></span><br><span class="line">r++;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123; <span class="comment">// 同样朴素的二分~~~ </span></span><br><span class="line"><span class="keyword">int</span> Mid = ((l+r) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(Check(Mid))</span><br><span class="line">r = Mid;</span><br><span class="line"><span class="keyword">else</span> l = Mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>_感谢 <code>学委</code> 对我的启发_</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 洛谷P2814 家谱</title>
      <link href="/2018/03/16/Solutions/Solution-Luogu2814/"/>
      <url>/2018/03/16/Solutions/Solution-Luogu2814/</url>
      
        <content type="html"><![CDATA[<h2 id="STL大法好！"><a href="#STL大法好！" class="headerlink" title="STL大法好！"></a>STL大法好！</h2><h3 id="（看到楼下的大佬们都没有用我这个方法，我就来脱碳甲醛一下辣-）"><a href="#（看到楼下的大佬们都没有用我这个方法，我就来脱碳甲醛一下辣-）" class="headerlink" title="（看到楼下的大佬们都没有用我这个方法，我就来脱碳甲醛一下辣~~）"></a>（看到楼下的大佬们都没有用我这个方法，我就来脱碳甲醛一下辣~~）</h3><hr><p><strong><del>以上都是废话</del></strong></p><p><strong>我所说的这个方法，具体思路是这样的：</strong></p><ul><li>最首先，基础的并查集大家应该都会，如果不会的话可以看代码或者出门右转P3367并查集模板</li><li>然后，STL中的Map可以直接方便地解决字符串哈希的问题</li><li>但是，每次都用一遍Map似乎显得有些不优美，似乎有些慢的说</li><li>所以，我们需要引进两个数组，一个Num和一个Names</li><li>Num是一个Map，它的作用就是Num[“A”]表示名为A的人的编号</li><li>于是，Names就是反过来的Num，Name[i]表示编号为i的人的名字</li><li>总体而言，不仅加快了速度，还方便了调试</li></ul><a id="more"></a><h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码~~"></a>上代码~~</h3><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; // 万能头文件 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">50100</span>]; <span class="comment">// 并查集，f[i]表示编号为i的人的祖先（可能是之一） </span></span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Num; <span class="comment">// 前面已经解释过了 </span></span><br><span class="line"><span class="built_in">string</span> Names[<span class="number">50100</span>]; <span class="comment">// 同上 </span></span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; Used;  <span class="comment">// 表示这个人有没有被加进Num数组里面 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 找到编号为x的人最早的祖先（并查集的东西） </span></span><br><span class="line"><span class="keyword">if</span>(f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">int</span> next = Find(f[x]);</span><br><span class="line">f[x] = next; <span class="comment">// 路径压缩 </span></span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> Fa, <span class="keyword">int</span> Son)</span></span>&#123; <span class="comment">// 将两个人连起来（把Son加到Fa的族谱下方） </span></span><br><span class="line">f[Son] = f[Find(Fa)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> Name; <span class="comment">// 当前这组父子关系中儿子的名字 </span></span><br><span class="line"><span class="built_in">string</span> Fa; <span class="comment">// Fa ♂乐♂器 （划掉）其实是表示当前这组父子关系中父亲的名字 </span></span><br><span class="line"><span class="keyword">char</span> Type = <span class="string">'A'</span>; <span class="comment">// 顾名思义，当前读入指令的种类 </span></span><br><span class="line"><span class="keyword">int</span> Cur = <span class="number">0</span>; <span class="comment">// 当前编号编到第几个 </span></span><br><span class="line"><span class="keyword">int</span> Fanum; <span class="comment">// 表示当前这组父子关系中父亲的编号 </span></span><br><span class="line"><span class="keyword">while</span>(Type != <span class="string">'$'</span>)&#123;</span><br><span class="line">Type = getchar();</span><br><span class="line"><span class="keyword">switch</span>(Type)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'#'</span>:&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Fa;</span><br><span class="line"><span class="keyword">if</span>(!Used[Fa])&#123; <span class="comment">// 如果这人第一次出现，给他编个号 </span></span><br><span class="line">Used[Fa] = <span class="literal">true</span>;</span><br><span class="line">Num[Fa] = ++Cur;</span><br><span class="line">Names[Cur] = Fa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[Num[Fa]] == <span class="number">0</span>) <span class="comment">// 如果他没有祖先，将他的祖先定义为他自己 </span></span><br><span class="line">f[Cur] = Cur;</span><br><span class="line">Fanum = f[Num[Fa]];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Name;</span><br><span class="line"><span class="keyword">if</span>(!Used[Name])&#123; <span class="comment">// 如果这个人是第一次出现，给他编个号 </span></span><br><span class="line">Used[Name] = <span class="literal">true</span>;</span><br><span class="line">Num[Name] = ++Cur;</span><br><span class="line">Names[Cur] = Name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[Num[Name]] == <span class="number">0</span>) <span class="comment">// 如果他没有祖先，将他的祖先定义为他自己 </span></span><br><span class="line">f[Num[Name]] = Cur;</span><br><span class="line">Link(Fanum, Num[Name]); <span class="comment">// 设定：他是他爸爸的儿子 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'?'</span>:&#123; <span class="comment">// 问询操作：输出Name和Name最早的祖先 </span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Name &lt;&lt; <span class="string">" "</span> &lt;&lt; Names[Find(Num[Name])]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> STL </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
