{"meta":{"title":"Dilute's blog","subtitle":"我好菜啊QwQ","description":"有了Hexo博客并不能改变我是个蒟蒻的事实","author":"Dilute","url":"https://dilute.xyz","root":"/"},"pages":[{"title":"404 not found","date":"2022-10-25T13:16:37.363Z","updated":"2019-04-22T06:02:44.000Z","comments":true,"path":"404.html","permalink":"https://dilute.xyz/404.html","excerpt":"","text":"哦不 你找的东西丢了 如果你是从别的地方点进来的，请直接在本页评论"},{"title":"About Dilute","date":"2022-10-25T13:16:38.329Z","updated":"2022-07-31T23:45:32.000Z","comments":true,"path":"about/index.html","permalink":"https://dilute.xyz/about/index.html","excerpt":"","text":"啊？关于我？ Dilute，男，浙江人，现在在哈尔滨读大一。 $QQ:$$23128866507$ 各大OJ的账号$\\texttt{Luogu:}$ $\\texttt{Dilute}$ $\\texttt{Codeforces:}$ $\\texttt{LibreOJ:}$ $\\texttt{Dilute}$ $\\texttt{BZOJ :}$ $\\texttt{Dilute}$"},{"title":"About Dilute","date":"2022-10-25T13:16:38.348Z","updated":"2022-07-31T23:44:56.000Z","comments":true,"path":"about/index的副本.html","permalink":"https://dilute.xyz/about/index的副本.html","excerpt":"","text":"啊？关于我？ Dilute，男，浙江人，现在在哈尔滨读大一。 $QQ:$$23128866507$ 各大OJ的账号$\\texttt{Luogu:}$ $\\texttt{Dilute}$ $\\texttt{Codeforces:}$ $\\texttt{LibreOJ:}$ $\\texttt{Dilute}$ $\\texttt{BZOJ :}$ $\\texttt{Dilute}$ 一些值得纪念的事情 2017.8.11 AC50 2017.8.12 洛谷绿名 2017.9.16 洛谷橙名 2017.9.29 AC100 2017.10.5 洛谷红名 2018.2.4 洛谷掉蓝回到解放前 2018.3.4 洛谷掉蓝一个月纪念重回红名（我回到红名肯定是因为拜了Sooke） 2018.3.11 洛谷掉绿 2018.3.17 洛谷回红X2 2018.4.14 AC200 2018.6.4 洛谷积分达到神犇 2018.7.10 AC250 2018.7.13 CF蓝名（Expert） 2018.8.1 AC300 2018.9.3 AC400 2018.9.24 AC500 2018.10.14 AC600 2018.10.27 AC666 2018.11.1 AC700 2018.11.24 AC800 2018.12.10 AC900 2018.12.23 CF紫名（Candidate Master） 2019.1.2 AC1000 2019.1.28 AC1100 2019.2.19 CF黄名（Master）"},{"title":"About Dilute","date":"2022-10-25T13:16:38.394Z","updated":"2019-01-11T06:51:58.000Z","comments":true,"path":"diary/index.html","permalink":"https://dilute.xyz/diary/index.html","excerpt":"","text":"啊？关于我？ 我是个大菜鸡 $\\texttt{Luogu}$： $Diltue​$ $\\texttt{Codeforces:}$ $Diltue$ $\\texttt{LibreOJ:}$ $Diltue$ $\\texttt{BZOJ :}$ $Diltue$ 更多东西以后再加吧（"},{"title":"所有标签","date":"2022-10-25T13:16:39.040Z","updated":"2019-03-01T12:24:40.000Z","comments":true,"path":"tags/index.html","permalink":"https://dilute.xyz/tags/index.html","excerpt":"","text":""},{"title":"我认识的dalao们","date":"2022-10-25T13:16:38.416Z","updated":"2020-01-15T14:02:32.000Z","comments":true,"path":"friends/index.html","permalink":"https://dilute.xyz/friends/index.html","excerpt":"","text":"此页里所有人都随手吊打我。 不接受任何反驳。"},{"title":"所有分类","date":"2022-10-25T13:16:38.370Z","updated":"2019-03-01T12:22:28.000Z","comments":true,"path":"categories/index.html","permalink":"https://dilute.xyz/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"ACM Journal","slug":"Other/ACM-Journal","date":"2022-07-31T23:39:00.000Z","updated":"2022-10-26T15:38:56.180Z","comments":true,"path":"2022/08/01/Other/ACM-Journal/","link":"","permalink":"https://dilute.xyz/2022/08/01/Other/ACM-Journal/","excerpt":"HZEZ OIer Dilute 的故事虽然已经结束…… 但是接下来是属于 HIT ACMer Dilute 的时间！","text":"HZEZ OIer Dilute 的故事虽然已经结束…… 但是接下来是属于 HIT ACMer Dilute 的时间！ 2022.10.26今天是 2022 年 10 月 26 号。 距离我上一次更新这个博客已经过了两个多月。 我其实也没什么 xcpc 相关的东西要写的。 虽然我这两个月也写了些题，但是总是因为各种各样的原因发到博客上来； 主要原因是我换了电脑 把博客迁移过来很累的啦 而且我也懒得把前两个月的题目总结一下 直到今天的俄语课上…… 我们的老师，她说了一个神秘的单词—————— Ълог 「啊这个单词意思是 博客 」 「欸我们班上有同学写博客吗？」 我举起了手，但是老师似乎没有看到。 「现在好像没什么人写这东西了。」 「我以前有个学生经常写，他好像是搞什么信息学竞赛的，很厉害。」 于是我终于想起来了我的小可爱博客。 并且把它移到了我的新电脑上。 好耶！ 写完之后又发现出现了奇怪的问题。 苹果的电脑有个机制 会把文件保存到icloud上面而把本地的文件删掉。 于是我的头像便惨遭了毒手。 我还得从手机相册里把我的头像的高清原图找出来发给电脑。 icloud ！我要把你那肮脏的服务器！砍断！切开！剁碎！ 2022.8.19Codeforces 1718C比赛的时候多测没清空，甚至过了几天才发现，我的评价是：寄！ 肯定成一个环，绕若干圈，然后可以发现最后选择的环长一定是一个质数，直接 $\\text{multiset}$ 爆淦即可。 高三毕业的暑假里突然想起自己还有一个blog。 于是打开了那个熟悉的网址，意料之外的是这个域名竟然一直没有过期。 而意料之中的是，虽然博客还在，但是包括评论系统，相当一部分的图片和友链都已经挂掉了甚至在上传这篇文章的时候还遇到了github上的ssh key 离奇消失的奇怪事件。上一次更新是两年半以前的事情——那好像是上个世纪的东西了。 接着我翻看了一下自己过往的文章。 看着初学OI时期的青涩的题解，那些是我看着可以扣地板扣出三室一厅的黑历史。 看着随着我OI水平的提高文风日渐成熟（虽然也没好到哪里去）的文章，我仿佛回到了坐在二中机房里，一杯水一台电脑，一个bug调一天的时光。 看着各处打比赛的游记，死去的回忆突然从我的脑海中苏醒，ZJOI时mwh「你瑞兹爸爸来啦！」的战吼仿佛又回荡在了我的脑海、PKUWC时和wxw和sooke的夜晚蹦迪似乎就发生在昨天、想到了NOIp / CSP 时的欢笑与泪水…… 回首往昔，我的OI生涯虽然称不上成功，但在我看来也并非是彻底的失败。 但是高中阶段的OI对我而言已然是过往云烟，我们应当向着未来去看。 换了新的头像，重新启用这个百废待兴的博客，不论是在日常生活，学习上，还是 OI / ACM 的方面上，我都希望我自己也可以成长为更加成熟，更加可以独当一面的人。 也许我还可以在大学，在ACM的舞台上发光发热。 这篇文章将会持续更新，更新我作为 ACMer 时写的题。 Dilute 写于2022年8月1日。","categories":[],"tags":[]},{"title":"题解 CF1314D Tourism","slug":"Solutions/Solution-CF1314D","date":"2020-02-24T13:16:50.000Z","updated":"2020-02-24T13:16:50.000Z","comments":true,"path":"2020/02/24/Solutions/Solution-CF1314D/","link":"","permalink":"https://dilute.xyz/2020/02/24/Solutions/Solution-CF1314D/","excerpt":"开场 10 分钟就有人过的 1D ，你值得拥有！ $\\texttt{swap(B, D)}$ 警告。","text":"开场 10 分钟就有人过的 1D ，你值得拥有！ $\\texttt{swap(B, D)}$ 警告。 精读题面，发现 $k \\le 10$ ，考虑从这个性质中寻找解法。 $k \\le 10$ 意味着最后真正对结果产生贡献的节点只会有 $10$ 个以下。 结合题面中给出的「没有奇环」条件，容易想到二分图黑白染色。 考虑对每个点随机染 黑 / 白色，再强制走两端颜色 不相同 的边。 这个过程可以用简单 dp ，$f_{i, j}$ 表示走了 $i$ 条边，当前在节点 $j$ 的最小花费，$\\Theta(n^2k)$ 直接转移即可。 重复这个过程若干遍即可。 我们继续考虑为什么这个解法是大概率正确的。 考虑如果我们已经知道了最终的一条最优路径，这上面最多有 $k$ 个点。 那么这 $k$ 个点在一种染色方案中黑白相间的概率是 $\\frac{1}{2^{k - 1}}$ ，在 $k = 10$ 的情况下就是 $\\frac{1}{512}$。 随机 $5000$ 次的情况下，随不出正确答案的概率是 $(\\frac{511}{512})^{5000} \\approx 0.000056845461206$ ，非常小，可以忽略不计。 这解法就 ** 离谱。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;ll f[20][100], dis[100][100];int c[100];int main()&#123; srand((unsigned)time(NULL)); int n = inp(); int k = inp(); int T = 5000; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) dis[i][j] = inp(); ll ans = 1e18; while(T--)&#123; for(int i = 1; i &lt;= n; i++)&#123; c[i] = rand() &amp; 1; f[0][i] = 1e18; &#125; f[0][1] = 0; for(int i = 0; i &lt; k; i++)&#123; for(int j = 1; j &lt;= n; j++) f[i + 1][j] = 1e18; for(int j = 1; j &lt;= n; j++) for(int u = 1; u &lt;= n; u++) if(c[j] != c[u]) f[i + 1][u] = std::min(f[i + 1][u], f[i][j] + dis[j][u]); &#125; ans = std::min(ans, f[k][1]); &#125; printf(\"%lld\\n\", ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"},{"name":"随机化","slug":"随机化","permalink":"https://dilute.xyz/tags/随机化/"}]},{"title":"题解 CF1286C Madhouse","slug":"Solutions/Solution-CF1286C","date":"2020-01-12T02:25:00.000Z","updated":"2020-01-12T03:53:02.000Z","comments":true,"path":"2020/01/12/Solutions/Solution-CF1286C/","link":"","permalink":"https://dilute.xyz/2020/01/12/Solutions/Solution-CF1286C/","excerpt":"这个 $0.777$ 让我想起了某位 EDG 的退役打野选手 —— Sooke 4396（无 端 迫 害）","text":"这个 $0.777$ 让我想起了某位 EDG 的退役打野选手 —— Sooke 4396（无 端 迫 害） 我们首先考虑如果我们询问了一段区间 $[1 ,n ]$ ，我们可以得到什么信息。 我们考虑把 $s_1 , s_{2} , s_{3} \\cdots s_n$ 在每种长度的子串中出现的次数给写出来（以 $n = 5$ 时的情况为例）。 $len$ $s_1$ $s_2$ $s_3$ $s_4$ $s_5$ 1 1 1 1 1 1 2 1 2 2 2 1 3 1 2 3 2 1 看出规律了吗？如果看不出来的话，我们把每列的数做差分之后的结果再写出来。 $len$ $s_1$ $s_2$ $s_3$ $s_4$ $s_5$ 1 1 1 1 1 1 2 0 1 1 1 0 3 0 0 1 0 0 这样以来，我们是不是可以得到 $s[\\frac{l + r}2]$ 的值（当 $len$ 为奇数的时候才可以），并且可以得到 $\\lfloor \\frac {len}2 \\rfloor$ 组形如 「$s_x$ 和 $s_y$ 分别是 $a$ 和 $b$ 」（其中 $a$ 和 $b$ 代表两个字符）的限制。 我们接下来考虑如何利用这个性质来解决这道题目。 考虑将这个字符串划分为三段，分别为 $[1 , s]$，$[s + 1, t]$，$[t + 1, n]$ 三段区间。 这个分法要满足一定的要求，具体是什么要求稍后会讲到。 然后询问 $[1 , t]$ ，$[s + 1 , n]$ ，$[s + 1, n - 1]$ 三段。 把每组得到的约束条件都连起来，我们可以得到一个差不多长成这样的图…… 注意那个画着一个绿色圈圈的位置，我们假设我们已经知道这里是什么。 那么考虑交替通过绿色和红色的约束就可以知道第二段和第三段，然后通过蓝色的约束就可以知道第一段了。 那么只要在询问 $[s + 1 , n]$ 的时候那个长度为奇数的时候中间可以直接知道的数落在它身上就可以了。 这样一来，我们就知道这个分法要满足什么要求了。 我们设三段的长度分别为 $len1 , len2 , len3$，那么需要满足： $len2 + len3$ 为奇数 $len2 &gt; len3$ $len2 &gt; len1$ （否则无法由第二段推出完整的 $len1$） 可以通过对 $n \\mod 3$ 进行分类讨论得出 $len1 , len2 , len3$ 。 每次询问的长度都是 $\\frac 23 n$ 级别，询问出来的字串数量都是 $\\frac 29 n^2$ 级别，最终三次询问加起来就大约是 $\\frac 23 n^2 \\approx 0.66666 n^2 &lt; 0.777 n^2$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647int inp()&#123; char c = getchar(); int neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') neg = -1; c = getchar(); &#125; int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * neg;&#125;char ans[110], s[110];char f[110][110][2];char _query(int x)&#123; std::cout &lt;&lt; \"? \" &lt;&lt; x &lt;&lt; ' ' &lt;&lt; x &lt;&lt; std::endl; char c = getchar(); while(c &lt; 'a' || c &gt; 'z') c = getchar(); return c;&#125;std::vector&lt;std::string&gt; vec[110];std::string str;bool cmp(std::string a, std::string b)&#123; return a.size() &lt; b.size();&#125;int cnt[30], q[110], cou[30];int qf = 1, qe = 0, n;bool used[110], have[110][110];int last[30], delta[30];void query(int l, int r)&#123; for(int i = 1; i &lt;= r - l + 1; i++) vec[i].clear(); std::cout &lt;&lt; \"? \" &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; std::endl; for(int i = 1; i &lt;= ((r - l + 1) * (r - l + 2) &gt;&gt; 1); i++)&#123; std::cin &gt;&gt; str; vec[(int)(str.size())].push_back(str); // printf(\"str.size() = %d\\n\", (int)(str.size())); &#125; memset(delta, 0, sizeof(delta)); memset(last, 0, sizeof(last)); for(int i = 0; i &lt; (int)(vec[1].size()); i++)&#123; last[vec[1][i][0] - 'a']++; delta[vec[1][i][0] - 'a']++; &#125; for(int i = 2; i &lt;= ((r - l) &gt;&gt; 1) + 1; i++)&#123; memset(cnt, 0, sizeof(cnt)); for(int j = 0; j &lt; (int)(vec[i].size()); j++) for(int u = 0; u &lt; i; u++) cnt[vec[i][j][u] - 'a']++; int cur = 0; // printf(\"i = %d\\n\", i); for(int j = 0; j &lt; 26; j++)&#123; cnt[j] -= last[j]; last[j] += cnt[j]; int last = cnt[j]; while(cnt[j] &lt; delta[j])&#123; // printf(\"link %d %d\\n\", l + i - 2, r - i + 2); f[l + i - 2][r - i + 2][cur] = 'a' + j; f[r - i + 2][l + i - 2][cur] = 'a' + j; have[l + i - 2][r - i + 2] = true; have[r - i + 2][l + i - 2] = true; cur++; cnt[j]++; &#125; delta[j] = last; &#125; &#125; // printf(\"maxinum %d | %d \", ((r - l + 1) &gt;&gt; 1) + ((r - l) &amp; 1), vec[2].size()); int mid = (l + r) &gt;&gt; 1; if((r - l + 1) &amp; 1)&#123; for(int i = 0; i &lt; 26; i++) if(delta[i] &amp;&amp; !used[mid])&#123; used[mid] = true; ans[mid] = 'a' + i; q[++qe] = mid; // printf(\"ans[%d] = '%c' | %d\\n\", mid, 'a' + i, cnt[i]); &#125; &#125; else &#123; int cur = 0; for(int i = 0; i &lt; 26; i++) while(delta[i])&#123; int mid = (l + r) &gt;&gt; 1; // printf(\"| link %d %d | %d left\\n\", mid, mid + 1, delta[i]); f[mid][mid + 1][cur] = 'a' + i; f[mid + 1][mid][cur] = 'a' + i; have[mid][mid + 1] = true; have[mid + 1][mid] = true; cur++; delta[i]--; &#125; &#125;&#125;void print(int len)&#123; printf(\"! \"); for(int i = 1; i &lt;= len; i++) putchar(ans[i]); std::cout &lt;&lt; std::endl;&#125;void bfs()&#123; while(qf &lt;= qe)&#123; int i = q[qf++]; for(int j = 1; j &lt;= n; j++) if(have[i][j] &amp;&amp; !used[j])&#123; ans[j] = f[i][j][f[i][j][0] == ans[i]]; used[j] = true; q[++qe] = j; &#125; &#125;&#125;int main()&#123; n = inp(); if(n &lt;= 3)&#123; for(int i = 1; i &lt;= n; i++) ans[i] = _query(i); print(n); return 0; &#125; int len1 = (n / 3); int len2 = len1, len3 = len1; if(n % 3 == 0)&#123; len2++; len3--; &#125; else if(n % 3 == 1)&#123; len2++; &#125; else &#123; len2++; len3++; &#125; query(1, len1 + len2); query(len1 + 1, n); query(len1 + 1, n - 1); // for(int i = 1; i &lt;= n; i++) // for(int j = 1; j &lt;= n; j++) // if(have[i][j]) // printf(\"&#123;%d, %d&#125; &#123;%c, %c&#125;\\n\", i, j, f[i][j][0], f[i][j][1]); bfs(); print(n);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"非传统题","slug":"非传统题","permalink":"https://dilute.xyz/tags/非传统题/"}]},{"title":"题解 CF498D Traffic Jams in the Land","slug":"Solutions/Solution-CF498D","date":"2019-08-31T23:16:00.000Z","updated":"2019-09-01T11:34:48.000Z","comments":true,"path":"2019/09/01/Solutions/Solution-CF498D/","link":"","permalink":"https://dilute.xyz/2019/09/01/Solutions/Solution-CF498D/","excerpt":"线段树首先观察数据范围，发现$a_i \\le6$，这个是一个非常有用的性质。 发现$\\mathrm{lcm}(1, 2, 3, 4, 5, 6)=60$，这个数有一个非常优美的性质：把$t$再$\\mod 60$意义下进行不会影响结果的正确性。","text":"线段树首先观察数据范围，发现$a_i \\le6$，这个是一个非常有用的性质。 发现$\\mathrm{lcm}(1, 2, 3, 4, 5, 6)=60$，这个数有一个非常优美的性质：把$t$再$\\mod 60$意义下进行不会影响结果的正确性。 接下来继续考虑线段树，对于每个区间$[l, r]$，再对于每个可能的时间$\\mod 60$意义下的结果，我们维护如果在达到$l$的时候$t \\mod 60 = i$，那么达到$r + 1$需要花费多少时间。 这个玩意儿可以$O(60)$的$push_up$。 那么我们就可以以$O(n \\log n \\times 60)$ 的优秀复杂度通过此题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define lc(a) ((a) &lt;&lt; 1)#define rc(a) ((a) &lt;&lt; 1 | 1)int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;int a[100010];struct SEG_Tree&#123; struct SEG&#123; int l; int r; int f[61]; &#125;t[400010]; void push_up(int cur)&#123; for(int i = 0; i &lt; 60; i++) t[cur].f[i] = t[rc(cur)].f[(i + t[lc(cur)].f[i]) % 60] + t[lc(cur)].f[i]; &#125; void build(int cur, int l, int r)&#123; t[cur].l = l; t[cur].r = r; if(l == r)&#123; for(int i = 59; i &gt;= 0; i--) t[cur].f[i] = 1 + (i % a[l] == 0); return ; &#125; int mid = (l + r) &gt;&gt; 1; build(lc(cur), l, mid); build(rc(cur), mid + 1, r); push_up(cur); &#125; void modify(int cur, int x, int c)&#123; if(t[cur].l == t[cur].r)&#123; a[x] = c; for(int i = 59; i &gt;= 0; i--) t[cur].f[i] = 1 + (i % a[x] == 0); return ; &#125; if(x &lt;= t[lc(cur)].r) modify(lc(cur), x, c); else modify(rc(cur), x, c); push_up(cur); &#125; int query(int cur, int l, int r, int x)&#123; if(t[cur].l &gt; r || t[cur].r &lt; l) return 0; if(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)&#123; // printf(\"[%d, %d].f[%d] = %d\\n\", t[cur].l, t[cur].r, x, t[cur].f[x]); return t[cur].f[x]; &#125; int ls = query(lc(cur), l, r, x); return ls + query(rc(cur), l, r, (x + ls) % 60); &#125;&#125;t;int main()&#123; int n = inp(); for(int i = 1; i &lt;= n; i++) a[i] = inp(); t.build(1, 1, n); int m = inp(); while(m--)&#123; char op = getchar(); while(op != 'C' &amp;&amp; op != 'A') op = getchar(); if(op == 'C')&#123; int x = inp(); int c = inp(); t.modify(1, x, c); &#125; else &#123; int l = inp(); int r = inp() - 1; printf(\"%d\\n\", t.query(1, l, r, 0)); &#125; &#125;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://dilute.xyz/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"https://dilute.xyz/tags/线段树/"}]},{"title":"题解 CF1178G The Awesomest Vertex","slug":"Solutions/Solution-CF1178G","date":"2019-07-21T04:12:00.000Z","updated":"2019-09-01T11:19:50.000Z","comments":true,"path":"2019/07/21/Solutions/Solution-CF1178G/","link":"","permalink":"https://dilute.xyz/2019/07/21/Solutions/Solution-CF1178G/","excerpt":"分块 + 斜率优化G真的比F2清真 首先，看到树上 + 子树操作，第一反应使用dfs序拍平。 那么这个问题就变成了支持： 区间$a_i += x$ 询问区间$\\max{|a_i| * |b_i|}$","text":"分块 + 斜率优化G真的比F2清真 首先，看到树上 + 子树操作，第一反应使用dfs序拍平。 那么这个问题就变成了支持： 区间$a_i += x$ 询问区间$\\max{|a_i| * |b_i|}$ 考虑这个问题如何解决。 发现$b_i$并不会改变，所以预处理出来$|b_i|$。 之后考虑如何支持修改$a$，考虑斜率优化。 对于每个点维护$y = b_ix + a_i * b_i$的直线； 其中$x$表示的是这个点的$\\Delta a_i$。 但是我们每次询问和修改的都是区间。 那么考虑分块，对于每个块内维护对应的凸壳。 然后对于每次修改，暴力重构边缘所在的块，对于中间完整覆盖的块，我们只需要打一个标记，代表这个块内所有东西的$a_i$值都加上了一个值，这样一来对于每块内他的$\\Delta$就是一个相等的值，那么查询的时候边缘暴力做，中间可以在凸壳上二分。 那么还有一个问题：这个绝对值还没有解决。 $b_i$的问题非常好解决，预处理的时候取一下即可。 对于$a_i$这是一个取$\\max$的问题，所以如果绝对值取反是肯定不优。那么只需要维护两个凸壳分别维护$a_i$取反和不取反的情况即可。 最终复杂度$O(n \\sqrt{n} \\log n)$，可能需要一些高超的卡常技巧，这边给一些卡常的技巧好了。 块大小开小一点（这是最重要的一点），虽然询问时候复杂度是$O(\\frac{n}{size} * \\log{size})$，然后修改的时候暴力重构是$O(size * \\log size)$的，但是询问的时候那个$\\log$严重跑不满，暴力重构的$\\log$是排序的，还是比较满的。 维护凸壳的时候用$vector$，不要用数组（我也不知道为什么，反正这样变快了，$\\color{black}{z} \\color{red}{xyhh}$大爷说这是高速缓存的问题）。 最后上一波代码吧… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;bits/stdc++.h&gt; #define SIZE 250#define ll long long#define INF 2147483647#define is_bad(a, m, c) ((m.b - c.b) * (m.k - a.k) &lt;= (a.b - m.b) * (c.k - m.k)) int inp()&#123; char c = getchar(); int neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') neg = -1; c = getchar(); &#125; int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * neg;&#125; int head[200010], nxt[200010], end[200010], dfn[200010], size[200010];ll a2[200010], b2[200010], a[200010], b[200010]; int cou = 0;void link(int a, int b)&#123; nxt[++cou] = head[a]; head[a] = cou; end[cou] = b;&#125; struct Node&#123; ll k; ll b; ll get(int x)&#123; return x * k + b; &#125;&#125;; bool cmp(Node a, Node b)&#123; return a.k &lt; b.k;&#125; struct Convex&#123; std::vector&lt;Node&gt; s; void insert(Node x)&#123; while(s.size() &gt; 1 &amp;&amp; is_bad(s[s.size() - 2], s[s.size() - 1], x)) s.resize(s.size() - 1); s.push_back(x); &#125; ll query(ll x)&#123; if(s.size() == 0) return -1e18; int l = 0; int r = s.size() - 1; while(l &lt; r)&#123; int mid = (l + r) &gt;&gt; 1; if(s[mid].get(x) &lt;= s[mid + 1].get(x)) l = mid + 1; else r = mid; &#125; return s[l].get(x); &#125; void clear()&#123; s.clear(); &#125;&#125;c[1000], cf[1000]; int ql[1000], qr[1000];ll delta[1000];std::vector&lt;Node&gt; vec; void rebuild(int x)&#123; vec.clear(); c[x].clear(); cf[x].clear(); for(int i = ql[x]; i &lt;= qr[x]; i++)&#123; a[i] += delta[x]; vec.push_back((Node)&#123;b[i], a[i] * b[i]&#125;); &#125; std::sort(vec.begin(), vec.end(), cmp); for(int i = 0; i &lt; vec.size(); i++) c[x].insert(vec[i]); for(int i = 0; i &lt; vec.size(); i++) cf[x].insert((Node)&#123;vec[i].k, -vec[i].b&#125;); delta[x] = 0;&#125; int idx = 0;void dfs(int cur)&#123; dfn[cur] = ++idx; size[cur] = 1; for(int x = head[cur]; x != -1; x = nxt[x])&#123; a[end[x]] += a[cur]; b[end[x]] += b[cur]; dfs(end[x]); size[cur] += size[end[x]]; &#125;&#125; int main()&#123; memset(head, -1, sizeof(head)); int n = inp(); int q = inp(); for(int i = 2; i &lt;= n; i++)&#123; int fa = inp(); link(fa, i); &#125; for(int i = 1; i &lt;= n; i++) a[i] = inp(); for(int i = 1; i &lt;= n; i++) b[i] = inp(); dfs(1); memcpy(a2, a, sizeof(a)); memcpy(b2, b, sizeof(b)); for(int i = 1; i &lt;= n; i++)&#123; a[dfn[i]] = a2[i]; b[dfn[i]] = abs(b2[i]); &#125; qr[0] = 0; int cur = 1; while(qr[cur - 1] &lt; n)&#123; ql[cur] = qr[cur - 1] + 1; qr[cur] = ql[cur] + SIZE - 1; cur++; &#125; qr[cur - 1] = n; for(int i = 1; i &lt; cur; i++) rebuild(i); while(q--)&#123; int op = inp(); if(op == 1)&#123; int v = inp(); ll x = inp(); int l = dfn[v]; int r = dfn[v] + size[v] - 1; int lb = (l - 1) / SIZE + 1; int rb = (r - 1) / SIZE + 1; if(lb == rb)&#123; for(int i = l; i &lt;= r; i++) a[i] += x; rebuild(lb); &#125; else &#123; for(int i = lb + 1; i &lt; rb; i++) delta[i] += x; for(int i = l; i &lt;= qr[lb]; i++) a[i] += x; for(int i = ql[rb]; i &lt;= r; i++) a[i] += x; rebuild(lb); rebuild(rb); &#125; &#125; else &#123; int v = inp(); int l = dfn[v]; int r = dfn[v] + size[v] - 1; int lb = (l - 1) / SIZE + 1; int rb = (r - 1) / SIZE + 1; ll ans = -1e18; if(lb == rb)&#123; for(int i = l; i &lt;= r; i++) ans = std::max(ans, abs(a[i] + delta[lb]) * b[i]); &#125; else &#123; for(int i = lb + 1; i &lt; rb; i++)&#123; ans = std::max(ans, c[i].query(delta[i])); ans = std::max(ans, cf[i].query(-delta[i])); &#125; for(int i = l; i &lt;= qr[lb]; i++) ans = std::max(ans, abs(a[i] + delta[lb]) * b[i]); for(int i = ql[rb]; i &lt;= r; i++) ans = std::max(ans, abs(a[i] + delta[rb]) * b[i]); &#125; printf(\"%lld\\n\", ans); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"斜率优化","slug":"斜率优化","permalink":"https://dilute.xyz/tags/斜率优化/"},{"name":"分块","slug":"分块","permalink":"https://dilute.xyz/tags/分块/"},{"name":"DFS序.","slug":"DFS序","permalink":"https://dilute.xyz/tags/DFS序/"}]},{"title":"题解 CF1183H Subsequences (hard version)","slug":"Solutions/Solution-CF1183H","date":"2019-06-27T00:43:00.000Z","updated":"2019-06-27T01:38:04.000Z","comments":true,"path":"2019/06/27/Solutions/Solution-CF1183H/","link":"","permalink":"https://dilute.xyz/2019/06/27/Solutions/Solution-CF1183H/","excerpt":"瞎搞DPCF出了H没出G 菜的真实 发现$k$从$\\texttt{E}$题的$100$变成了$O(10^{12})$，考虑与$k$复杂度无关的做法。 我们考虑$f_{i, j}$表示以$s_i$开始，本质不同的长度为$j$的子序列数量。","text":"瞎搞DPCF出了H没出G 菜的真实 发现$k$从$\\texttt{E}$题的$100$变成了$O(10^{12})$，考虑与$k$复杂度无关的做法。 我们考虑$f_{i, j}$表示以$s_i$开始，本质不同的长度为$j$的子序列数量。 显然直接转移是错误的，例如下面这种情况就会在计算字符串$\\texttt{baa}$的$f_{1, 2}$的时候把$\\texttt{ba}$给计算两遍。 我们考虑如何去掉这些重复算的字符串。 首先，我们枚举下一个出现的位置$u$，考虑$f_{u, j - 1}$被算重的条件。 如果存在一个$k$，使得$s_k = s_j$且$i &lt; k &lt; u$，那么我们发现$f_{k, j - 1}$完全包含的$f_{u, j - 1}$，换句话说就是$f_{u, j - 1}$整个算重了。 也就是说，我们在枚举转移的时候，我们只需要选择$s_u$是在$(l, n]$这段区间内第一次出现的$f_{u, j - 1}$转移即可。 求出了$f$之后，我们可以得出长度为$len$的本质不同的子序列就是$f[0][len + 1]$。 我们只需要从高到低枚举$len$，然后贪心的尽量取长的字符串即可。 最终复杂度$O(n^3)$（其实是可以做到$O(26 n^2)$的，但是过了就行）。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647ll inp()&#123; char c =getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); ll sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;ll f[200][200];bool used[30];char s[200];int main()&#123; int n = inp(); ll k = inp(); scanf(\"%s\", s + 1); for(int i = 0; i &lt;= n; i++) f[i][1] = 1; for(int len = 2; len &lt;= n + 1; len++)&#123; for(int i = 0; i &lt;= n; i++)&#123; memset(used, false, sizeof(used)); for(int j = i + 1; j &lt;= n; j++) if(!used[s[j] - 'a'])&#123; used[s[j] - 'a'] = true; f[i][len] += f[j][len - 1]; f[i][len] = std::min(f[i][len], k); &#125; &#125; &#125; ll ans = 0; for(int i = n; i &gt;= 0; i--)&#123; ll sum = f[0][i + 1]; memset(used, false, sizeof(used)); if(k &gt; sum)&#123; k -= sum; ans += (n - i) * sum; &#125; else &#123; ans += (n - i) * k; k = 0; &#125; &#125; if(k &gt; 0)&#123; printf(\"-1\\n\"); return 0; &#125; printf(\"%lld\\n\", ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"}]},{"title":"题解 CF240F TorCoder","slug":"Solutions/Solution-CF240F","date":"2019-06-03T12:53:00.000Z","updated":"2019-06-03T13:22:12.000Z","comments":true,"path":"2019/06/03/Solutions/Solution-CF240F/","link":"","permalink":"https://dilute.xyz/2019/06/03/Solutions/Solution-CF240F/","excerpt":"线段树乱搞考虑如果要重排一段区间使得它是回文的是可行的 首先对这段区间的长度分类讨论","text":"线段树乱搞考虑如果要重排一段区间使得它是回文的是可行的 首先对这段区间的长度分类讨论 如果它的长度是奇数，那么在这个区间的数肯定满足以下条件： 有一个字母出现了奇数次（这个放在最中间） 其他的出现了偶数次（放在旁边） 如果它的长度是偶数，那么这个区间内出现过的数肯定都出现过了偶数次 再考虑如何构造 如果长度是奇数，把那个出现了奇数次的数放一个在最中间 枚举A~Z，从最左和最右分别开始一直放（因为需要保证字典序最小） 容易发现这只需要线段树维护区间每个字母的出现次数就行了（也可以理解成26棵线段树） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define lc(a) ((a) &lt;&lt; 1)#define rc(a) ((a) &lt;&lt; 1 | 1)int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;struct SEG&#123; int l; int r; int sum[30]; int lazy; void clear()&#123; memset(sum, 0, sizeof(sum)); &#125;&#125;;int cnt[30];char s[100010];SEG operator + (SEG a, SEG b)&#123; if(a.l == -1) return b; if(b.l == -1) return a; SEG ret; ret.l = a.l; ret.r = b.r; for(int i = 0; i &lt; 26; i++) ret.sum[i] = a.sum[i] + b.sum[i]; return ret;&#125;struct SEG_Tree&#123; SEG t[800010]; void push_up(int cur)&#123; for(int i = 0; i &lt; 26; i++) t[cur].sum[i] = t[lc(cur)].sum[i] + t[rc(cur)].sum[i]; &#125; void build(int cur, int l, int r)&#123; t[cur].lazy = -1; t[cur].l = l; t[cur].r = r; if(l == r)&#123; t[cur].clear(); t[cur].sum[s[l] - 'a'] = 1; return ; &#125; int mid = (l + r) &gt;&gt; 1; build(lc(cur), l, mid); build(rc(cur), mid + 1, r); push_up(cur); &#125; void push_down(int cur)&#123; if(t[cur].lazy != -1)&#123; t[lc(cur)].clear(); t[rc(cur)].clear(); t[lc(cur)].sum[t[cur].lazy] = t[lc(cur)].r - t[lc(cur)].l + 1; t[rc(cur)].sum[t[cur].lazy] = t[rc(cur)].r - t[rc(cur)].l + 1; t[lc(cur)].lazy = t[rc(cur)].lazy = t[cur].lazy; &#125; t[cur].lazy = -1; &#125; void query(int cur, int l, int r)&#123; SEG nul; nul.l = -1; if(t[cur].l &gt; r || t[cur].r &lt; l) return ; push_down(cur); if(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)&#123; for(int i = 0; i &lt; 26; i++) cnt[i] += t[cur].sum[i]; return ; &#125; query(lc(cur), l, r); query(rc(cur), l, r); &#125; void modify(int cur, int l, int r, int c)&#123; if(t[cur].l &gt; r || t[cur].r &lt; l) return ; if(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)&#123; t[cur].clear(); t[cur].sum[c] = t[cur].r - t[cur].l + 1; t[cur].lazy = c; return ; &#125; push_down(cur); modify(lc(cur), l, r, c); modify(rc(cur), l, r, c); push_up(cur); &#125; void print(int cur)&#123; if(t[cur].l == t[cur].r)&#123; for(int i = 0; i &lt; 26; i++) if(t[cur].sum[i]) putchar('a' + i); return ; &#125; push_down(cur); print(lc(cur)); print(rc(cur)); &#125;&#125;t;int main()&#123; freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout); int n = inp(); int q = inp(); scanf(\"%s\", s + 1); t.build(1, 1, n); while(q--)&#123; int l = inp(); int r = inp(); memset(cnt, 0, sizeof(cnt)); t.query(1, l, r); if((r - l + 1) &amp; 1)&#123; int cs = 0, num; for(int i = 0; i &lt; 26; i++) if(cnt[i] &amp; 1)&#123; cs++; num = i; &#125; if(cs == 1)&#123; int mid = (l + r) &gt;&gt; 1; t.modify(1, mid, mid, num); int cc = 0; for(int i = 0; i &lt; 26; i++)&#123; if(cnt[i] &lt;= 1) continue; int c2 = cc + (cnt[i] &gt;&gt; 1); t.modify(1, l + cc, l + c2 - 1, i); t.modify(1, r - c2 + 1, r - cc, i); cc = c2; &#125; &#125; &#125; else &#123; int cs = 0, num = -1; for(int i = 0; i &lt; 26; i++) if(cnt[i] &amp; 1)&#123; cs++; num = i; &#125; if(cs == 0)&#123; int cc = 0; for(int i = 0; i &lt; 26; i++)&#123; if(cnt[i] == 0) continue; int c2 = cc + (cnt[i] &gt;&gt; 1); t.modify(1, l + cc, l + c2 - 1, i); t.modify(1, r - c2 + 1, r - cc, i); cc = c2; &#125; &#125; &#125; &#125; t.print(1); putchar('\\n');&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://dilute.xyz/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"https://dilute.xyz/tags/线段树/"}]},{"title":"题解 CF1051E Vasya and Big Integers","slug":"Solutions/Solution-CF1051E","date":"2019-05-28T11:12:00.000Z","updated":"2019-05-28T11:45:42.000Z","comments":true,"path":"2019/05/28/Solutions/Solution-CF1051E/","link":"","permalink":"https://dilute.xyz/2019/05/28/Solutions/Solution-CF1051E/","excerpt":"哈希 + 二分 + DP首先看到题面，很容易想到一个$DP$，令$f[i]$为划分到$i$为止的方案数。 然后朴素的暴力转移是$O(n^2)$的，非常显然一个状态$i$能够转移到的$j$是一段连续的，进而想到使用前缀和优化。","text":"哈希 + 二分 + DP首先看到题面，很容易想到一个$DP$，令$f[i]$为划分到$i$为止的方案数。 然后朴素的暴力转移是$O(n^2)$的，非常显然一个状态$i$能够转移到的$j$是一段连续的，进而想到使用前缀和优化。 令$l$的长度为$sl$，$r$的长度为$sr$，那么长度为$len$（$sl &lt; len &lt; sr$）的一段数字$s$必定满足$l &lt; s &lt; r$。然后那么我们只需要考虑当前状态$i$的时候$[i, i + sl)$和$[i,i + sr)$这两段区间分别和$l,r$的大小关系。 如果我们我们要比较两个字符串$a$和$b$的大小关系，我们完全先特判掉两个完全一样的情况，然后再求出它们的$lcp$，然后那么$a$和$b$的大小关系就是$a[lcp + 1]$和$b[lcp + 1]$的大小关系了。 $lcp$可以哈希 + 二分解决，接下来的事情就是$DP$的了 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define mod 998244353#define px 11#define mul(a, b) ((ll)(a) * (ll)(b) % mod)int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;char s[1000010], l[1000010], r[1000010];ll f[1000010], sum[1000010];int n, sl, sr, pl[1000010], pr[1000010], hshs[1000010], hshl[1000010], hshr[1000010], fpow[1000010];bool ok1(int x)&#123; if(x + sl - 1 &gt; n) return false; if(sl == pl[x]) return true; return l[pl[x] + 1] &lt; s[x + pl[x]];&#125;bool ok2(int x)&#123; if(x + sr - 1 &gt; n) return false; if(pr[x] == sr) return true; return r[pr[x] + 1] &gt; s[x + pr[x]];&#125;int get_hsh(int *hsh, int l, int r)&#123; return (hsh[r] - mul(hsh[l - 1], fpow[r - l + 1]) + mod) % mod;&#125;void solve(int *s, int *hsh, int len)&#123; // 求lcp for(int i = 1; i &lt;= n - len + 1; i++)&#123; int l = 0; int r = len; while(l &lt; r)&#123; int mid = (l + r + 1) &gt;&gt; 1; if(get_hsh(hshs, i, i + mid - 1) == get_hsh(hsh, 1, mid)) l = mid; else r = mid - 1; &#125; s[i] = l; &#125;&#125;void gethash(char *str, int *hsh, int len)&#123; for(int i = 1; i &lt;= len; i++) hsh[i] = ((ll)(hsh[i - 1]) * (ll)(px) + str[i] - '0' + 1) % mod;&#125;int main()&#123; fpow[0] = 1; for(int i = 1; i &lt;= 1000000; i++) fpow[i] = mul(fpow[i - 1], px); scanf(\"%s\", s + 1); scanf(\"%s\", l + 1); scanf(\"%s\", r + 1); n = strlen(s + 1); sl = strlen(l + 1); sr = strlen(r + 1); gethash(l, hshl, sl); gethash(r, hshr, sr); gethash(s, hshs, n); f[0] = 1; solve(pl, hshl, sl); solve(pr, hshr, sr); // for(int i = 1; i &lt;= n; i++) // printf(\"%d \", pl[i]); // putchar('\\n'); // for(int i = 1; i &lt;= n; i++) // printf(\"%d \", pr[i]); // putchar('\\n'); for(int i = 0; i &lt;= n; i++)&#123; if(i)&#123; sum[i] += sum[i - 1]; f[i] += sum[i]; f[i] %= mod; &#125; // printf(\"f[%d] = %d\\n\", i, f[i]); if(s[i + 1] == '0')&#123; if(sl == 1 &amp;&amp; l[1] == '0')&#123; f[i + 1] += f[i]; f[i + 1] %= mod; &#125; continue; &#125; if(sl &lt; sr)&#123; sum[sl + i + 1] += f[i]; sum[sl + i + 1] %= mod; sum[sr + i] += mod - f[i]; sum[sr + i] %= mod; &#125; if(sl == sr)&#123; if(ok1(i + 1) &amp;&amp; ok2(i + 1))&#123; f[i + sl] += f[i]; f[i + sl] %= mod; &#125; &#125; else &#123; if(ok1(i + 1))&#123; f[i + sl] += f[i]; f[i + sl] %= mod; &#125; if(ok2(i + 1))&#123; f[i + sr] += f[i]; f[i + sr] %= mod; &#125; &#125; // printf(\"f[%d] = %d\\n\", i, f[i]); &#125; std::cout &lt;&lt; f[n] &lt;&lt; std::endl;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"},{"name":"哈希","slug":"哈希","permalink":"https://dilute.xyz/tags/哈希/"},{"name":"二分","slug":"二分","permalink":"https://dilute.xyz/tags/二分/"}]},{"title":"题解 CF15D Map","slug":"Solutions/Solution-CF15D","date":"2019-05-08T02:18:00.000Z","updated":"2020-02-13T06:00:04.000Z","comments":true,"path":"2019/05/08/Solutions/Solution-CF15D/","link":"","permalink":"https://dilute.xyz/2019/05/08/Solutions/Solution-CF15D/","excerpt":"$set$ 瞎搞首先非常显然，一个矩形$(x1, y1, x2, y2)$的代价就是$\\displaystyle\\sum_{i = x1}^{x2}\\sum_{j = y1}^{y2} h[i][j] - \\min_{x1 \\le i \\le x2, y1 \\le j \\le y2} h[i][j]$，我们用$f[i][j]$表示以$(i, j)$为左上角的矩形的代价。即矩形$(i, j, i + a - 1, j + b - 1)$的代价。 我们首先考虑如何求出$f[i][j]$。","text":"$set$ 瞎搞首先非常显然，一个矩形$(x1, y1, x2, y2)$的代价就是$\\displaystyle\\sum_{i = x1}^{x2}\\sum_{j = y1}^{y2} h[i][j] - \\min_{x1 \\le i \\le x2, y1 \\le j \\le y2} h[i][j]$，我们用$f[i][j]$表示以$(i, j)$为左上角的矩形的代价。即矩形$(i, j, i + a - 1, j + b - 1)$的代价。 我们首先考虑如何求出$f[i][j]$。 前面的求和可以一个二维前缀和简单解决，关键在于后面的$\\min$。 我们对每行都建一个$st$表，考虑我们把当前我们要求的区间里的$h[i][j]$都丢进一个$set$中。 我们考虑每次把矩形往下移动。 发现其实对于每一行，只有它的在范围内的最小值才有贡献，所$set$中只需要放每行的最小值（可以用$st$表快速查询）。 我们再考虑如下图所示。 然后如果我们要从蓝色矩形移动到黑色矩形，那么我们只需要在$set$中删去灰色部分的最小值，再加入浅蓝色部分的最小值即可。 求出了$f[i][j]$之后就可以按题意模拟了w 每次我们可以找出$f[i][j]$的最小值，这个排遍序轻松解决（我之前作死用set被卡常了）然后给所有因为这个矩形被取到了导致不能取的打上标记，这样子时间复杂度是正确的，最多只会被取到$\\frac{n m}{ab}$个矩形，然后每次打标记是$O(a * b)$的，最后复杂度就是$O(\\frac{n m}{a b} a b) = O(n m)$的。 复杂度$O(n m \\log n)$，轻微卡常w 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;int f[1010][1010][12];std::multiset&lt;ll&gt; s2;int ans1[1000010], ans2[1000010], h[1010][1010];ll ans3[1000010], sum[1010][1010], val[1010][1010];bool used[1010][1010];std::pair&lt;int, int&gt; s[1000010];ll query(int x, int l, int r)&#123; int lg = log2(r - l + 1); return std::min(f[x][l][lg], f[x][r - (1 &lt;&lt; lg) + 1][lg]);&#125;bool cmp(std::pair&lt;int, int&gt; a, std::pair&lt;int, int&gt; b)&#123; if(val[a.first][a.second] == val[b.first][b.second]) return a &lt; b; return val[a.first][a.second] &lt; val[b.first][b.second];&#125;int main()&#123; int n = inp(); int m = inp(); int a = inp(); int b = inp(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) f[i][j][0] = h[i][j] = inp(); for(int i = 1; i &lt;= n; i++) for(int u = 1; u &lt;= 10; u++) for(int j = 1; j &lt;= m; j++) if(j + (1 &lt;&lt; u) - 1 &lt;= m) f[i][j][u] = std::min(f[i][j][u - 1], f[i][j + (1 &lt;&lt; (u - 1))][u - 1]); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + h[i][j]; for(int j = 1; j &lt;= m - b + 1; j++)&#123; s2.clear(); for(int i = 1; i &lt;= a; i++) s2.insert(query(i, j, j + b - 1)); for(int i = 1; i &lt;= n - a + 1; i++)&#123; val[i][j] = sum[i + a - 1][j + b - 1] + sum[i - 1][j - 1] - sum[i + a - 1][j - 1] - sum[i - 1][j + b - 1] - (*(s2.begin())) * (a * b); s2.erase(s2.find(query(i, j, j + b - 1))); if(i + a &lt;= n) s2.insert(query(i + a, j, j + b - 1)); &#125; &#125; int cc = 0; for(int i = 1; i &lt;= n - a + 1; i++) for(int j = 1; j &lt;= m - b + 1; j++) s[++cc] = std::make_pair(i, j); std::sort(s + 1, s + cc + 1, cmp); int cnt = 0; for(int u = 1; u &lt;= cc; u++)&#123; if(used[s[u].first][s[u].second]) continue; cnt++; ans1[cnt] = s[u].first; ans2[cnt] = s[u].second; ans3[cnt] = val[s[u].first][s[u].second]; for(int i = ans1[cnt] - a + 1; i &lt;= ans1[cnt] + a - 1; i++) for(int j = ans2[cnt] - b + 1; j &lt;= ans2[cnt] + b - 1; j++) if(i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; !used[i][j] &amp;&amp; i &lt;= n - a + 1 &amp;&amp; j &lt;= m - b + 1) used[i][j] = true; &#125; printf(\"%d\\n\", cnt); for(int i = 1; i &lt;= cnt; i++) printf(\"%d %d %I64d\\n\", ans1[i], ans2[i], ans3[i]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://dilute.xyz/tags/数据结构/"}]},{"title":"ZJOI2019 游记","slug":"Other/ZJOI2019-Journey","date":"2019-04-27T06:41:00.000Z","updated":"2019-05-01T11:36:20.000Z","comments":true,"path":"2019/04/27/Other/ZJOI2019-Journey/","link":"","permalink":"https://dilute.xyz/2019/04/27/Other/ZJOI2019-Journey/","excerpt":"Round 1咕咕咕。 回头再补。","text":"Round 1咕咕咕。 回头再补。 Day 0咕咕咕 Day 1咕咕咕 Day 2咕咕咕 Day 3比赛日。 密码暗示JYB政策？（河蟹警告） 不管了 题最重要 还没解压密码的时候就看到有一题文件名叫做$mahjong$。 打开题面，第一反应八木唯好可爱啊awsl 我想着这个暴力应该不会太难敲（flag × 1）于是就开始敲这个T1 后来发现其实很大的一个瓶颈在于判断和牌，本来想法的“瞎jb判不就行了吗”被频繁$hack$，最后权衡再三写了个肯定对但是难敲的要死的5进制状压每种牌的数量。 Day (懒得算)出成绩惹。。。 果然T1挂掉了 以后再也不敢开麻将斗地主一类的毒瘤题了。。。 最终成绩的$0 + 20 + 10 = 30\\ pts$ Round 2Day 0颓废了一个上午，中午跟同学一起叫外卖肯德基结果发现就自己没有汉堡？？？只能吃点其他东西垫着算了。 接着坐车到了余姚中学。 然后又跟xay5421 _QAQ LJC00118三个神仙打了一下午 + 晚上mc。 Day 1早上听讲课，日常听不懂，跟好久不见的Venus小姐姐面基了。结果她就直接坐在我旁边了，讲课的时间就在各种花式听不懂 + 颓废中度过了。 晚上zxy_hhhh想找我打LOL，结果我电脑容量太小了，装不下，于是他们去找_QAQ去了。 于是又打了一个晚上的MC，还顺便看了看盾勇没网上说的那么糟糕啊 Day 2上午我校高三巨野讲课，然而还是那样听不太懂，中午吃完饭，回到礼堂，zxy_hhhh看到地上躺着一个人，惊呼 艹这不是Venus吗 后面xxc（吹雪吹雪吹）做了一些奇奇怪怪的事情就不说了。 回到宾馆，_QAQ的LOL下好了，于是_QAQ，Sooke，Venus，zxy_hhhh和一个不知道网名的学长就开始五黑了。然后我就在_QAQ的房间里看他打。 _QAQ拿了个剑圣正常地打了半把，LJ开始查房了。当时LJ查到他们房间的时候，_QAQ打LOL被石锤了，LJ还说 撸啊撸我不认识啊？ 然后_QAQ跟啥都没发生一样继续打了。 结果他们就因为LJ查房输了。 _QAQ后来开始玩快乐瑞兹，这里我整理一下他的语录。 你瑞兹爸爸来了！（0/12/1） 啊～诺手鸽鸽带带我～诺手鸽鸽～ 我觉得我能秒掉他！ 这瑞兹是什么垃圾英雄！ 据某位不愿透露姓名的认识表示他的瑞兹连招QAAAAAA Day 3比赛日。 进考场，开题。 解压包密码看不懂还贼难输考场老师还写错了一次，输错*n，心情极差。 看到这个T1，一眼看出应该是个状压DP之类做的暴力，但是显然这玩意是有后效性的，所以必须得加个高斯消元，暴力复杂度是$O(8^n)$的，只能过$n \\leq 8$的点，可可能优化之后是个治疗之雨状物？不知道，但是看上去不太好做的样子，所以先跳过。 一看T2，这题一看就比T1清真多了。一个显然的结论是一个点对$(a, b)$是合法的当且仅当存在给出的路径$c, d$包含$a, b$这条路径。枚举其中一个点，然后我们考虑所有穿过当前枚举的点$a$的给出路径，显然只有这些路径上的点是合法的，然后这么写就可以得到$O(n^2)$的优秀复杂度。链的情况非常好想，再花了点时间写了个对拍，直接$40 + 20 = 60$分到手。 之后试着想了想T2的正解，觉得可能是个树链剖分 + 容斥之类的玩意儿，反正我想不出来，滚粗。 接下来开T3，看上去像个类斜率优化之类的奇怪玩意儿，显然可以把每个人看成一根线段，那么反向选拔度就是横坐标。首先把$a_j \\geq a_i, b_j \\geq b_i​$的人提前判掉，因为他们是不可能被超过的。可以想到一个人分数比另一个人高可以表示为一个交点，换句话说也可以吧表示为一个约束条件。 约束条件只有$x \\leq k$和$x \\geq k​$两种。我们枚举第一种满足多少个，就可以得出第二种满足多少个，那么就可以得出一个人最多超过多少人，换句话说就是一个人的最高排名。 这时比赛还剩1个小时，虽然T3的$m = 1$部分分直接一个凸壳解决，但是只有$10$分并且也不好敲，我决定还是去做$T1$。 $T1​$的方程列错了n次，最后开始写高消的时候一个小时已经过去一半了，最后都没过$n = 8​$的样例。没办法，手动推了个$n = 2​$的柿子交上去滚粗了。 期望得分$20 + 60 + 40 = 120\\ pts​$ Day （懒得算）出成绩惹…最终得分$20 + 40 + 40 = 100\\ pts$ 我T2的链都打挂了，我果然太菜了嘤","categories":[{"name":"游记","slug":"游记","permalink":"https://dilute.xyz/categories/游记/"}],"tags":[{"name":"瞎写","slug":"瞎写","permalink":"https://dilute.xyz/tags/瞎写/"}]},{"title":"题解 CF609F Frogs and mosquitoes","slug":"Solutions/Solution-CF609F","date":"2019-04-22T14:27:00.000Z","updated":"2019-04-22T14:55:14.000Z","comments":true,"path":"2019/04/22/Solutions/Solution-CF609F/","link":"","permalink":"https://dilute.xyz/2019/04/22/Solutions/Solution-CF609F/","excerpt":"set​瞎搞预处理我们考虑一下，一只青蛙能够影响的区间是什么 我们发现，如果将每只青蛙能够吃到的文字区间$[l, r]$按照左端点$l$排序，然后把后面的区间和前面的区间的重复部分去掉，那么就可以得到一个青蛙真正可以吃到的蚊子的范围区间","text":"set​瞎搞预处理我们考虑一下，一只青蛙能够影响的区间是什么 我们发现，如果将每只青蛙能够吃到的文字区间$[l, r]$按照左端点$l$排序，然后把后面的区间和前面的区间的重复部分去掉，那么就可以得到一个青蛙真正可以吃到的蚊子的范围区间 我觉得下面这张图讲的很清楚w 好，那么我们的预处理就这么完了。 加入蚊子我们采用$set​$维护所有青蛙能够真正吃到的蚊子的范围区间，那么在加入一只蚊子的时候，可以lower_bound快速求出这只蚊子会不会被吃掉，如果它被吃掉了，是被哪只青蛙吃掉了。 显然，如果一只蚊子被吃掉了，那么吃掉它的哪只青蛙和其他青蛙可以吃到的蚊子的范围区间都会变化，那么我们只要从当前更新过的哪只青蛙的范围向后找，把所有被当前区间所包含的区间全都删除，最后再调整一下没有被完全覆盖的区间的左端点。 还有一点这道题有一个非常恶心的设定：蚊子如果没有被吃掉，它会待在原地，直到被某只青蛙吃掉为止。 这让我们再用一个$set$维护当前没有被吃掉的蚊子，然后在前面吃掉一只蚊子，区间变长的时候，在储存蚊子的那个$set$里面lower_bound一下判断是否能够再吃掉其他的蚊子，等确定没有蚊子可吃的时候再去判断后面的区间是否被更新。 代码我实现的丑的要命，反正跑得过去就行，轻喷… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;struct Node&#123; int l; int r; int id; bool operator &lt; (const Node &amp;b) const &#123; if(l == b.l) return r &gt; b.r; return l &lt; b.l; &#125;&#125;;std::set&lt;Node&gt; s;std::multiset&lt;std::pair&lt;int, int&gt; &gt; s2;int ans[200010], x[200010], t[200010], p[200010], b[200010];std::set&lt;Node&gt;::iterator operator + (std::set&lt;Node&gt;::iterator it, const int &amp;b)&#123; it++; return it;&#125;std::set&lt;Node&gt;::iterator operator - (std::set&lt;Node&gt;::iterator it, const int &amp;b)&#123; it--; return it;&#125;int id[200010];bool cmp(int a, int b)&#123; return x[a] &lt; x[b];&#125;int main()&#123; int n = inp(); int m = inp(); for(int i = 1; i &lt;= n; i++)&#123; x[i] = inp(); t[i] = inp(); id[i] = i; &#125; std::sort(id + 1, id + n + 1, cmp); s.insert((Node)&#123;x[id[1]], x[id[1]] + t[id[1]], id[1]&#125;); for(int i = 2; i &lt;= n; i++) if(std::max(s.rbegin()-&gt;r + 1, x[id[i]]) &lt;= x[id[i]] + t[id[i]]) s.insert((Node)&#123;std::max(s.rbegin()-&gt;r + 1, x[id[i]]), x[id[i]] + t[id[i]], id[i]&#125;); for(int i = 1; i &lt;= m; i++)&#123; p[i] = inp(); b[i] = inp(); std::set&lt;Node&gt;::iterator it = s.upper_bound((Node)&#123;p[i], p[i]&#125;); it--; if(it-&gt;r &gt;= p[i] &amp;&amp; it-&gt;l &lt;= p[i])&#123; t[it-&gt;id] += b[i]; ans[it-&gt;id]++; Node nxt = *it; s.erase(it); s.insert((Node)&#123;nxt.l, nxt.r + b[i], nxt.id&#125;); it = s.find((Node)&#123;nxt.l, nxt.r + b[i], nxt.id&#125;); std::multiset&lt;std::pair&lt;int, int&gt; &gt;::iterator it2 = s2.lower_bound(std::make_pair(it-&gt;l, 1)); while(it2 != s2.end() &amp;&amp; it2-&gt;first &lt;= it-&gt;r)&#123; t[it-&gt;id] += it2-&gt;second; ans[it-&gt;id]++; Node nxt = *it; s.erase(it); s.insert((Node)&#123;nxt.l, nxt.r + it2-&gt;second, nxt.id&#125;); it = s.find((Node)&#123;nxt.l, nxt.r + it2-&gt;second, nxt.id&#125;); s2.erase(it2); it2 = s2.lower_bound(std::make_pair(it-&gt;l, 1)); &#125; while((it + 1) != s.end() &amp;&amp; it-&gt;r &gt;= (it + 1)-&gt;r) s.erase(it + 1); if((it + 1) != s.end())&#123; Node nxt = *(it + 1); s.erase(it + 1); s.insert((Node)&#123;std::max(nxt.l, it-&gt;r + 1), nxt.r, nxt.id&#125;); &#125; &#125; else s2.insert(std::make_pair(p[i], b[i])); &#125; for(int i = 1; i &lt;= n; i++) printf(\"%d %d\\n\", ans[i], t[i]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://dilute.xyz/tags/数据结构/"}]},{"title":"OI Journal","slug":"Other/Problems","date":"2019-04-18T13:27:00.000Z","updated":"2022-08-19T02:52:28.000Z","comments":true,"path":"2019/04/18/Other/Problems/","link":"","permalink":"https://dilute.xyz/2019/04/18/Other/Problems/","excerpt":"看到学长txc爷的blog里写了个“最近写的题目” 然后心血来潮准备自己也弄个这个东西","text":"看到学长txc爷的blog里写了个“最近写的题目” 然后心血来潮准备自己也弄个这个东西 2019.11.3Codeforces 557I发现 BIT 可以实现平行四边形修改（把坐标系扭转一下，也就是把 $(x ,y)$ 映射到 $(x , x + y)$），考虑在超过边界的时候平行四边形可以被认为是一个直角梯形。直角梯形加，矩形减，用二维 BIT 维护，就能达到三角形加的效果。 2019.11.2Codeforces 997E考虑题目中要求的子串满足 $\\max - \\min = r - l$，把询问离线下来，枚举右端点，维护 $(\\max - \\min) - (r - l)= 0$ 的个数，本质就是维护最小值出现次数，注意打标记实现前缀和统计。 2019.11.1Codeforces 585E枚举前一半数的 $\\gcd$ ，那么先算前一半数必须要在 $\\gcd$ 的倍数中取，后面的数不在 $\\gcd$ 的倍数中取的方案数，然后容斥，发现容斥系数正好是 $\\mu$ ，证明可以感性理解（捂脸）。 2019.10.31Codeforces 587D前来膜拜一波神仙学长 txc 的集训队作业。 对于每个点，如果连着他的一条边被割了，那么与之相连的其他边都不能被割。 对于每个点连着的边的每种颜色，如果其中一条边没有被割，其他边都必须被割。 二分 + 前后缀和优化建图 + 2-SAT 即可。 2019.10.21Codeforces 576D对于每个存在某个航班从不可用到可用的分界点专门拿出来考虑。 中间可以用 floyd + 矩阵乘法 维护每个点可不可以在这个时刻到达，可以用bitset优化。 对于每个分界点跑一遍多源最短路即可。 2019.10.20Codeforces 1239C使用一个堆维护下一个发生的事件即可。 2019.10.12Codeforces 954I$\\Theta(6^2)$ 的枚举两个字符，然后发现如果在这个子串中存在 $s[i] \\neq t[i]$ 则表示有必要把 $s[i]$ 和 $t[i]$ 两种字符合并，存不存在可以写成卷积性质然后 FFT / NTT 解决，后半部分可以并查集。 2019.10.8Codeforces 573E发现肯定存在一个分界点，左边不取，右边去，然后就可以平衡树维护了。严格证明在这篇题解里有。 2019.10.3Codeforces 1172D$\\color{black}{\\text{S}}\\color{red}{\\text{ooke}}$ 跟我讨论怎么出题。 结果 $\\color{black}{\\text{S}}\\color{red}{\\text{ooke}}$ 一句「你做过Portals没」就把话题变成了Portals做法讨论了…… 在 $(x,1)$ 和 $(y,1)$ 放一对传送门，满足 $r[x] = 1, r[y] = 1$，这样子 $x$ 和 $y$ 一行一列就解决了，然后递归即可。 2019.9.26BZOJ 3416倒过来做，每次选择一段连续的区间即可。 2019.9.25Codeforces 568E由于是严格的LIS，所以每个数只能填一遍跟没有一样，然后用正常的$\\Theta(n \\log n)$ LIS，做到gap的时候就枚举取哪个数，复杂度$\\Theta(mk + n \\log n)$，还是比较松的。 BZOJ 3427为什么POI全是权限题 发现最优解的每个元素$\\in {-1, 0, 1}$，然后瞎dp就可以了。 2019.9.23Codeforces 555E将原图中所有边双都拎出来，这些是可以做到强连通的。 拎出来之后就是树了，一条路径上一半设为向上另一半向下，判断有无矛盾即可。 2019.9.22Codeforces 1221F枚举矩形右端点，将左端点的每一个可能取值用线段树维护一下即可。 Luogu4768 [NOI2018]归程$\\text{Kruscal}$重构树… 跑出$1$到每个点的最段路之后就可以搞了。 Luogu4197 Peaks还是$\\text{Kruscal}$重构树…… 把询问最小值改成第$k$大即可。 2019.9.21CometOJ #11 D$\\text{Kruscal}$重构树。 询问的是整一棵重构树上的子树的积。 但是因为$0$的存在，不能树状数组，必须线段树。 比赛的时候写了个$O(n \\sqrt n \\log n)$的莫队结果过不去。 最后半个小时的时候改写正解喜提$\\text{rush}$失败，心情极差。 2019.9.19Codeforces 555D每次二分当前这玩意儿可以掼到哪里，注意加一个如果两次掼回去的话可以直接取模，这样每次至少减少一半就是$O(n \\log^2 n)$的了。 2019.9.18Codeforces 1209F不美好的回忆$\\times 2$… 虽然我打的很臭但是这场的题还是蛮有意思的… 先拆点，然后建出最短路$\\text{DAG}$之后分层贪心取，细节很多… 2019.9.17Codeforces 1209E2不美好的回忆… E1的基础之上（$f[i][j]$表示枚举到第$i$列，状态为$j$的行的最大值已经被确定）状压之后记录一下对于当前列，每个状态可以达到的最大和优化DP，并且注意只取$max$值最大的$n$列。 2019.9.16Codeforces 1215F前一天CF的F题。 建出$M$个点，代表$f \\le i$是否成立，建图十分神仙，最后$2-SAT$即可。 Sooke txdy 2019.9.14Codeforces 553D二分答案，得出对于每个点，最少有多少个被选中的点和他相邻，然后每次把已经不可能选进的点给删掉即可。 2019.9.13Codeforces 547D对于每条横着 / 竖着的线，两两配对连边之后跑黑白染色即可。 2019.9.11Codeforces 536E树剖裸题。 2019.9.10Codeforces 536D直接把每个点转换为坐标为$\\left(dis(s, i), dis(t, i)\\right)$的点，然后就可以DP了。 2019.9.9Codeforces 528D把$t$串反过来，是否满足条件的柿子转成卷积形式后NTT即可。 2019.9.6Codeforces 521D先把赋值操作转换成加操作，再把加改成乘，因为对于一个数上加的顺序是固定的，贪心即可。 打了场CometOJ。 这C题难度实在超标。 虽然做完之后发现不难但是我就是愣是没想到$(x, x + 1) = 1$然后就可以$O(2^{\\text{质因数个数}})$暴力枚举了艹。 似乎是打CometOJ以来rk最高的一次（雾）毕竟我之前打的两场都是打到一半回家了（大雾） 顺便把标题改了下 2019.9.5Codeforces 516D令$f(x)$为离$x$最远的点离$x$的距离。 两边$dfs$之后以$f(x)$最小的点为根，可以证明$\\forall x\\ f(x) \\geq f(fa(x))$，倍增即可。 2019.9.4Codeforces 512E想办法把两个状态变成一个$(1, 3), (1, 4) … (1, n - 1)$的三角剖分，一个正着做一个倒着做即可。 打了场CF。 $zxyhh$和$Sooke$讨论了半个小时$F$，得出了一个优秀的假做法。 我和$Sooke$讨论了半个小时$H$，得出了一个优秀的假做法，赛后问$Isonan$爷发现距离正解仅仅差一个无解判断。 2019.9.3Codeforces 506D先用unordered_map​维护$n$个并查集，把每个联通块拎出来做根号分治即可。 Codeforces 512D删掉环，他就是一个树形DP，连着环的可以直接做，没连环的枚举最后一个取了哪个点。 2019.9.2Codeforces 504D高精线性基。 懒得写了（大雾） Codeforces 504E倍增 + 哈希维护一条链上的哈希值。 由于是倍增所以不用二分，是$O(\\log n)$的。 口胡完事（大雾） 都怪Sooke疯狂怂恿我口胡（大雾） Codeforces 505D对于一个联通块，如果有环，贡献为$size - 1$否则贡献为$size$。 我以为这是1D，做到一半：这真的是1D吗，然后去看了一下发现是2D 2019.9.1一不小心就咕咕咕了3个月了… 都是高中生！怎么能这么咕咕咕！（这就是你晚自修跑出来玩电脑的理由？） 我要重新开始！ 从现在的开始要反一下….越往上越新 之前的就懒得改了…反正也没什么人看这只菜鸡的blog 现在开始准备模仿zxyhh神仙每次随机找$\\texttt{Codeforces}$的Div1 D E做了。 Codeforces 498D直接在$\\mod 60$意义在进行，线段树维护。 完整题解 Codeforces 498E状压维护竖着的杆子存在与否。 同一种颜色中间用矩乘加速。 2019.4.18CF321E Ciel and Gondolas今天的考试题 一道神奇的斜率优化 考场上随便打的暴力艹过去了，CF上特判了一组数据就过了 CF1154F Shovels Shop傻逼背包题，昨天Div3的时候特别智障的看错题意导致没切、 我果然太菜了 CF219E Parking Lot细节题。 用两个珂朵莉树状物维护一下连续的空段就行了。 2019.4.19昨天23:35到今天1:35打了一场CF，还行，小号上紫成功w （这出题人B题放码农题然后CDE三道傻逼题算什么意思啊） CF895E Eyes Closed用线段树简单维护一下每个点的期望值 有点奇奇怪怪 容易写挂（又是细节题） CF442D Adam and Tree每次暴力向根更新+DP+剪枝是正确的。 因为答案最大是$\\log$的（树剖），所以封顶$n \\log n$ CF1154G Minimum Possible LCM淦 前天Div 3怎么全都是水题 直接用桶存一下数字然后再调和级数$O(10^7 \\ln 10^7)$枚举即可。 CF311D Interval Cubing奇奇怪怪的找规律 + 线段树 发现所有数都在$48$的时候形成循环，然后再用线段树打标记维护一下。 2019.4.21CF746F Music in Car又双叒叕是细节题 用两个$set$维护一下整首播放的和半首播放的即可。 其实这sb题我22号才调出来的 但是我看21号没做其他题就放过来的 2019.4.22CF176E Archaeology | LOJ #10132. 「一本通 4.4 例 3」异象石结论：把需要求的点个按照$DFS$序排个序，设得到的序列为$s_1, s_2, s_3 … s_m$那么这个时候的答案就是$\\frac{\\sum\\limits_{i = 1}^{m - 1}dis(s_i, s_{i + 1}) + dis(s_1, s_m)}{2}$，然后再用$set$维护$s$，和$\\sum\\limits_{i = 1}^{m - 1}dis(s_i, s_{i + 1})$然后把$dis(s_1, s_m)$单独拎出来，询问的时候加上就行了。 CF609F Frogs and mosquitoes怎么又双叒叕是set 整天就知道set, set 我看CF你这个OJ就像个set 用两个set维护青蛙能影响的区间和未被吃掉的问题 完整题解：&gt;Here&lt; 2019.4.24 ~ 4.27ZJOI期间，只打了一场CF，其他啥都没写 帮可爱的xay5421写了1个小时的假算法 2019.4.28ZJOI2019爆完0回来了。 CF295E Yaroslav and Points不用离散化，算出$[l, r]$之间每个点的贡献。 直接用$fhq\\ treap$ 维护一个区间的答案，滋瓷插入和删除即可。 CF542A Place Your Ad Here首先枚举电视台。 钦点当前这个区间跟左边/右边其中一边不接触，用ST表维护一下区间内最右边/左边的点，然后特判一下广告区间包含电视台的区间的情况即可。 2019.4.29CF618E Robot Arm线段树 + 计算几何。 线段树区间$[l, r]$维护一个向量，表示$l$的起点和$r$的重点之间的位置关系，注意开$long\\ double$和使用$atan2()$防止过大精度误差。 CF558E A Simple Task线段树大水题。 $26$棵线段树随便艹。 orz $spfa$ ODT神仙。 CF420D Cup Trick使用$fhq\\ treap$ 逆着题意模拟即可。 一开始所有点都不确定，每次取出第一个，判无解，$erase$ + $insert$二连，最终把不确定的瞎填一通输出即可。 2019.4.30CF316E3 Summer Homework我们考虑线段树，一个段里维护$\\displaystyle\\sum_{i = 1}^{n} a_i fib_i$和$\\displaystyle\\sum_{i = 1}^{n} a_i fib_{i - 1}$，然后可以矩阵乘法预处理出$\\displaystyle\\sum_{i = 1}^{n} a_i fib_{i + k}$和$\\displaystyle\\sum_{i = 1}^{n} a_i fib_i$，$\\displaystyle\\sum_{i = 1}^{n} a_i fib_{i - 1}$的关系$pushup$的时候从预处理好的里面取系数就行了。 CF1149C Tree Generator™orz $S\\color{red}{ooke}$ 红名巨爷。 首先两点之间一段可以转换为一个类dfs序状物，然后把距离可以做一个转换，变为序列上首尾相接的两端，前面那半段取反。接下来用线段树维护就行了。 CF653F Paper task如果我们钦点左括号为$1$，右括号为$-1$，$sum_i$为$\\displaystyle\\sum_{i = 1}^{i} a_i$，一个序列$[l, r]$是括号匹配的当且仅当$\\displaystyle\\min_{l \\leq i \\leq r} (sum_i) \\geq sum_{l - 1}$且$sum_r = sum_{l - 1}$那么用二分 + 后缀数组可以得出对于一个左端点，它右端点的范围。最后主席树维护一波即可。 CF1070B Berkomnadzor先建出字典树（只针对需要被屏蔽的，白名单直接在他和根的路径中打个标记就好了）。 再判个无解。 然后遍历一遍字典树，尽量取浅的未被标记的节点即可。 2019.5.1CF436E Cardboard Box首先把所有的关卡按照通过第二关的难度排个升序，然后再对于枚举一个点$i$，使得在$i$前面的关卡拿了一颗星，$i$后面的关卡没拿第二颗星（可以证明肯定存在一个最优解使得满足性质的$i$存在）。我们令$w_j$为使第$j$关拿到下一颗星的代价，然后用$fhq\\ treap$动态维护前$n - i + 1$个最大的$w_j$即可。 2019.5.2打了场CF还unr了。。。今天一大半时间都在做前一天CF的题目w CF887D Ratings and Reality Shows显然脱口秀放在一个事件后面一个单位时间最优。 然后枚举放在哪个后面 + 模拟即可。 CF1156E Special Segments of Permutation分治。 每次从一个线段中的最大值割开，维护一个$map$，然后合并的时候启发式合并一波即可。 感谢$L\\color{red}{JC0118}$教我的orz CF1156D 0-1-Tree简单DP，$f1[i]$表示以$i$点为开始的只有$0$边的路径的数量$f2[i]$表示….只有$1$边的….数量。 两遍DFS解决，最后显然答案就是$\\displaystyle\\sum_{i = 1}^{n} f1[i] * f2[i]$。 CF1156F Card Bag期望DP。$f[i][j]$表示取到第$i$个，目前包里还有还有$j$个球。 注意要开个$f2$辅助$f$的转移，否则要枚举下一个在什么地方取，就是$O(n^3)$的。 2019.5.3CF15D Map 把每个矩形的代价丢进$set$里面，每次取出代价最小的。 再把因为这个矩形取了导致不能够取的矩形删掉，就可以了。 2019.5.4luogu比赛正好和课外班撞了一大半。。。半个小时的时间只够打个$T1$了（艹要是我T2的倍增优化建边打出来了我就rk前10了w） T2边过个几天再补（咕咕咕） 洛谷P5343 【XR-1】分块简单矩阵乘法。 很像CF1117D Magic Gems，我的题解：&gt;Here&lt; 把柿子改改就可以了。 2019.5.6昨天回初中学校考试去了。。。 CF269D Maximum Waterfall用一个线段树维护一下每个点上最下面的节点，每次一直往下面加入线段。 每次分治一下+DP转移即可。 CF513D2Constrained Tree简单构造。 直接按照先序遍历为$1…n$这个性质乱搞，每次取尽量少的点构造一棵树，如何还有不够的就在最后直接加 因为如果在最右边的一个节点的右子树上加，不管是先序还是后序，表现出来都是在序列最后加。 CF431E Chemistry Experiment先离散化一波 然后直接大力二分 + 权值树状数组维护一波就行了。 2019.5.7洛谷P5344 【XR-1】逛森林裸倍增优化建边 注意要用一个类似ST表的东西来让它的点数小一个$\\log$ 2019.5.8CF286D Tourists答案可以转换成很多个斜线和一个奇奇怪怪的矩形组成的图形的交 接下来用堆 + 单调栈维护一下即可。 CF845E Fire in the City一个火区在一段时间后影响的时间是一个正方形，然后非常显然地想到二分答案 然后$check$里面把所有火区影响范围的边界弄出来，离散化一下，可以得到最上、最下、最左、最右的未着火区，然后就可以确定最后一个的位置了。 2019.5.9CF1117G Recursive Queries我们令$rb[i]$为$i$右边的最近的比$a[i]$大的数字的位置，$lb[i]$就是在左边的… 考虑一个数字$i$会使$[i + 1, rb[i] - 1]$和$[lb[i] + 1, i]$区间内的元素的贡献+1（前提是$i$在范围询问内） 两端分开来算，分别从左到右和从右到左加贡献 + 询问，线段树维护即可。 CF873E Awards For Contestants首先，暴力枚举第一个和第二个，显然前二个里面最优的解的数量封顶是$O(n^2)$的 接下来在前两个最优的情况下我们显然可以得到第三个的取值范围，就可以用$st$表维护差分最大值了。 2019.5.10CF257E Greedy Elevator按照题意模拟。 用一个$set$维护等电梯的和坐电梯的人即可。 CF446C DZY Loves Fibonacci Numbers我们可以在线段树上的Lazy标记改成一个斐波那契数列的第一和第二项（斐波那契数列是可以直接相加的） $pushdown$里面套一个矩阵乘法，就可以$O(n \\log^2 n)$解决了。 2019.5.11CF455D Serega and Fun分块。 每个块里开一个$deque$和一个桶，每次修改的时候瞎jb乱搞一下就行了。 2019.5.12CF515E Drazil and Park套路性拆环，直接把序列倍长一遍就变成区间最大字段和问题了。 直接用线段树解决即可。 2019.5.13CF1158C Permutation recovery这是$Sooke$验题的CF里的题 可以建图DFS过序过去，也可以树状数组乱搞。 CF551E GukiZ and GukiZiana实名diss洛谷上的第二篇题解。。。代码是抄的，注释跟简单介绍分块基本没有区别$O(q \\sqrt{n \\log n})$被硬生生说成了$O(nq\\log n)$不知道作者是怎么想的 就是分块 块内有序 查询的时候从左和右分别开始每个块内二分看是否存在要找的数。 似乎每块开个unordered_map就能去log了 2019.5.16CF786C Till I Collapse我们用主席树上二分可以得到每个地点可以最多往左走到哪里 每次询问从右往左暴力跳就行了，因为最多跳$\\frac ni$次，加起来就是$n \\log n$加上主席树上二分就是两只$\\log$的 2019.5.17CF348C Subset Sums把集合分成大小$&gt; \\sqrt n$和大小$&lt; \\sqrt n$的两种，加的时候大集合打标记 小集合暴力加，并且给所有大集合加上所对应的贡献。 查询的时候对于大集合，我们把它的标记和加小集合对它的贡献加起来就行了。 小集合照样暴力即可，注意要加上修改大集合对它的贡献。 2019.5.18CF1166E The LCMs Must be Large 结束了？结束了。 orz $\\color{black}s\\color{red}{pfa}$ CF650D Zip-line发现答案只有可能原LIS + 1, LIS, LIS - 1中的一个 我们对于它是不是在原LIS节点作分类讨论，接下来用主席树维护即可。 2019.5.21CF911G Mass Change Queries线段树，$f[i]$表示在这个区间内，$i$全都变成了$f[i]$，可以将$f$认为是一种特殊的懒标。 每次下传的时候$t[lc(cur)].f[i] = t[cur].f[t[lc(cur)].f[i]]$即可，右儿子也是这样。 CF240F TorCoder直接丢篇完整题解好了 2019.5.22CF992E Nastya and King-Shamans每次往后跳，直接跳到$s[j] &gt; 2s[i]$的最小的$j$ 可以用线段树上二分实现。 2019.5.24CF1030F Putting Boxes Together其实最终的决策就是一个带权带修中位数 然后用一个线段树维护即可。 CF1051E Vasya and Big Integers求出LCP之后就可以比较两个的大小 然后就可以DP了 完整题解 2019.5.25CF940F Machine Learning考虑带修莫队， 每次更新的时候分块$O(1)$修改。 每个询问的时候$O(\\sqrt n)$查询即可。 2019.5.28CF749E Inversions After Shuffle对于每一个选择的区间，序列分成前面的，中间的，后面的三部分。 然后中间的每对数，贡献$\\frac 12$，其他的每个逆序对贡献$1$，使用树状数组维护即可。 CF916E Jamie and Tree2019.5.29CF1044D Deduction Queries2019.5.30CF338E Optimize!2019.5.31CF372D Choosing Subtree is Fun2019.6.1CF266E More Queries to Array…2019.6.2CF811E Vladik and Entertaining Flags2019.6.3CF200A CinemaCF1148F Foo FightersCF1148E Earth Wind and Fire2019.6.4CF28D Don’t fear, DravDe is kind####","categories":[],"tags":[]},{"title":"题解 CF1153E Serval and Snake","slug":"Solutions/Solution-CF1153E","date":"2019-04-14T04:02:00.000Z","updated":"2019-04-14T13:27:38.000Z","comments":true,"path":"2019/04/14/Solutions/Solution-CF1153E/","link":"","permalink":"https://dilute.xyz/2019/04/14/Solutions/Solution-CF1153E/","excerpt":"有趣的交互题我们考虑一件事情 如果我们询问的矩形中有一个端点 那么答案 $\\mod 2 = 1$ 否则答案 $\\mod 2 = 0$ 换句话说，就是如果询问到的答案$\\mod 2 = 0$，那么这个矩形内要么没有端点，要么有两个端点","text":"有趣的交互题我们考虑一件事情 如果我们询问的矩形中有一个端点 那么答案 $\\mod 2 = 1$ 否则答案 $\\mod 2 = 0$ 换句话说，就是如果询问到的答案$\\mod 2 = 0$，那么这个矩形内要么没有端点，要么有两个端点 我们考虑 如果两个答案不在同一行 那么我们可以$O(n)$次询问找到这两行然后二分答案，这是非常简单易懂轻松愉快的 如果在同一行 那么他们肯定不在同一列 然后我们只需要找到他们中的一个，而且只需要二分一次就行了 因为两个在同一行，他们有一维坐标是一样的，如果二分两次的话被卡满就是$n + n + 2\\log n = 2020$次询问，刚刚好爆掉（来自出题人的恶意） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;std::pair&lt;int, int&gt; ans[4];int n;int query(int x1, int y1, int x2, int y2)&#123; printf(\"? %d %d %d %d\\n\", x1, y1, x2, y2); fflush(stdout); return inp();&#125;int solve1(int cur)&#123; int l = 1; int r = n; while(l &lt; r)&#123; int mid = (l + r) &gt;&gt; 1; if(query(cur, l, cur, mid) &amp; 1) r = mid; else l = mid + 1; &#125; return l;&#125;int solve2(int cur)&#123; int l = 1; int r = n; while(l &lt; r)&#123; int mid = (l + r) &gt;&gt; 1; if(query(l, cur, mid, cur) &amp; 1) r = mid; else l = mid + 1; &#125; return l;&#125;int main()&#123; n = inp(); int cnt = 0; for(int i = 1; i &lt;= n; i++)&#123; int num = query(i, 1, i, n); if(num &amp; 1) ans[++cnt] = std::make_pair(i, solve1(i)); &#125; if(cnt == 0)&#123; for(int i = 1; i &lt;= n; i++)&#123; int num = query(1, i, n, i); if(num &amp; 1)&#123; if(cnt == 0) ans[++cnt] = std::make_pair(solve2(i), i); else ans[++cnt] = std::make_pair(ans[1].first, i); &#125; &#125; &#125; printf(\"! %d %d %d %d\\n\", ans[1].first, ans[1].second, ans[2].first, ans[2].second); fflush(stdout);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://dilute.xyz/tags/二分/"},{"name":"非传统题","slug":"非传统题","permalink":"https://dilute.xyz/tags/非传统题/"}]},{"title":"题解 CF343D Water Tree","slug":"Solutions/Solution-CF343D","date":"2019-03-29T13:50:00.000Z","updated":"2019-03-29T14:37:00.000Z","comments":true,"path":"2019/03/29/Solutions/Solution-CF343D/","link":"","permalink":"https://dilute.xyz/2019/03/29/Solutions/Solution-CF343D/","excerpt":"似乎莫得人是不用树剖的w但是为什么的一只$\\log$乱搞被树剖的两只$\\log$爆踩啊 是因为我实现的太丑了吗 不管了直接讲做法好了","text":"似乎莫得人是不用树剖的w但是为什么的一只$\\log$乱搞被树剖的两只$\\log$爆踩啊 是因为我实现的太丑了吗 不管了直接讲做法好了 首先，我们考虑一个很显然的结论： 如果我们对于节点$x$他上次被灌水的时间位$x$，上次被清除水的时间是$y$ 那么若有$x &gt; y$则此时这个节点有水 否则这个节点没水 然后我们再考虑如何维护$x$和$y​$ 我们把两种修改分别讨论，分别用树上差分和$dfs$序维护，就可以愉快地以$O(n \\log n)$的复杂度切掉此题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define lc(a) (a &lt;&lt; 1)#define rc(a) (a &lt;&lt; 1 | 1)int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;struct SEG_Tree&#123; struct SEG&#123; int l; int r; int max; int lazy; &#125;t[2000000]; void push_up(int cur)&#123; t[cur].max = std::max(t[lc(cur)].max, t[rc(cur)].max); &#125; void push_down(int cur)&#123; if(!t[cur].lazy) return ; t[lc(cur)].max = t[rc(cur)].max = t[lc(cur)].lazy = t[rc(cur)].lazy = t[cur].lazy; t[cur].lazy = 0; &#125; void build(int cur, int l, int r)&#123; t[cur].l = l; t[cur].r = r; t[cur].max = 0; t[cur].lazy = 0; if(l == r) return ; int mid = (l + r) &gt;&gt; 1; build(lc(cur), l, mid); build(rc(cur), mid + 1, r); &#125; void modify(int cur, int l, int r, int c)&#123; if(t[cur].l &gt; r || t[cur].r &lt; l) return ; if(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r)&#123; t[cur].max = c; t[cur].lazy = c; return ; &#125; push_down(cur); modify(lc(cur), l, r, c); modify(rc(cur), l, r, c); push_up(cur); &#125; int query(int cur, int l, int r)&#123; if(t[cur].l &gt; r || t[cur].r &lt; l) return 0; if(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r) return t[cur].max; push_down(cur); return std::max(query(lc(cur), l, r), query(rc(cur), l, r)); &#125;&#125;t1, t2;int dfn[500010], size[500010], head[500010], nxt[1000010], end[1000010];int cou = 0;void link(int a, int b)&#123; nxt[++cou] = head[a]; head[a] = cou; end[cou] = b;&#125;int idx = 0;void dfs(int cur, int last)&#123; dfn[cur] = ++idx; size[cur] = 1; for(int x = head[cur]; x != -1; x = nxt[x]) if(end[x] != last)&#123; dfs(end[x], cur); size[cur] += size[end[x]]; &#125;&#125;int main()&#123; memset(head, -1, sizeof(head)); int n = inp(); for(int i = 1; i &lt; n; i++)&#123; int u = inp(); int v = inp(); link(u, v); link(v, u); &#125; int m = inp(); dfs(1, 0); t1.build(1, 1, n); t2.build(1, 1, n); for(int i = 1; i &lt;= m; i++)&#123; int op = inp(); if(op == 1)&#123; int x = inp(); t1.modify(1, dfn[x], dfn[x] + size[x] - 1, i); &#125; else if(op == 2)&#123; int x = inp(); t2.modify(1, dfn[x], dfn[x], i); &#125; else &#123; int x = inp(); int a1 = t1.query(1, dfn[x], dfn[x]); int a2 = t2.query(1, dfn[x], dfn[x] + size[x] - 1); // printf(\"%d %d\\n\", a1, a2); if(a1 &gt; a2) printf(\"1\\n\"); else printf(\"0\\n\"); &#125; &#125;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://dilute.xyz/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"https://dilute.xyz/tags/线段树/"},{"name":"树上差分","slug":"树上差分","permalink":"https://dilute.xyz/tags/树上差分/"},{"name":"DFS序","slug":"DFS序","permalink":"https://dilute.xyz/tags/DFS序/"}]},{"title":"题解 CF1117D Magic Gems","slug":"Solutions/Solution-CF1117D","date":"2019-03-02T12:25:00.000Z","updated":"2019-03-02T13:12:16.000Z","comments":true,"path":"2019/03/02/Solutions/Solution-CF1117D/","link":"","permalink":"https://dilute.xyz/2019/03/02/Solutions/Solution-CF1117D/","excerpt":"有趣的矩阵乘法（为方便，下文中“大号宝石”代指连续的$m$个分裂出来的宝石，“小号宝石”代指未分裂的单个宝石） 首先，我们观察这题，考虑$DP​$，设状态$f_i​$表示已经取了$i​$个单元的方案数的不难推出一个朴素的$O(n^2) DP​$方程$f_i = \\displaystyle\\sum_{i - j \\geq m} f_j +1​$（可以理解成上一个大号宝石放的位置，最后一个$1​$即为全部用小号宝石填满的方案） 我们再仔细看看这个式子，加个前缀和，不难优化到$O(n)$，然而数据范围$n \\leq 10^{18}$，这让我们考虑$O(\\log n)$级别的算法，我们接下来考虑矩阵乘法优化这个式子。","text":"有趣的矩阵乘法（为方便，下文中“大号宝石”代指连续的$m$个分裂出来的宝石，“小号宝石”代指未分裂的单个宝石） 首先，我们观察这题，考虑$DP​$，设状态$f_i​$表示已经取了$i​$个单元的方案数的不难推出一个朴素的$O(n^2) DP​$方程$f_i = \\displaystyle\\sum_{i - j \\geq m} f_j +1​$（可以理解成上一个大号宝石放的位置，最后一个$1​$即为全部用小号宝石填满的方案） 我们再仔细看看这个式子，加个前缀和，不难优化到$O(n)$，然而数据范围$n \\leq 10^{18}$，这让我们考虑$O(\\log n)$级别的算法，我们接下来考虑矩阵乘法优化这个式子。 显然，这个式子跟满足$i - j \\geq m​$的$j​$有关，但是这些数字的数量是$n​$级别的，我们考虑将$\\displaystyle\\sum_{i - j \\geq m} f_j​$变形，变成$\\displaystyle\\sum_{j = 1}^{i} f_j - \\sum_{j = i - m}^{j &lt; i} f_j​$ 这样只要我们维护一下$\\displaystyle\\sum_{j = 1}^{i} f_j​$就可以把需要维护的值的数量降到$m​$级别。 接下来直接在矩阵的第一行的第$j (1 \\leq j \\leq m) ​$ 位放上$f_{i - j}​$，然后第$m + 1​$位维护$\\displaystyle\\sum_{j = 1}^{i} f_j​$，第$m + 2​$位再弄个$1​$，瞎构造一通转移矩阵，就可以愉快的套矩阵快速幂板子了，最终复杂度$O(m^3 \\log n)​$。 （转移的矩阵的具体构造建议看代码） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define mod 1000000007ll inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); ll sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;class Square&#123; public: long long num[110][110]; int len; Square operator *(Square b)&#123; Square ans; memset(ans.num, 0, sizeof(ans.num)); for(int i = 1;i &lt;= len; i++) for(int j = 1; j &lt;= len; j++) for(int k = 1; k &lt;= len; k++)&#123; ans.num[i][j] += num[i][k] * b.num[k][j]; ans.num[i][j] %= mod; &#125; ans.len = len; return ans; &#125;&#125;;int main()&#123; ll n = inp(); int m = inp() - 1; Square a, b; a.len = m + 2; b.len = m + 2; memset(a.num, 0, sizeof(a.num)); a.num[1][m + 2] = 1; a.num[1][1] = 1; a.num[1][m + 1] = 1; memset(b.num, 0, sizeof(b.num)); for(int i = 1; i &lt;= m; i++) b.num[i][m + 1] = -1; b.num[m + 1][m + 1] = 2; b.num[m + 2][m + 1] = 1; b.num[m + 2][m + 2] = 1; for(int i = 2; i &lt;= m; i++) b.num[i - 1][i] = 1; for(int i = 1; i &lt;= m; i++) b.num[i][1] = -1; b.num[m + 2][1] = b.num[m + 1][1] = 1; // n -= 2; while(n)&#123; if(n &amp; 1) a = a * b; b = b * b; n &gt;&gt;= 1; // printf(\"%lld\\n\", a.num[1][1]); &#125; // printf(\"%lld\\n\", (a * (b * b) * b * b).num[1][1]); // for(int i = 1; i &lt;= n; i++)&#123; // printf(\"%lld\\n\", a.num[1][1]); // a = a * b; // &#125; std::cout &lt;&lt; a.num[1][1] &lt;&lt; std::endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://dilute.xyz/tags/矩阵乘法/"}]},{"title":"题解 CF452F Permutation","slug":"Solutions/Solution-CF452F","date":"2019-02-26T13:39:00.000Z","updated":"2020-02-13T06:01:46.000Z","comments":true,"path":"2019/02/26/Solutions/Solution-CF452F/","link":"","permalink":"https://dilute.xyz/2019/02/26/Solutions/Solution-CF452F/","excerpt":"又双叒叕是题外话今天模拟考是原题大战。 $T1​$是这题。$T2$是某次$CF\\ Div1\\ E$题。$T3​$反正是某道神仙题。 像我这样的菜鸡只能来做做相对可做的T1 虽然只是相对可做但是还是被全场切穿了啊喂 内心OS：这个不订正的理由真的nice","text":"又双叒叕是题外话今天模拟考是原题大战。 $T1​$是这题。$T2$是某次$CF\\ Div1\\ E$题。$T3​$反正是某道神仙题。 像我这样的菜鸡只能来做做相对可做的T1 虽然只是相对可做但是还是被全场切穿了啊喂 内心OS：这个不订正的理由真的nice 思路我们看到题面要求求的三元组，然后瞎变形一下$$\\begin{aligned}a_j - a_i &amp;= a_k - a_i\\a_i + a_k &amp;= 2 a_j \\a_k &amp;= 2a_j - a_i\\\\end{aligned}$$这样子，我们开始试图枚举$j$，之后我们就有一个美妙的性质 在$j$确定的情况下，对于一个$a_i$有对应的$a_j$可以组成三元组当且仅当 $2a_j - a_i$存在（废话） $2a_j - a_i$与$a_j$在$a_i$的不同侧 （如果第二点看不懂可以直接看下面的进一步推导） 我们用$s_i$表示$i$这个数在$j$左边的位置有没有出现过 那么我们可以把上面的两点东西给弄出来，那么就是 $\\forall\\ 1 \\leq 2a_j - a_i \\leq n, s_{a_i} \\neq s_{2a_j - a_i}​$ 变换一下，变成不能组成三元组的条件，那就是 $\\forall\\ 1 \\leq 2a_j - a_i \\leq n, s_{a_i} = s_{2a_j - a_i}$ 表示在图上，那就可以画成这样↓ （就是红色部分和绿色部分是对称的）（反正这个意思感性理解一下） 好，然后我们接下来可以愉快地对$s$进行哈希了。 我们接下来考虑如何动态地维护$s$的哈希数组 现在的目标就是：资瓷单点修改和区间查询（正反都要） 实际上一个线段树就可以解决了 每个节点维护正反两个哈希值 就可以轻松写意地切掉此题。 这是我在模拟考时候写的代码，丑的一批。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define mod 998244353#define lc(a) (a &lt;&lt; 1)#define rc(a) (a &lt;&lt; 1 | 1)#define add(a, b) ((a) + (b) &gt;= mod ? (a) + (b) - mod : (a) + (b))#define minus(a, b) ((a) &lt; (b) ? (a) - (b) + mod : (a) - (b))#define mul(a, b) ((a) * (ll)(b) % mod)int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;int a[300010];int s[300010];int powmod[300010];struct SEG&#123; int l; int r; int sum; int rev; SEG operator + (const SEG &amp;b) const &#123; // 为了方便查询的时候我把push_up给直接写成这种形式了 if(l == -1) // (SEG)&#123;-1, -1, -1, -1&#125; 代表空的一段 return b; if(b.l == -1) return (SEG)&#123;l, r, sum, rev&#125;; return (SEG)&#123;l, b.r, add(mul(sum, powmod[b.r - b.l + 1]), b.sum), add(mul(b.rev, powmod[r - l + 1]), rev)&#125;; &#125;&#125;;struct SEG_Tree&#123; SEG t[2400000]; void push_up(int cur)&#123; t[cur] = t[lc(cur)] + t[rc(cur)]; &#125; void build(int cur, int l, int r)&#123; t[cur].l = l; t[cur].r = r; t[cur].sum = t[cur].rev = 0; if(l == r)&#123; t[cur].sum = t[cur].rev = 0; return ; &#125; int mid = (l + r) &gt;&gt; 1; build(lc(cur), l, mid); build(rc(cur), mid + 1, r); push_up(cur); &#125; void modify(int cur, int pos, int c)&#123; if(t[cur].l == t[cur].r)&#123; t[cur].sum = t[cur].rev = c; return ; &#125; if(pos &lt;= t[lc(cur)].r) modify(lc(cur), pos, c); else modify(rc(cur), pos, c); push_up(cur); &#125; SEG query(int cur, int l, int r)&#123; if(t[cur].l &gt; r || t[cur].r &lt; l) return (SEG)&#123;-1, -1, -1, -1&#125;; // printf(\"[%d, %d], query(%d, %d), &#123;%d, %d&#125;\\n\", t[cur].l, t[cur].r, l, r, t[cur].sum, t[cur].rev); if(t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r) return t[cur]; return query(lc(cur), l, r) + query(rc(cur), l, r); &#125;&#125;t;int main()&#123; int n = inp(); for(int i = 1; i &lt;= n; i++) a[i] = inp(); powmod[0] = 1; for(int i = 1; i &lt;= n; i++) powmod[i] = (powmod[i - 1] &lt;&lt; 1) % mod; t.build(1, 1, n); bool flg = false; for(int i = 1; i &lt;= n; i++)&#123; t.modify(1, a[i], 1); // printf(\"--------------------\\na[i] = %d\\n\", a[i]); if((a[i] &lt;&lt; 1) - 1 &lt;= n)&#123; if(a[i] &gt; 1 &amp;&amp; t.query(1, 1, a[i] - 1).sum != t.query(1, a[i] + 1, (a[i] &lt;&lt; 1) - 1).rev)&#123; flg = true; break; &#125; &#125; else &#123; if(a[i] &lt; n &amp;&amp; t.query(1, a[i] + 1, n).rev != t.query(1, (a[i] &lt;&lt; 1) - n, a[i] - 1).sum)&#123; flg = true; break; &#125; &#125; &#125; if(flg)&#123; printf(\"YES\\n\"); &#125; else &#123; printf(\"NO\\n\"); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://dilute.xyz/tags/哈希/"},{"name":"线段树","slug":"线段树","permalink":"https://dilute.xyz/tags/线段树/"}]},{"title":"题解P2892 追捕盗贼","slug":"Solutions/Solution-Luogu2892","date":"2019-02-21T10:17:00.000Z","updated":"2019-03-02T12:32:24.000Z","comments":true,"path":"2019/02/21/Solutions/Solution-Luogu2892/","link":"","permalink":"https://dilute.xyz/2019/02/21/Solutions/Solution-Luogu2892/","excerpt":"本篇题解讲述的为非完美做法，但是可以骗到96分说实话我在网上找了好久结果都是这个$O(n^2)$的非正解树型$DP$ 听说有个$O(N)​$的正解在某篇论文里？ 算了反正我也看不懂 所以我接下来就介绍一下这个$O(n^2)$的树型$DP$吧QwQ 顺手丢一下我学习的这篇blog​吧","text":"本篇题解讲述的为非完美做法，但是可以骗到96分说实话我在网上找了好久结果都是这个$O(n^2)$的非正解树型$DP$ 听说有个$O(N)​$的正解在某篇论文里？ 算了反正我也看不懂 所以我接下来就介绍一下这个$O(n^2)$的树型$DP$吧QwQ 顺手丢一下我学习的这篇blog​吧 预处理首先我们先用$f[i]$表示占领以$i$为根的子树所需要的人数 然后我们可以很显然地列出一个方程$f[u] = \\max{f[v]}$ 然后我们还要特判一下，如果有多个$f[v] = max{f[v]}$，那么得$f[u]$得再加上1 因为在我们进行每一个子树的占领的时候除了最后一个，必须得有一个人待在root处（具体可以看后面的代码） 构造方案首先，我们预处理$n$次，分别以1~n为根，接下来就可以确定一个答案最小的根。 确认根之后，我们显然要先向根丢一个人，然后以为前面所说，我们得先把$f[v]$不是最大的$v$给先处理掉，然后再做$f[v]$最大的$v$。 而我们访问一棵子树的顺序如下： 在$u$节点放一个警探 将$u$节点的其中一个警探走向$v$节点（为了防止目标待在$u \\rightarrow v$的边上赖着不走） 递归做$v$节点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647inline int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;int head[100010];int nxt[20010];int end[20010];char type[100000];int num1[100000], num2[100000];int cnt = 0;int cou = 0;int f[20010];void link(int a, int b)&#123; nxt[++cou] = head[a]; head[a] = cou; end[cou] = b;&#125;void dfs(int cur, int last)&#123; int max = 0; bool mt = true; for(int x = head[cur]; x != -1; x = nxt[x])&#123; if(end[x] != last)&#123; dfs(end[x], cur); if(f[end[x]] &gt; max)&#123; max = f[end[x]]; mt = false; &#125; else if(f[end[x]] == max) mt = true; &#125; &#125; if(mt) f[cur] = max + 1; else f[cur] = max;&#125;void dfs2(int cur, int last)&#123; int max = 0; bool mt = true; int degree = 0; int pos; for(int x = head[cur]; x != -1; x = nxt[x])&#123; if(end[x] != last)&#123; dfs(end[x], cur); if(f[end[x]] &gt; max)&#123; max = f[end[x]]; mt = false; pos = end[x]; &#125; else if(f[end[x]] == max) mt = true; degree++; &#125; &#125; // printf(\"%d %d pos = %d\\n\", cur, last, pos); if(degree == 0)&#123; type[++cnt] = 'B'; num1[cnt] = cur; return ; &#125; for(int x = head[cur]; x != -1; x = nxt[x])&#123; if(end[x] != pos &amp;&amp; end[x] != last)&#123; type[++cnt] = 'L'; num1[cnt] = cur; type[++cnt] = 'M'; num1[cnt] = cur; num2[cnt] = end[x]; dfs2(end[x], cur); &#125; &#125; type[++cnt] = 'M'; num1[cnt] = cur; num2[cnt] = pos; dfs2(pos, cur); if(mt) f[cur] = max + 1; else f[cur] = max;&#125;int main()&#123; memset(head, -1, sizeof(head)); int n = inp(); for(int i = 1; i &lt; n; i++)&#123; int u = inp(); int v = inp(); link(u, v); link(v, u); &#125; int root = 0; int min = INF; for(int i = 1; i &lt;= n; i++)&#123; dfs(i, 0); if(f[i] &lt; min)&#123; min = f[i]; root = i; &#125; &#125; dfs2(root, 0); printf(\"%d\\n%d\\n\", min, cnt + 1); printf(\"L %d\\n\", root); for(int i = 1; i &lt;= cnt; i++)&#123; putchar(type[i]); printf(\" %d\", num1[i]); if(type[i] == 'M') printf(\" %d\", num2[i]); putchar('\\n'); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"},{"name":"骗分","slug":"骗分","permalink":"https://dilute.xyz/tags/骗分/"}]},{"title":"题解 CF1111C Creative Snap","slug":"Solutions/Solution-CF1111C","date":"2019-02-12T06:30:00.000Z","updated":"2019-03-02T12:32:14.000Z","comments":true,"path":"2019/02/12/Solutions/Solution-CF1111C/","link":"","permalink":"https://dilute.xyz/2019/02/12/Solutions/Solution-CF1111C/","excerpt":"简单递归首先我们如果要消灭一段区间$[l, r]$，我们可以有三种选择： 如果$[l, r]​$区间内没人，那么直接花费$A​$的代价将这段摧毁 如果$r &gt; l​$（即这段区间长度$&gt;2​$），可以选择把它切割成$\\left[ l, \\lfloor \\frac{l + r}2\\rfloor\\right]​$ $\\left[\\lceil \\frac{l + r}2\\rceil, r\\right]​$两段 如果$[l, r]$区间内有人，直接花费$b (r - l + 1)x$的代价将其摧毁。","text":"简单递归首先我们如果要消灭一段区间$[l, r]$，我们可以有三种选择： 如果$[l, r]​$区间内没人，那么直接花费$A​$的代价将这段摧毁 如果$r &gt; l​$（即这段区间长度$&gt;2​$），可以选择把它切割成$\\left[ l, \\lfloor \\frac{l + r}2\\rfloor\\right]​$ $\\left[\\lceil \\frac{l + r}2\\rceil, r\\right]​$两段 如果$[l, r]$区间内有人，直接花费$b (r - l + 1)x$的代价将其摧毁。 那么我们可以直接递归寻找对于每个区间的最优解 但是如果暴力找，那么是$O(2^n)​$的。 然后我们可以发现一个很显然的结论，就是若一个区间内没人，那么第一种方案是肯定最优的。 可以理解成动态开点线段树上的$DP​$ 将这个优化加上去之后复杂度就是正确的QwQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define int long longint inp()&#123; char c = getchar(); int neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') neg = -1; c = getchar(); &#125; int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return neg * sum;&#125;int pos[100010];int n, k, a, b;int solve(int l, int r)&#123; int cnt = std::upper_bound(pos + 1, pos + k + 1, r) - std::lower_bound(pos + 1, pos + k + 1, l); // printf(\"cnt [%d, %d] = %d\\n\", l, r, cnt); int mid = (l + r) &gt;&gt; 1; if(l == r &amp;&amp; cnt != 0) return (r - l + 1) * cnt * b; return (cnt == 0) ? a : std::min((r - l + 1) * cnt * b, solve(l, mid) + solve(mid + 1, r));&#125;signed main()&#123; n = inp(); k = inp(); a = inp(); b = inp(); for(int i = 1; i &lt;= k; i++) pos[i] = inp(); std::sort(pos + 1, pos + k + 1); printf(\"%I64d\\n\", solve(1, 1 &lt;&lt; n)); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"}]},{"title":"题解 洛谷P5174 圆点","slug":"Solutions/Solution-Luogu5174","date":"2019-01-28T12:02:00.000Z","updated":"2019-03-02T12:32:42.000Z","comments":true,"path":"2019/01/28/Solutions/Solution-Luogu5174/","link":"","permalink":"https://dilute.xyz/2019/01/28/Solutions/Solution-Luogu5174/","excerpt":"题外话我本来自己想到的的做法是跟别的大多数题解一样的 但是$LJC00118$大仙跟我讲了他的做法，据说常数更小一些，于是我就过来发（水）题（社）解（区）了（分）。","text":"题外话我本来自己想到的的做法是跟别的大多数题解一样的 但是$LJC00118$大仙跟我讲了他的做法，据说常数更小一些，于是我就过来发（水）题（社）解（区）了（分）。 解法首先，我们看到圆上整点，我们可以发现圆上整点的集合就是满足$x, y$都为整数，且$x^2 + y^2 \\leq r^2$的点的集合，那么这题要求的东西就可以表示成$\\displaystyle\\sum_{i = 1}^{\\sqrt r}\\sum_{i^2 + j^2 \\leq r} i^2 + j^2$表达不太规范，反正意思对就行QwQ 我们把这个式子给化一下 令$j​$的上界为$maxj​$$ \\displaystyle\\sum_{i= 1}^{\\sqrt r} \\left(\\sum_{j = 1}^{maxj} j^2\\right) + i^2 * maxj ​$ $ \\displaystyle\\sum_{i = 1}^{\\sqrt r} \\frac{maxj(maxj + 1)(2maxj + 1)}{6} + i^2 * maxj$ 然后我们瞪一下这个式子，显然可以发现$maxj​$是单调下降的 然后我们存一下$maxj​$，然后一遍枚举$i​$一边算$maxj​$就可以做了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define mod 1000000007ll powmod(ll a, int b)&#123; ll sum = 1; while(b)&#123; if(b &amp; 1)&#123; sum *= a; sum %= mod; &#125; a *= a; a %= mod; b &gt;&gt;= 1; &#125; return sum;&#125;ll inv6;ll sum(ll n)&#123; return (n * (n + 1) % mod * ((n &lt;&lt; 1) + 1) % mod) * inv6 % mod;&#125;int main()&#123; inv6 = powmod(6, mod - 2); ll r; scanf(\"%lld\", &amp;r); ll ans = 0; ll num = sqrt(r) + 1; for(ll i = 0; i * i &lt;= r; i++)&#123; while(i * i + num * num &gt; r) num--; ans += i * i % mod * num % mod; ans %= mod; ans += sum(num); ans %= mod; &#125; ans &lt;&lt;= 2; ans %= mod; printf(\"%lld\\n\", ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[]},{"title":"PKUWC2019游记","slug":"Other/PKUWC2019-Journey","date":"2019-01-20T10:49:00.000Z","updated":"2019-03-02T12:44:14.000Z","comments":true,"path":"2019/01/20/Other/PKUWC2019-Journey/","link":"","permalink":"https://dilute.xyz/2019/01/20/Other/PKUWC2019-Journey/","excerpt":"$Day\\ 0$早上八点的飞机从杭州飞到广东中山纪念。 飞机上跟旁边的$sjn$神犇聊了一会之后开始颓废，后来敲了$fhq\\ Treap$、最大流、费用流三个板子。 到了广东之后做了3个小时的公交车 到了中山纪念之后觉得宿舍略破，不过至少有电QwQ 试了个机，T1水题，T2据说是去年PKUSC的D1T2，想出了DP的状态定义不会转移，结果后来Sooke教我了一下，感觉不是特别想敲=-= 试完机之后还有蛮长的一段时间吃饭，于是我们就打了一盘狼人杀（法官真好玩） 饭菜一般般，坐我旁边的Sooke想找人面基，但是最后也就来的路上遇到了bztQwQ 晚上吃完饭，又来了一盘狼人杀（我还是法官）（双预言家真好玩） 现在是晚上7点，我躺在床上跟LJC00118一起写游记 真是充（颓）实（废）的一天","text":"$Day\\ 0$早上八点的飞机从杭州飞到广东中山纪念。 飞机上跟旁边的$sjn$神犇聊了一会之后开始颓废，后来敲了$fhq\\ Treap$、最大流、费用流三个板子。 到了广东之后做了3个小时的公交车 到了中山纪念之后觉得宿舍略破，不过至少有电QwQ 试了个机，T1水题，T2据说是去年PKUSC的D1T2，想出了DP的状态定义不会转移，结果后来Sooke教我了一下，感觉不是特别想敲=-= 试完机之后还有蛮长的一段时间吃饭，于是我们就打了一盘狼人杀（法官真好玩） 饭菜一般般，坐我旁边的Sooke想找人面基，但是最后也就来的路上遇到了bztQwQ 晚上吃完饭，又来了一盘狼人杀（我还是法官）（双预言家真好玩） 现在是晚上7点，我躺在床上跟LJC00118一起写游记 真是充（颓）实（废）的一天 $Day\\ 1$还是起床，吃饭，吃完早饭睡了个回炉觉然后去吃中饭 进考场，打开OJ，登录，看题。 第一题看上去像个状压，一时没想出来，于是我先打了个暴力，拿了26分之后再花30min写了个链的情况 现在得分40分，看看旁边的人，似乎没有A掉的，于是我开始想52分的部分分。 我觉得这个部分分不简单，于是我开始去肝$T3$，试图从T3拿个$30$~$40​$分，结果事实告诉我，我大错特错了。 我原以为3个小时的时间够我写+调了，然后我最后死在了我没打过斗地主 我以为不同长度的顺子可以接在一起=-= 我花了3个小时写T3，结果获得了0分的好成绩 九条可怜我*** $Day\\ 1$总分$40 + 0 + 0 = 40\\ pts$ 出考场的瞬间发现T1是道签到傻逼题， 确确实实地感觉到了考场上智商$&gt;&gt;= 1$的$DEBUFF​$ $Day\\ 2$","categories":[{"name":"游记","slug":"游记","permalink":"https://dilute.xyz/categories/游记/"}],"tags":[{"name":"瞎写","slug":"瞎写","permalink":"https://dilute.xyz/tags/瞎写/"},{"name":"游记","slug":"游记","permalink":"https://dilute.xyz/tags/游记/"}]},{"title":"fhq Treap与区间操作","slug":"Notes/fhq-Treap","date":"2019-01-16T04:29:00.000Z","updated":"2019-03-02T12:29:04.000Z","comments":true,"path":"2019/01/16/Notes/fhq-Treap/","link":"","permalink":"https://dilute.xyz/2019/01/16/Notes/fhq-Treap/","excerpt":"​ 前段时间在机房里几个大爷的墙裂安利下学了发$fhq\\ treap$ 于是就顺带着把$fhq\\ treap$的区间操作给学了（比$Splay$的好理解多了） 似乎这么一点字太少了？那我放张图=-=","text":"​ 前段时间在机房里几个大爷的墙裂安利下学了发$fhq\\ treap$ 于是就顺带着把$fhq\\ treap$的区间操作给学了（比$Splay$的好理解多了） 似乎这么一点字太少了？那我放张图=-= Ⅰ前置芝士 —— fhq Treap （非旋Treap）我这篇文章是来讲区间操作的 不是来教你fhq treap的 所以你如果不会fhq treap的话自己找别的讲稿把 其实主要是因为我自己一大半也是感性理解的啦 好吧还是贴个代码把 咳咳咳，没错，所以这个部分就是让你们来背代码的 $merge$$merge(a, b)$的作用就是把根为b的树向根为a的树合并，并且返回合并出来的树的根。 12345678910111213int merge(int a, int b)&#123; if(a == 0 || b == 0) return a + b; if(t[a].w &gt; t[b].w)&#123; t[a].rc = merge(t[a].rc, b); push_up(a); return a; &#125; else &#123; t[b].lc = merge(a, t[b].lc); push_up(b); return b; &#125;&#125; 恩，就这么短。 $split$$split(a, b, c, d)$的作用是把根为a的子树分裂成两棵树$c, d$，并且$c$子树中是前$b$个元素。 123456789101112131415void split(int cur, int k, int &amp;a, int &amp;b)&#123; if(cur == 0)&#123; a = b = 0; return ; &#125; if(k &lt;= t[t[cur].lc].size)&#123; b = cur; split(t[cur].lc, k, a, t[b].lc); push_up(b); &#125; else &#123; a = cur; split(t[cur].rc, k - t[t[cur].lc].size - 1, t[a].rc, b); push_up(a); &#125;&#125; 其他核心操作？$\\tan 90^{\\text{o}}$。 因为$fhq\\ treap$ 的核心操作就这俩玩意儿。 Ⅱ 如何操作显然，如果你要对一个区间进行操作，你就得先从它的根节点开始搞事情 那么你如何获得它的根节点呢？ 如果你要操作一个$[l, r]$的区间 不管你怎么操作 肯定存在一个很方便的办法：弄出来一个表示$[l, r]$这个区间的子树。 说到子树，如果你学懂了$fhq$，那么你肯定能想到$split$操作 说到split，我就想到了唐僧与世俗split开去西天取经，明年年初，中美合拍，文体两开花，关注，谢谢支持。 在前一行，你什么都没看到，恩，就这样。 （瞬间正经）好，我们考虑如何$split$出来表示$[l , r]$区间的子树。 首先，我们首先$split$出来一个$size$为$l - 1$的子树，那剩下了第二棵子树，那么第二棵子树代表的显然就是$[l, n]$，然后你再$split$出来一个$size$为$r - l + 1$的子树，那么你这次$split$出来的子树代表的区间就是$[l, r]$啦 操作完之后我们就会得到3棵子树，你在第二棵上面做玩你想要的操作之后把子树$merge$回去就行了 比方说区间翻转的代码长这样↓ 12345678void reverse(int l, int r)&#123; int x, y, z; split(root, l - 1, x, y); int rt = y; split(rt, r - l + 1, y, z); t[y].lazy ^= 1; root = merge(x, merge(y, z));&#125; 关于区间翻转的操作我会在下面讲↓ Ⅲ 例题洛谷P3391 【模板】文艺平衡树（Splay）原题：&gt;Here&lt; 这边的区间翻转我们应当用打懒标的方式实现，然后每次操作的时候记得$pushdown$一下就行啦 怎么得到区间刚刚已经讲过了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647inline int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;struct fhq_Treap&#123; struct T&#123; int lc; int rc; bool lazy; int size; int w; int v; &#125;t[100010]; int root; int cnt; void init()&#123; root = cnt = 0; t[0].lc = t[0].rc = t[0].lazy = t[0].size = 0; &#125; inline void push_up(int cur)&#123; t[cur].size = t[t[cur].lc].size + t[t[cur].rc].size + 1; &#125; inline void push_down(int cur)&#123; if(!t[cur].lazy) return ; std::swap(t[cur].lc, t[cur].rc); t[t[cur].lc].lazy ^= 1; t[t[cur].rc].lazy ^= 1; t[cur].lazy = false; &#125; void split(int cur, int k, int &amp;x, int &amp;y)&#123; push_down(cur); if(cur == 0)&#123; x = y = 0; return ; &#125; if(t[t[cur].lc].size &gt;= k)&#123; y = cur; split(t[cur].lc, k, x, t[y].lc); push_up(y); &#125; else &#123; x = cur; split(t[cur].rc, k - t[t[cur].lc].size - 1, t[x].rc, y); push_up(x); &#125; &#125; int merge(int x, int y)&#123; if(x == 0) return y; if(y == 0) return x; push_down(x); push_down(y); if(t[x].w &gt; t[y].w)&#123; t[x].rc = merge(t[x].rc, y); push_up(x); return x; &#125; else &#123; t[y].lc = merge(x, t[y].lc); push_up(y); return y; &#125; &#125; void reverse(int l, int r)&#123; int x, y, z; split(root, l - 1, x, y); int rt = y; split(rt, r - l + 1, y, z); t[y].lazy ^= 1; // printf(\"finished split phase.\\n\"); // printf(\"%d %d, %d\\n\", x, y, z); rt = merge(y, z); // print(rt); root = merge(x, rt); // printf(\"completed reverse.\\n\"); &#125; inline void insert(int x)&#123; t[++cnt].lazy = false; t[cnt].size = 1; t[cnt].w = rand(); t[cnt].v = x; t[cnt].lc = t[cnt].rc = 0; root = merge(root, cnt); &#125; void print(int cur)&#123; if(cur == 0) return ; push_down(cur); print(t[cur].lc); printf(\"%d \", t[cur].v); print(t[cur].rc); &#125;&#125;t;int main()&#123; t.init(); int n = inp(); int m = inp(); for(int i = 1; i &lt;= n; i++) t.insert(i); for(int i = 1; i &lt;= m; i++)&#123; int l = inp(); int r = inp(); // t.print(t.root); // putchar('\\n'); t.reverse(l, r); &#125; t.print(t.root);&#125; SP4350 QMAX3VN - Giá trị lớn nhất 3原题：&gt;Here&lt; 这题luogu上面没法用C艹交 但是fhq treap 这种一堆取址的东西用C弄超级麻烦 于是我贡献了大量的CE与UKE 好的，这题要求资瓷插入以及查询区间最大值 然后插入的话我们split两棵子树，$merge$的时候把新加的元素当做一棵子树并在中间就行了 节点上维护区间最大值就OK了 还是很简单的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647inline ll inp()&#123; char c = getchar(); ll neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') neg = -1; c = getchar(); &#125; ll sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * neg;&#125;struct fhq_Treap&#123; struct T&#123; ll max; ll lc; ll rc; ll size; ll v; ll w; &#125;t[200010]; ll cnt, root; void init()&#123; root = cnt = 0; t[0] = &#123;-INF, 0, 0, 0, 0, 0&#125;; &#125; ll create(ll v)&#123; ll v0 = std::max(v, 0ll); t[++cnt] = &#123;v, 0, 0, 1, v, rand()&#125;; return cnt; &#125; void push_up(ll cur)&#123; t[cur].max = std::max(t[cur].v, std::max(t[t[cur].lc].max, t[t[cur].rc].max)); t[cur].size = t[t[cur].lc].size + t[t[cur].rc].size + 1; // printf(\"cur = %lld, max = %lld\\n\", cur, t[cur].max); &#125; ll merge(ll a, ll b)&#123; if(a == 0 || b == 0) return a + b; if(t[a].w &gt; t[b].w)&#123; t[a].rc = merge(t[a].rc, b); push_up(a); return a; &#125; else &#123; t[b].lc = merge(a, t[b].lc); push_up(b); return b; &#125; &#125; void split(ll cur, ll k, ll &amp;a, ll &amp;b)&#123; if(cur == 0)&#123; a = b = 0; return ; &#125; if(k &lt;= t[t[cur].lc].size)&#123; b = cur; split(t[cur].lc, k, a, t[b].lc); push_up(b); &#125; else &#123; a = cur; split(t[cur].rc, k - t[t[cur].lc].size - 1, t[a].rc, b); push_up(a); &#125; &#125; void insert(ll pos, ll v)&#123; ll x, y; split(root, pos - 1, x, y); // printf(\"Insert x = %lld, y = %lld\\n\", x, y); root = merge(merge(x, create(v)), y); &#125; void del(ll pos)&#123; ll x, y, z; split(root, pos - 1, x, y); split(y, 1, y, z); root = merge(x, z); &#125; void prll(ll cur)&#123; if(cur == 0) return ; prll(t[cur].lc); // printf(\"t[%lld] v = %lld ls= %lld rs= %lld sum= %lld tot= %lld lc= %lld rc= %lld\\n\", cur, t[cur].v, t[cur].ls, t[cur].rs, t[cur].sum, t[cur].tot, t[cur].lc, t[cur].rc); printf(\"t[%lld] = lc = %lld, rc = %lld, max = %lld, v = %lld\\n\", cur, t[cur].lc, t[cur].rc, t[cur].max, t[cur].v); prll(t[cur].rc); &#125; ll query(ll l, ll r)&#123; ll x, y, z; split(root, l - 1, x, y); split(y, r - l + 1, y, z); // prll(y); ll ret = t[y].max; root = merge(merge(x, y), z); return ret; &#125; void build(ll x)&#123; root = merge(root, create(x)); &#125;&#125;t;int main()&#123; t.init(); ll m = inp(); // printf(\"%d\\n\", m); // t.prll(t.root); for(ll i = 1; i &lt;= m; i++)&#123; char type = getchar(); while(type != 'A' &amp;&amp; type != 'Q') type = getchar(); if(type == 'A')&#123; ll x = inp(); ll pos = inp(); t.insert(pos, x); &#125; else &#123; ll l = inp(); ll r = inp(); printf(\"%lld\\n\", t.query(l, r)); &#125; // printf(\"i = %lld, finished %c\\n\", i, type); &#125;&#125; SP4487 GSS6 - Can you answer these queries VI原题：&gt;Here&lt; 这题就比较毒瘤啦 资瓷区间查询最大子段和，插入，删除，修改。 区间最大字段和的话我们可以参照线段树做法，一个节点上维护左端点开始的，右端点开始的还有整个的最大字段和，以及区间的和。 $pushup$因为两段元素中间还多了个自己这个节点，所以会麻烦不少 删除的时候只要$split$出来之后中间那段不$merge$回去就行了 修改的时候只要把中间那段修改权值一下就行了 只是写完之后修锅要好长时间呢… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define int long longinline int inp()&#123; char c = getchar(); int neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') neg = -1; c = getchar(); &#125; int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * neg;&#125;struct fhq_Treap&#123; struct T&#123; int ls; int rs; int sum; int tot; int lc; int rc; int size; int v; int w; &#125;t[200010]; int cnt, root; void init()&#123; root = cnt = 0; t[0] = &#123;0, 0, -INF, 0, 0, 0, 0, 0&#125;; &#125; int create(int v)&#123; int v0 = std::max(v, 0ll); t[++cnt] = &#123;v0, v0, v, v, 0, 0, 1, v, rand()&#125;; return cnt; &#125; void push_up(int cur)&#123; if(t[cur].lc == 0 &amp;&amp; t[cur].rc == 0)&#123; int v2 = std::max(t[cur].v, 0ll); t[cur].sum = t[cur].tot = t[cur].v; t[cur].ls = t[cur].rs = v2; t[cur].size = 1; return ; &#125; t[cur].tot = t[t[cur].lc].tot + t[t[cur].rc].tot + t[cur].v; t[cur].ls = std::max(t[t[cur].lc].tot + t[cur].v + t[t[cur].rc].ls, t[t[cur].lc].ls); t[cur].rs = std::max(t[t[cur].rc].tot + t[cur].v + t[t[cur].lc].rs, t[t[cur].rc].rs); t[cur].sum = std::max(std::max(t[t[cur].lc].sum, t[t[cur].rc].sum), t[t[cur].lc].rs + t[cur].v + t[t[cur].rc].ls); t[cur].size = t[t[cur].lc].size + t[t[cur].rc].size + 1; // printf(\"push up %lld | max&#123;%lld %lld %lld&#125; = %d\\n\", cur, t[t[cur].lc].sum, t[t[cur].rc].sum, t[t[cur].lc].rs + t[cur].v + t[t[cur].rc].ls, t[cur].sum); &#125; int merge(int a, int b)&#123; if(a == 0 || b == 0) return a + b; if(t[a].w &gt; t[b].w)&#123; t[a].rc = merge(t[a].rc, b); push_up(a); return a; &#125; else &#123; t[b].lc = merge(a, t[b].lc); push_up(b); return b; &#125; &#125; void split(int cur, int k, int &amp;a, int &amp;b)&#123; if(cur == 0)&#123; a = b = 0; return ; &#125; if(k &lt;= t[t[cur].lc].size)&#123; b = cur; split(t[cur].lc, k, a, t[b].lc); push_up(b); &#125; else &#123; a = cur; split(t[cur].rc, k - t[t[cur].lc].size - 1, t[a].rc, b); push_up(a); &#125; &#125; void insert(int pos, int v)&#123; int x, y; split(root, pos - 1, x, y); // printf(\"Insert x = %lld, y = %lld\\n\", x, y); root = merge(merge(x, create(v)), y); &#125; void modify(int pos, int v)&#123; int x, y, z; split(root, pos - 1, x, y); split(y, 1, y, z); int v0 = std::max(v, 0ll); t[y] = &#123;v0, v0, v, v, 0, 0, 1, v, t[y].w&#125;; root = merge(merge(x, y), z); &#125; void del(int pos)&#123; int x, y, z; split(root, pos - 1, x, y); split(y, 1, y, z); root = merge(x, z); &#125; void print(int cur)&#123; if(cur == 0) return ; print(t[cur].lc); printf(\"t[%lld] v = %lld ls= %lld rs= %lld sum= %lld tot= %lld lc= %lld rc= %lld\\n\", cur, t[cur].v, t[cur].ls, t[cur].rs, t[cur].sum, t[cur].tot, t[cur].lc, t[cur].rc); print(t[cur].rc); &#125; int query(int l, int r)&#123; int x, y, z; split(root, l - 1, x, y); split(y, r - l + 1, y, z); // print(y); int ret = t[y].sum; root = merge(merge(x, y), z); return ret; &#125; void build(int x)&#123; root = merge(root, create(x)); &#125;&#125;t;signed main()&#123; t.init(); int n = inp(); for(int i = 1; i &lt;= n; i++) t.build(inp()); int m = inp(); // printf(\"%d\\n\", m); // t.print(t.root); for(int i = 1; i &lt;= m; i++)&#123; char type = getchar(); while(type != 'I' &amp;&amp; type != 'D' &amp;&amp; type != 'R' &amp;&amp; type != 'Q') type = getchar(); if(type == 'I')&#123; int pos = inp(); int x = inp(); t.insert(pos, x); &#125; else if(type == 'D')&#123; t.del(inp()); &#125; else if(type == 'R')&#123; int pos = inp(); int x = inp(); t.modify(pos, x); &#125; else &#123; int l = inp(); int r = inp(); printf(\"%lld\\n\", t.query(l, r)); &#125; // printf(\"i = %lld, finished %c\\n\", i, type); &#125;&#125; [NOI2005]维护数列原题：&gt;Here&lt; 这题可以认为就是前三题加起来了 不过有一点要注意 在维护最大字段和的时候如果左右子树是反的那么会导致错误 所以我们不能像我给的文艺平衡树板子那样子写区间翻转 具体怎么做还是看代码把（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647inline int inp()&#123; char c = getchar(); int neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') neg = -1; c = getchar(); &#125; int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * neg;&#125;struct fhq_Treap&#123; struct T&#123; int ls; int rs; int sum; int tot; int lc; int rc; int size; int v; int w; int lazy; bool reverse; &#125;t[5000010]; int cnt, root; void init()&#123; root = cnt = 0; t[0] = (T)&#123;0, 0, -INF, 0, 0, 0, 0, 0, -INF, false&#125;; &#125; int create(int v)&#123; int v0 = std::max(v, 0); t[++cnt] = (T)&#123;v0, v0, v, v, 0, 0, 1, v, rand(), -INF, false&#125;; return cnt; &#125; void push_up(int cur)&#123; if(t[cur].lc == 0 &amp;&amp; t[cur].rc == 0)&#123; int v2 = std::max(t[cur].v, 0); t[cur].sum = t[cur].tot = t[cur].v; t[cur].ls = t[cur].rs = v2; t[cur].size = 1; return ; &#125; t[cur].tot = t[t[cur].lc].tot + t[t[cur].rc].tot + t[cur].v; t[cur].ls = std::max(t[t[cur].lc].tot + t[cur].v + t[t[cur].rc].ls, t[t[cur].lc].ls); t[cur].rs = std::max(t[t[cur].rc].tot + t[cur].v + t[t[cur].lc].rs, t[t[cur].rc].rs); t[cur].sum = std::max(std::max(t[t[cur].lc].sum, t[t[cur].rc].sum), t[t[cur].lc].rs + t[cur].v + t[t[cur].rc].ls); t[cur].size = t[t[cur].lc].size + t[t[cur].rc].size + 1; // printf(\"push up %d | max&#123;%d %d %d&#125; = %d\\n\", cur, t[t[cur].lc].sum, t[t[cur].rc].sum, t[t[cur].lc].rs + t[cur].v + t[t[cur].rc].ls, t[cur].sum); &#125; inline void push_down(int cur)&#123; if(t[cur].lazy != -INF)&#123; int v0 = std::max(t[cur].lazy, 0); t[t[cur].lc].ls = t[t[cur].lc].rs = v0 * t[t[cur].lc].size; t[t[cur].rc].ls = t[t[cur].rc].rs = v0 * t[t[cur].rc].size; t[t[cur].lc].sum = std::max(t[cur].lazy, t[cur].lazy * t[t[cur].lc].size); t[t[cur].rc].sum = std::max(t[cur].lazy, t[cur].lazy * t[t[cur].rc].size); t[t[cur].lc].tot = t[cur].lazy * t[t[cur].lc].size; t[t[cur].rc].tot = t[cur].lazy * t[t[cur].rc].size; t[t[cur].lc].lazy = t[cur].lazy; t[t[cur].rc].lazy = t[cur].lazy; t[t[cur].lc].v = t[t[cur].rc].v = t[cur].lazy; t[cur].lazy = -INF; t[cur].reverse = false; &#125; if(t[cur].reverse)&#123; std::swap(t[t[cur].lc].lc, t[t[cur].lc].rc); std::swap(t[t[cur].rc].lc, t[t[cur].rc].rc); std::swap(t[t[cur].lc].ls, t[t[cur].lc].rs); std::swap(t[t[cur].rc].ls, t[t[cur].rc].rs); t[t[cur].lc].reverse ^= 1; t[t[cur].rc].reverse ^= 1; t[cur].reverse = false; &#125; t[0] = (T)&#123;0, 0, -INF, 0, 0, 0, 0, 0, -INF, false&#125;; &#125; int merge(int a, int b)&#123; if(a == 0 || b == 0) return a + b; push_down(a); push_down(b); if(t[a].w &gt; t[b].w)&#123; t[a].rc = merge(t[a].rc, b); push_up(a); return a; &#125; else &#123; t[b].lc = merge(a, t[b].lc); push_up(b); return b; &#125; &#125; void split(int cur, int k, int &amp;a, int &amp;b)&#123; if(cur == 0)&#123; a = b = 0; return ; &#125; push_down(cur); if(k &lt;= t[t[cur].lc].size)&#123; b = cur; split(t[cur].lc, k, a, t[b].lc); push_up(b); &#125; else &#123; a = cur; split(t[cur].rc, k - t[t[cur].lc].size - 1, t[a].rc, b); push_up(a); &#125; &#125; void insert(int pos, int rt)&#123; int x, y; split(root, pos, x, y); root = merge(merge(x, rt), y); &#125; void modify(int pos, int len, int v)&#123; int x, y, z; split(root, pos - 1, x, y); split(y, len, y, z); t[y].ls = t[y].rs = std::max(v, 0) * t[y].size; t[y].tot = t[y].size * v; t[y].sum = std::max(v, v * t[y].size); t[y].lazy = v; t[y].v = v; root = merge(merge(x, y), z); &#125; void del(int pos, int len)&#123; int x, y, z; split(root, pos - 1, x, y); split(y, len, y, z); root = merge(x, z); &#125; void print(int cur)&#123; if(cur == 0) return ; push_down(cur); print(t[cur].lc); printf(\"t[%d] v = %d ls= %d rs= %d sum= %d tot= %d lc= %d rc= %d\\n\", cur, t[cur].v, t[cur].ls, t[cur].rs, t[cur].sum, t[cur].tot, t[cur].lc, t[cur].rc); print(t[cur].rc); push_up(cur); &#125; int query(int l, int len)&#123; int x, y, z; split(root, l - 1, x, y); split(y, len, y, z); // print(y); int ret = t[y].tot; root = merge(merge(x, y), z); return ret; &#125; void build(int x)&#123; root = merge(root, create(x)); &#125; void reverse(int pos, int len)&#123; int x, y, z; split(root, pos - 1, x, y); split(y, len, y, z); t[y].reverse ^= 1; std::swap(t[y].lc, t[y].rc); std::swap(t[y].ls, t[y].rs); root = merge(merge(x, y), z); &#125;&#125;t;signed main()&#123; t.init(); int n = inp(); int m = inp(); for(int i = 1; i &lt;= n; i++) t.build(inp()); // printf(\"%d\\n\", m); // t.print(t.root); char type[20]; for(int i = 1; i &lt;= m; i++)&#123; scanf(\"%s\", type); if(type[0] == 'I')&#123; int pos = inp(); int cnt = inp(); std::vector &lt;int&gt; vec; int rt = 0; for(int j = 1; j &lt;= cnt; j++) rt = t.merge(rt, t.create(inp())); t.insert(pos, rt); &#125; else if(type[0] == 'D')&#123; int l = inp(); int len = inp(); t.del(l, len); &#125; else if(type[0] == 'R')&#123; int pos = inp(); int len = inp(); t.reverse(pos, len); &#125; else if(type[0] == 'M' &amp;&amp; type[2] == 'K')&#123; int pos = inp(); int len = inp(); int x = inp(); t.modify(pos, len, x); &#125; else if(type[0] == 'G')&#123; int pos = inp(); int len = inp(); printf(\"%d\\n\", t.query(pos, len)); &#125; else &#123; printf(\"%d\\n\", t.t[t.root].sum); &#125; // t.print(t.root); // putchar('\\n'); &#125;&#125; Ⅳ 与其他相似算法的比较SplaySplay的作用跟$fhq\\ Treap$差不多，都是可以维护区间操作，但是个人认为$fhq$优于$Splay$，理由有二 好写，代码短 易于理解 而且，$fhq$的常数跟$Splay$差不多 但是$fhq$的缺点也是显著，就是不能写LCT。 其他平衡树不得不说$fhq$和$Splay$两个可以维护区间操作的平衡树在常数方面完全可以以变态大的常数打爆其他平衡树（甚至包括$set$） 所以，如果不写区间操作，$set$都比$fhq$快。 完结撒花～～","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dilute.xyz/categories/学习笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://dilute.xyz/tags/数据结构/"},{"name":"平衡树","slug":"平衡树","permalink":"https://dilute.xyz/tags/平衡树/"}]},{"title":"题解 洛谷4142 洞穴遇险","slug":"Solutions/Solution-Luogu4142","date":"2019-01-10T07:13:00.000Z","updated":"2019-03-02T12:32:30.000Z","comments":true,"path":"2019/01/10/Solutions/Solution-Luogu4142/","link":"","permalink":"https://dilute.xyz/2019/01/10/Solutions/Solution-Luogu4142/","excerpt":"题外话我们模拟赛考了这题。 模拟赛大概还剩一个半小时的时候，我想出了这题，并且说 “要是我这没A掉，我就不交卷了” 于是我就没有A掉。 其实赛后半个小时左右就调出来了（我才不会告诉你我比赛的时候那个建模是有锅的呢）","text":"题外话我们模拟赛考了这题。 模拟赛大概还剩一个半小时的时候，我想出了这题，并且说 “要是我这没A掉，我就不交卷了” 于是我就没有A掉。 其实赛后半个小时左右就调出来了（我才不会告诉你我比赛的时候那个建模是有锅的呢） 大思路首先考试的时候去做另外两题 我另外两题暴力刚敲完，旁边的$Isonan$爷大吼一声 A了！ 于是我一惊，$Isonan$爷固然巨，但是考试才过了1个小时，这题似乎不难，我开始考虑正解。 我看到这$n = 50$的数据规模，我意识到这题正解估计就是网络流之类的解法 看到这个神奇的$L$字形，我们就可以往奇偶分层方面想。 鬼畜建模首先，我们马上可以想到把$x + y$为奇数的有权的点给拎出来，称为a类点 然后把剩下来无点权的点分类 如果它在偶数行，称为b类点 否则称为c类点 那么一个3*3的矩阵分类之后长这样↓ 1234567+-+-+-+|c|a|c|+-+-+-+|a|b|a|+-+-+-+|c|a|c|+-+-+-+ 然后显然，贪心地想，一个L字形必须得放在有点权的A类点上 那么感性理解一下，一个L字形肯定是由一个a一个b一个c组成的 然后继续感性理解，我们可以弄出来一个类似带权三分图匹配（大雾）之类的东西 具体是这样的 源点向源点2 连边 流量$m$费用0（最多放$m$个石头） 源点2 向 $b$连边，流量$1$ 费用$0$ 将$a$拆点 $b$ 向 $a$入点连边，流量$1$ 费用$0$ $a$ 入点向 $a$ 出点连边，流量$1​$，费用为该点的点权 $a$ 出点向 $c$ 连边，流量$1$，费用$0$ $c$ 向汇点连边，流量$1$，费用$0$ 最后跑最大费用最大流即可。 由于我以前有个假的解法，导致我的$b$和$c$类点也拆了点，所以可以不用在意，意思对就行。 需要注意的一个坑每次增广之后都应该重新统计一遍答案，因为$m$的流量不一定要流满。 代码实现具体的还是上代码吧。 实现的比较丑，轻喷。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;bits/stdc++.h&gt;#define INF 2147483647#define ll long long#define get(i, j) ((i - 1) * n + j)int inp()&#123; char c = getchar(); int neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') neg = -1; c = getchar(); &#125; int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = ((sum &lt;&lt; 3) + (sum &lt;&lt; 1)) + c - '0'; c = getchar(); &#125; return neg * sum;&#125;const int opt[10][4] = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;int head[200010];int nxt[500010];int end[500010];int value[500010];int cost[500010];int dis[200010];int prev1[200010];int prev2[200010];bool inq[200010];int q[1000010];bool dag[100][100];int w[100][100];int Cou = -1;void link(int a, int b, int v, int c)&#123; // printf(\"linked %d and %d\\n\", a, b); nxt[++Cou] = head[a]; head[a] = Cou; end[Cou] = b; value[Cou] = v; cost[Cou] = c; nxt[++Cou] = head[b]; head[b] = Cou; end[Cou] = a; value[Cou] = 0; cost[Cou] = -c;&#125;int main()&#123; memset(head, -1, sizeof(head)); int n = inp(); int m = inp(); int k = inp(); int sum = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++)&#123; w[i][j] = inp(); sum += w[i][j]; &#125; for(int i = 1; i &lt;= k; i++)&#123; int x = inp(); int y = inp(); dag[x][y] = true; &#125; int s = 0; link(s, 200001, m, 0); int e = 200000; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++)&#123; if((i + j) &amp; 1)&#123; link(get(i, j), get(i, j) + (n * n), 1, -w[i][j]); if(i &amp; 1)&#123; if(j &gt; 1) link(get(i, j) + (n * n), get(i, j - 1), 1, 0); if(j &lt; n) link(get(i, j) + (n * n), get(i, j + 1), 1, 0); &#125; else &#123; if(i &gt; 1) link(get(i, j) + (n * n), get(i - 1, j), 1, 0); if(i &lt; n) link(get(i, j) + (n * n), get(i + 1, j), 1, 0); &#125; &#125; else &#123; if(dag[i][j]) continue; link(get(i, j), get(i, j) + (n * n), 1, 0); if(i &amp; 1)&#123; link(get(i, j) + (n * n), e, 1, 0); &#125; else &#123; link(200001, get(i, j), 1, 0); for(int u = 0; u &lt; 4; u++)&#123; int tx = i + opt[u][0]; int ty = j + opt[u][1]; if(tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; n) continue; link(get(i, j) + (n * n), get(tx, ty), 1, 0); &#125; &#125; &#125; &#125; int flow = 0; int ans = 0; int f = INF; int ret = 0; while(f &gt; 0)&#123; memset(inq, false, sizeof(inq)); memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; q[1] = s; int qf = 1; int qe = 1; int sum = 0; while(qf &lt;= qe)&#123; int u = q[qf++]; inq[u] = false; sum -= dis[u]; for(int x = head[u]; x != -1; x = nxt[x])&#123; if(value[x] &gt; 0 &amp;&amp; dis[end[x]] &gt; dis[u] + cost[x])&#123; if(inq[end[x]]) sum -= dis[end[x]]; dis[end[x]] = dis[u] + cost[x]; prev1[end[x]] = u; prev2[end[x]] = x; sum += dis[end[x]]; if(!inq[end[x]])&#123; q[++qe] = end[x]; inq[end[x]] = true; &#125; &#125; &#125; &#125; // for(int i = 1; i &lt;= 20; i++) // printf(\"%d \", dis[i]); // putchar('\\n'); if(dis[e] == dis[200002]) break; int delta = f; for(int i = e; i != s; i = prev1[i])&#123; // printf(\"%d&lt;-(%d)--\", i % (n * n), value[prev2[i]]); delta = std::min(delta, value[prev2[i]]); &#125; // putchar('\\n'); f -= delta; flow += delta; ans += delta * dis[e]; for(int i = e; i != s; i = prev1[i])&#123; value[prev2[i]] -= delta; value[prev2[i] ^ 1] += delta; &#125; ret = std::min(ret, ans); &#125; printf(\"%d\", sum + ret);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://dilute.xyz/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"https://dilute.xyz/tags/费用流/"}]},{"title":"浅谈珂朵莉树","slug":"Notes/Chtholly-Tree","date":"2019-01-10T00:24:00.000Z","updated":"2019-03-02T12:27:10.000Z","comments":true,"path":"2019/01/10/Notes/Chtholly-Tree/","link":"","permalink":"https://dilute.xyz/2019/01/10/Notes/Chtholly-Tree/","excerpt":"Ⅰ 什么是珂朵莉？珂朵莉是世界上最幸福的女孩，没有之一，不接受任何反驳。","text":"Ⅰ 什么是珂朵莉？珂朵莉是世界上最幸福的女孩，没有之一，不接受任何反驳。 Ⅱ 什么是珂朵莉树？珂朵莉树又称ODT，是一种基于$std::set$ 的数据结构，复杂度其实是假的，但是在数据随机的时候可以有很好的表现。 但是珂朵莉树的使用局限性较大，非常好卡，而且如果没有区间赋值操作的话，那就是毫无用武之地。 说白了就是用$set$维护一段连续的相同元素。 Ⅲ 珂朵莉树的实现1.定义节点123456789struct Node&#123; int l; int r; mutable ll v; bool operator &lt; (const Node &amp;b) const &#123; return l &lt; b.l; &#125;&#125;;std::set&lt;Node&gt; s; 我来解释一下各部分吧。 $l, r$很显然就是这个区间的左右端点。 $v$很显然就是这个区间共同的权值。 顺便说一下$mutable$，这是个黑科技，可以让你对着迭代器直接修改里面不影响顺序的值。 然后下面那个重载运算符就是拿来为了让它在$set$里面的顺序是对的。 哦对，为了方便，我一般习惯加上这么一句： 1#define iter std::set&lt;Node&gt;::iterator 看后面代码的时候自行脑补一下吧QwQ 2.建树12for(int i = 1; i &lt;= n; i++) s.insert((Node)&#123;i, i, a[i]&#125;); 应该不用我多讲，就是把每个点当做一个连续的段暴力插入就行了。 3.核心操作1 $split$$split$操作，顾名思义，就是把原来一段的一个区间分成两段。 一般而言，$split$操作都要返回切成的两块区间的右边那段的$iterator$。 12345678910iter split(int pos)&#123; iter it = s.lower_bound((Node)&#123;pos, pos, -1&#125;); // 找到它的后一个 if (it != s.end() &amp;&amp; it-&gt;l == pos) // 如果根本无需删除，直接return return it; it--; // 因为找到的是我们需要split的后一个，所以应当分离 Node ins = *it; // 先把我们要删掉的节点存储好 s.erase(it); // 分离 = 删除 + 2 * 插入 s.insert((Node)&#123;ins.l, pos - 1, ins.v&#125;); return s.insert((Node)&#123;pos, ins.r, ins.v&#125;).first;&#125; 个人认为注释里面应该写的比较清楚了QwQ 这应该是最难懂的部分了，如果这部分看懂了接下来的就不难了。 4.核心操作2 $assign$$assign$操作虽然有个很好听的名字：推平一段区间 但是实际上，就是个区间赋值。 那为什么说$assign$操作也是珂朵莉树的核心操作呢？ 因为珂朵莉树的复杂度是由它保证的。 一次$assign$操作就会是$set$的规模大幅度减少，而且保证数据随机的情况下，$assign$操作出现的概率不小，而且一次的范围也很大，会让$set$的规模一直在一个很小的范围里。（毕竟人家$split$一次才多一个，$assign$一下直接一段区间就推平了） 给上代码～ 123456void assign(int l, int r, ll v)&#123; iter it_r = split(r + 1); iter it_l = split(l); s.erase(it_l, it_r); // 这样子就可以erase一个区间了 s.insert((Node)&#123;l, r, v&#125;);&#125; 特别短小精悍有木有？ 其他常用操作我们这边就以珂朵莉树公认模板题$Willem, Chtholly\\ and\\ Seniorious$来做例子了 原题传送门：&gt;Here&lt; 5.区间加暴力加。 把两端$split$出来，然后，把中间的所有$iterator$里的$v$全都加上$c$。 然后我们之前假的$mutable$标记就可以用上了（ 1234567void modify(ll l, ll r, ll c)&#123; iter it_r = split(r + 1); iter it_l = split(l); for(iter it = it_l; it != it_r; it++) it-&gt;v += c;&#125; 又一个一个for循环解决的操作 接下来的操作就可以体现出珂朵莉树的强大了。 6.求$\\displaystyle\\sum_{i = l}^{r} a_i^x$12345678910ll query(int l, int r, ll x, ll y)&#123; iter it_l = split(l); iter it_r = split(r + 1); ll ans = 0; for(iter it = it_l; it != it_r; it++)&#123; ans += (ll)(it-&gt;r - it-&gt;l + 1) * powmod(it-&gt;v, x, y); ans %= y; &#125; return ans;&#125; 快速幂大家应该都会，应该不会有人没学快速幂就来学这种DL数据结构吧，我就不贴了。 恩，就是这么暴力，把每段区间取出来，把每个元素的$x$次方算出来，乘上这个连续段的长度，加起来，显然就是答案了。 7.区间第k大123456789101112131415161718192021222324struct Node2&#123; ll len; ll v;&#125;;bool cmp(Node2 a, Node2 b)&#123; return a.v &lt; b.v;&#125;ll k_query(ll l, ll r, ll k)&#123; std::vector&lt;Node2&gt; q; q.clear(); iter it_l = split(l); iter it_r = split(r + 1); for(iter it = it_l; it != it_r; it++) q.push_back((Node2)&#123;it-&gt;r - it-&gt;l + 1, it-&gt;v&#125;); std::sort(q.begin(), q.end(), cmp); ll sum = 0; for(std::vector&lt;Node2&gt;::iterator it = q.begin(); it != q.end(); it++)&#123; sum += it-&gt;len; if(sum &gt;= k) return it-&gt;v; &#125; return -1;&#125; 这个稍微复杂一点，但是实际上还是暴力。 把所有元素取出来，记录一下每个元素出现的数量。 然后把元素排个序，就可以愉快的找到第$k$大了。 至此，$CF896C$的所有操作都讲完了。 这边我顺便贴一下$CF896C$的完整代码把 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;#define ll long long#define INF 2147483647#define iter std::set&lt;Node&gt;::iteratorll n, m;ll seed, vmax;ll rnd()&#123; ll ret = seed; seed = (seed * 7 + 13) % 1000000007; return ret;&#125;struct Node&#123; ll l; ll r; mutable ll v; bool operator &lt; (const Node &amp;b) const &#123; return l &lt; b.l; &#125;&#125;;std::set&lt;Node&gt; s;iter split(ll pos)&#123; iter it = s.lower_bound((Node)&#123;pos, pos, -1&#125;); if (it != s.end() &amp;&amp; it-&gt;l == pos) return it; it--; Node ins = *it; s.erase(it); s.insert((Node)&#123;ins.l, pos - 1, ins.v&#125;); return s.insert((Node)&#123;pos, ins.r, ins.v&#125;).first;&#125;void assign(ll l, ll r, ll v)&#123; iter it_l = split(l), it_r = split(r + 1); s.erase(it_l, it_r); s.insert((Node)&#123;l, r, v&#125;);&#125;ll powmod(ll a, ll b, ll mod)&#123; a %= mod; ll sum = 1; while(b)&#123; if(b &amp; 1)&#123; sum *= a; sum %= mod; &#125; a *= a; a %= mod; b &gt;&gt;= 1; &#125; return sum;&#125;ll query(ll l, ll r, ll x, ll y)&#123; iter it_l = split(l); iter it_r = split(r + 1); ll ans = 0; for(iter it = it_l; it != it_r; it++)&#123; // prllf(\"[%d %d] -&gt; %d\\n\", it-&gt;l, it-&gt;r, it-&gt;v); ans += (ll)(it-&gt;r - it-&gt;l + 1) * powmod(it-&gt;v, x, y); ans %= y; &#125; return ans;&#125;void modify(ll l, ll r, ll c)&#123; iter it_l = split(l); iter it_r = split(r + 1); for(iter it = it_l; it != it_r; it++)&#123; // Node ins = *it; // ins.v += c; // s.erase(it); // s.insert(ins); // it = s.find(ins); it-&gt;v += c; &#125;&#125;struct Node2&#123; ll len; ll v;&#125;;bool cmp(Node2 a, Node2 b)&#123; return a.v &lt; b.v;&#125;ll k_query(ll l, ll r, ll k)&#123; std::vector&lt;Node2&gt; q; q.clear(); iter it_l = split(l); iter it_r = split(r + 1); for(iter it = it_l; it != it_r; it++) q.push_back((Node2)&#123;it-&gt;r - it-&gt;l + 1, it-&gt;v&#125;); std::sort(q.begin(), q.end(), cmp); ll sum = 0; for(std::vector&lt;Node2&gt;::iterator it = q.begin(); it != q.end(); it++)&#123; sum += it-&gt;len; if(sum &gt;= k) return it-&gt;v; &#125; return -1;&#125;ll a[100010];int main()&#123; std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax; for(ll i = 1; i &lt;= n; i++) a[i] = rnd() % vmax + 1; for(int i = 1; i &lt;= n; i++) s.insert((Node)&#123;i, i, a[i]&#125;); s.insert((Node)&#123;n + 1, n + 1, 0&#125;); int cnt = 0; for(ll i = 1; i &lt;= m; i++)&#123; ll type = (rnd() % 4) + 1; ll l = (rnd() % n) + 1; ll r = (rnd() % n) + 1; ll x, y; if(l &gt; r) std::swap(l, r); if(type == 3) x = (rnd() % (r - l + 1)) + 1; else x = (rnd() % vmax) + 1; if(type == 4) y = (rnd() % vmax) + 1; if(type == 1)&#123; modify(l, r, x); &#125; else if(type == 2)&#123; assign(l, r, x); &#125; else if(type == 3)&#123; printf(\"%I64d\\n\", k_query(l, r, x)); cnt++; &#125; else if(type == 4)&#123; printf(\"%I64d\\n\", query(l, r, x, y)); cnt++; &#125; &#125;&#125; 为什么感觉一大半代码都是随机数生成器的 Ⅳ 可以使用珂朵莉树的其他题目例题1 给定一个仅包含小写字母的字符串。 资瓷区间排序 求$m$次排序之后的字符串。 这题的正常做法是线段树维护一个桶，然后在排序的时候进行26次的查询与修改。 这样的话虽然理论复杂度是$O(n \\log n)$的，但是带一个$26$的大常数，极易造成卡常。 如果使用珂朵莉树的话，我们可以用类似这种线段树的做法，查询每个字母出现的数量，再进行26次区间修改操作。 于是我们可以发现，一次排序之后，这一段区间最后只会被分成$26$个$set$中元素，规模完全可以接受。 实测在数据随机的情况下，珂朵莉树暴打$O(n \\log * 26)$的标算。 （这是我们某次模拟赛的题目） （结果标算T飞了，时限开到7s都拯救不了，而某位dalao同学spfa使用珂朵莉树A了，A了就算了，还快的飞起，于是该同学之后不久改名叫做Chtholly_Tree，并留下一句名言：） 模拟赛使我相信珂学。 例题2&gt;Here&lt; 一个长度为$10^9$的0-1串，初始值全为$1$ 资瓷区间修改为0或者为1 求每次修改之后$1$的个数。 这道题目正统做法是动态开点线段树。 但是显然区间修改让我们往珂朵莉树方面去想 我们只需要让珂朵莉树资瓷$assign$还有区间求和就行了 Ⅴ 总结-珂朵莉树的优缺点优点： 码量小 易于理解 能够资瓷大量操作 缺点： 使用局限性较大 容易被卡 珂朵莉树的功能极其强大，可以说只要可以暴力做的它都能做，但是只要没有区间复制操作，那么它比暴力还多只$\\log$，而且只要出题人有这个心，完全可以把你卡满，但是它作为一种骗分技巧还是非常实用的，很重要的是它学起来很简单，而且大概$10min$（也许更短？）就可以敲完。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dilute.xyz/categories/学习笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://dilute.xyz/tags/数据结构/"}]},{"title":"题解 CF1096G Lucky Tickets","slug":"Solutions/Solution-CF1096G","date":"2018-12-29T00:53:00.000Z","updated":"2019-03-02T12:36:18.000Z","comments":true,"path":"2018/12/29/Solutions/Solution-CF1096G/","link":"","permalink":"https://dilute.xyz/2018/12/29/Solutions/Solution-CF1096G/","excerpt":"其实我很想吐槽这题 我比赛的时候疯狂$\\text{WA on test 16}​$ 然后死活找不出来哪儿错了 我觉得我数组开小了 于是我开到$MLE$都没有过掉 最后一看 被一个n = 2的点卡掉了…… 才出4题，罚时爆炸，上黄失败，掉分哭唧唧","text":"其实我很想吐槽这题 我比赛的时候疯狂$\\text{WA on test 16}​$ 然后死活找不出来哪儿错了 我觉得我数组开小了 于是我开到$MLE$都没有过掉 最后一看 被一个n = 2的点卡掉了…… 才出4题，罚时爆炸，上黄失败，掉分哭唧唧 首先我们看到题，我们可以想到一个朴素的$DP$方法： 我们用$f[i][j]$来表示在前$i$个里面取到和为$j$的方案数 然后我们可以列出$DP$方程，即$f[i][j] = \\displaystyle\\sum_{u = 1}^{k} f[i - 1][j - d[u]]$ 那么显然，答案就是$\\displaystyle \\sum_{i = 1}^{n * 5}f[\\frac{n}{2}][i] $ 然而这个朴素的DP是$O(n^2)$的 我们考虑如何优化这个$DP$方程 我们想想看卷积的公式 $c[i] = \\displaystyle \\sum_{j = 0}^{i} a[j] * b[i - j]$ 我们再试着改写一下原来的$DP$方程 我们令$g[u]$为$1$当且仅当$u \\in d$，否则$g[u] = 0$ 那么式子就可以改写成 $f[i][j] = \\displaystyle\\sum_{u = 1}^{j} f[i - 1][j - u] * g[u]$ 我一看，这下子$f[i]$不就是$f[i - 1]$和$g$这两个多项式的卷积了吗 我们再考虑$f[0]$，显然$f[0] = {1, 0, 0, 0… }$ 然后我们发现任何多项式乘上$f[0]$都等于它本身 于是我们发现最终的答案就是$g$这个多项式的$\\frac{n}{2}$次幂 然后我们就可以愉快的用多项式快速幂解决这个问题了 注意多项式的长度要动态开，否则会T飞～ 这里我用的是$NTT$，毕竟模数是$998244353$，取模比起$FFT$方便不少… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;// o^r^z w^x^w#define ll long long#define INF 2147483647#define mod 998244353int pi = acos(-1);const int G = 3;inline int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;ll powmod(ll a, int b)&#123; ll sum = 1; while(b)&#123; if(b &amp; 1)&#123; sum *= a; sum %= mod; &#125; a *= a; a %= mod; b &gt;&gt;= 1; &#125; return sum;&#125;int g[8000010], num[8000010];int len, r[8000010];int a[8000010], b[8000010], c[8000010];int wn[8000010];int invlim;#define add(a, b) ((a) + (b) &gt;= mod ? (a) + (b) - mod : (a) + (b))#define mine(a, b) ((a) &lt; (b) ? (a) - (b) + mod : (a) - (b))#define mul(a, b) ((ll)(a) * (ll)(b) % mod)inline void ntt(int *a, int f)&#123; for(int i = 0; i &lt; len; i++) if(i &lt; r[i]) std::swap(a[i], a[r[i]]); for(int i = 1; i &lt; len; i &lt;&lt;= 1)&#123; wn[0] = 1; wn[1] = powmod(G, (mod - 1) / (i &lt;&lt; 1)); for(int j = 2; j &lt; i; j++) wn[j] = mul(wn[j - 1], wn[1]); for(int j = 0; j &lt; len; j += i &lt;&lt; 1)&#123; int *L = a + j; int *R = L + i; for(int k = 0; k &lt; i; k++)&#123; const int t = mul(wn[k], R[k]); R[k] = mine(L[k], t); L[k] = add(L[k], t); &#125; &#125; &#125; if(f == -1)&#123; std::reverse(a + 1, a + len); for(int i = 0; i &lt; len; i++) a[i] = mul(a[i], invlim); &#125;&#125;void init(int n)&#123; len = 1; int lg = 0; while(len &lt;= n) len &lt;&lt;= 1, lg++; for(int i = 0; i &lt; len; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (lg - 1)); invlim = powmod(len, mod - 2);&#125;int main()&#123; int n = inp() &gt;&gt; 1; int k = inp(); memset(g, 0, sizeof(g)); for(int i = 1; i &lt;= k; i++)&#123; int x = inp(); g[x] = 1; &#125; int pownum = n - 1; memcpy(num, g, sizeof(g)); init(20); while(pownum)&#123; // printf(\"%d\\n\", pownum); if(pownum &amp; 1)&#123; int maxw = 0; for(int i = 1; i &lt;= 5000000; i++) if(g[i] &gt; 0) maxw = i; init(maxw &lt;&lt; 2); ntt(g, 1); ntt(num, 1); for(int i = 0; i &lt;= len; i++) num[i] = mul(num[i], g[i]); ntt(g, -1); ntt(num, -1); &#125; int maxw = 0; for(int i = 1; i &lt;= 5000000; i++) if(g[i] &gt; 0) maxw = i; init(maxw &lt;&lt; 2); ntt(g, 1); for(int i = 0; i &lt;= len; i++) g[i] = mul(g[i], g[i]); ntt(g, -1); pownum &gt;&gt;= 1; &#125; int ans = 0; for(int i = 0; i &lt;= len; i++) ans = add(ans, mul(num[i], num[i])); printf(\"%d\\n\", ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"},{"name":"数论，数学","slug":"数论，数学","permalink":"https://dilute.xyz/tags/数论，数学/"},{"name":"NTT","slug":"NTT","permalink":"https://dilute.xyz/tags/NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://dilute.xyz/tags/多项式/"}]},{"title":"题解 CF1095D Circular Dance","slug":"Solutions/Solution-CF1095D","date":"2018-12-28T09:12:00.000Z","updated":"2019-03-02T12:31:44.000Z","comments":true,"path":"2018/12/28/Solutions/Solution-CF1095D/","link":"","permalink":"https://dilute.xyz/2018/12/28/Solutions/Solution-CF1095D/","excerpt":"我们令$fa[i]$为$i$直接连向的点 那么显然，$fa[i] \\in {a_{i, 1}, a_{i, 2}}​$ 假设$a_{i, 1}$为$fa[i]$，那么$a_{2, i} \\in { a_{fa[i], 1}, a_{fa[i], 2} }$ 否则肯定有$a_{2, i} \\not\\in { a_{fa[i], 1}, a_{fa[i], 2} }$ 所以，如果有$a_{2, i} \\in { a_{fa[i], 1}, a_{fa[i], 2} }$，那么$fa[i] = a_{i, 1}$，否则$fa[i] = a_{i, 2}$","text":"我们令$fa[i]$为$i$直接连向的点 那么显然，$fa[i] \\in {a_{i, 1}, a_{i, 2}}​$ 假设$a_{i, 1}$为$fa[i]$，那么$a_{2, i} \\in { a_{fa[i], 1}, a_{fa[i], 2} }$ 否则肯定有$a_{2, i} \\not\\in { a_{fa[i], 1}, a_{fa[i], 2} }$ 所以，如果有$a_{2, i} \\in { a_{fa[i], 1}, a_{fa[i], 2} }$，那么$fa[i] = a_{i, 1}$，否则$fa[i] = a_{i, 2}$ 按照这个模拟即可 接下来送上代码 最后还有一点 在n = 3的时候上述方法是不适用的。 但是显然，n = 3 的时候随便输出一个环都能是答案 但是用这个方法可能构造出一个$n \\leq 2$的环…… 反正这个特判不加会$\\color{red}\\text{WA on test 13}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define INF 2147483647#define ll long longinline int inp()&#123; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); int sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum;&#125;int a1[200010];int a2[200010];int fa[200010];inline bool rel(int a, int b)&#123; // 判断b是否有 b ∈ &#123; a_&#123;a1&#125;, a_&#123;a2&#125; &#125; return (b == a1[a] || b == a2[a]);&#125;int main()&#123; int n = inp(); if(n == 3)&#123; printf(\"1 2 3\"); return 0; &#125; for(int i = 1; i &lt;= n; i++)&#123; a1[i] = inp(); a2[i] = inp(); &#125; for(int i = 1; i &lt;= n; i++)&#123; if(rel(a1[i], a2[i])) fa[i] = a1[i]; else fa[i] = a2[i]; &#125; int cur = 1; while(fa[cur] != 1)&#123; printf(\"%d \", cur); cur = fa[cur]; &#125; printf(\"%d\\n\", cur);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://dilute.xyz/tags/构造/"}]},{"title":"题解 洛谷P5003 跳舞的线-乱拐弯","slug":"Solutions/Solution-Luogu5003","date":"2018-11-21T08:21:00.000Z","updated":"2019-03-02T12:32:38.000Z","comments":true,"path":"2018/11/21/Solutions/Solution-Luogu5003/","link":"","permalink":"https://dilute.xyz/2018/11/21/Solutions/Solution-Luogu5003/","excerpt":"一道有点套路化的网格图上$DP$QwQ我们用$f_{min}[i][j][0]$表示线头在$(i, j)$这个点的时候，线的方向朝下，我们能取到的最小的拐弯次数、用$f_{min}[i][j][1]$表示线头在$(i, j)$这个点的时候，显得方向朝右，能够取到的最小的拐弯次数 同理，我们用$f_{max}[i][j][0]$与$f_{max}[i][j][1]$表示线头在$(i, j)$位置是线朝下和朝右能够取到的最大的拐弯次数。 接下来，对于有障碍的点，我们直接不处理 显然，答案分别为$\\max(f_{max}[n][m][0], f_{max}[n][m][1])$与$\\min(f_{min}[n][m][0], f_{min}[n][m][1])$","text":"一道有点套路化的网格图上$DP$QwQ我们用$f_{min}[i][j][0]$表示线头在$(i, j)$这个点的时候，线的方向朝下，我们能取到的最小的拐弯次数、用$f_{min}[i][j][1]$表示线头在$(i, j)$这个点的时候，显得方向朝右，能够取到的最小的拐弯次数 同理，我们用$f_{max}[i][j][0]$与$f_{max}[i][j][1]$表示线头在$(i, j)$位置是线朝下和朝右能够取到的最大的拐弯次数。 接下来，对于有障碍的点，我们直接不处理 显然，答案分别为$\\max(f_{max}[n][m][0], f_{max}[n][m][1])$与$\\min(f_{min}[n][m][0], f_{min}[n][m][1])$ 接下来，我们就可以写出状态转移方程辣 $f_{min}[i][j][0] = \\min(f_{min}[i - 1][j][0], f_{min}[i - 1][j][1] + 1)$$f_{min}[i][j][1] = \\min(f_{min}[i][j - 1][1], f_{min}[i][j - 1][0] + 1)$ $f_{max}[i][j][0] = \\max(f_{max}[i - 1][j][0], f_{max}[i - 1][j][1] + 1)$$f_{max}[i][j][1] = \\max(f_{max}[i][j - 1][1], f_{max}[i][j - 1][0] + 1)$ 注意初始化，$f_{min}$初始化为$\\inf$，$f_{max}$初始化为-1，注意边界~~ 上代码QwQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Sooke bless me.// LJC00118 bless me.#include&lt;bits/stdc++.h&gt;#define INF 1000000000#define ll long longint Inp()&#123; char c = getchar(); int Neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') Neg = -1; c = getchar(); &#125; int Sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; Sum = ((Sum &lt;&lt; 3) + (Sum &lt;&lt; 1)) + c - '0'; c = getchar(); &#125; return Neg * Sum;&#125;int f_max[1010][1010][3];int f_min[1010][1010][3]; char s[1010][1010];int main()&#123; int n = Inp(); int m = Inp(); for(int i = 1; i &lt;= n; i++) scanf(\"%s\", s[i] + 1); for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= m; j++)&#123; f_max[i][j][0] = f_max[i][j][1] = -1; f_min[i][j][0] = f_min[i][j][1] = INF; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++)&#123; if(s[i][j] == '#') continue; if(i == 1 &amp;&amp; j == 1)&#123; f_max[1][1][0] = f_max[1][1][1] = 0; f_min[1][1][0] = f_min[1][1][1] = 0; continue; &#125; f_min[i][j][0] = std::min(f_min[i - 1][j][0], f_min[i - 1][j][1] + 1); f_min[i][j][1] = std::min(f_min[i][j - 1][1], f_min[i][j - 1][0] + 1); f_max[i][j][0] = std::max(f_max[i - 1][j][0], f_max[i - 1][j][1] + 1); f_max[i][j][1] = std::max(f_max[i][j - 1][1], f_max[i][j - 1][0] + 1); &#125; if(std::min(f_min[n][m][0], f_min[n][m][1]) == INF)&#123; printf(\"-1\"); return 0; &#125; printf(\"%d %d\", std::max(f_max[n][m][0], f_max[n][m][1]) - 1, std::min(f_min[n][m][0], f_min[n][m][1]));&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"}]},{"title":"题解 CF1070H BerOS File Suggestion","slug":"Solutions/Solution-CF1070H","date":"2018-11-19T05:34:00.000Z","updated":"2019-03-02T12:30:38.000Z","comments":true,"path":"2018/11/19/Solutions/Solution-CF1070H/","link":"","permalink":"https://dilute.xyz/2018/11/19/Solutions/Solution-CF1070H/","excerpt":"对于这题，看到字符串匹配，第一反应想到字符串hash，同时看到$len \\leq 8 $ ，考虑对于先给出的$n$个字符串，$O(len^2)$枚举它的子串，将其加入$map$中，但是要注意如果一个然后对于每个字符串，我们都统计一下它最后一次出现在哪里（于是就可以顺便判一下重） 然后我们在询问的时候，就可以直接输出这个字符串对应的出现次数以及最后一处出现的位置啦QwQ","text":"对于这题，看到字符串匹配，第一反应想到字符串hash，同时看到$len \\leq 8 $ ，考虑对于先给出的$n$个字符串，$O(len^2)$枚举它的子串，将其加入$map$中，但是要注意如果一个然后对于每个字符串，我们都统计一下它最后一次出现在哪里（于是就可以顺便判一下重） 然后我们在询问的时候，就可以直接输出这个字符串对应的出现次数以及最后一处出现的位置啦QwQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Sooke bless me.// LJC00118 bless me.#include&lt;bits/stdc++.h&gt;#define INF 2147483647#define ll long longint Inp()&#123; char c = getchar(); int Neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') Neg = -1; c = getchar(); &#125; int Sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; Sum = ((Sum &lt;&lt; 3) + (Sum &lt;&lt; 1)) + c - '0'; c = getchar(); &#125; return Neg * Sum;&#125;std::map &lt;std::string, int&gt; Cnt; // 出现次数std::map &lt;std::string, int&gt; Ans; // 最后一次出现位置std::string s[10010];int main()&#123; int n = Inp(); for(int i = 1; i &lt;= n; i++)&#123; std::cin &gt;&gt; s[i]; int Len = s[i].size(); for(int j = 1; j &lt;= Len; j++) for(int u = 0; u &lt;= Len - j; u++)&#123; if(Ans[s[i].substr(u, j)] != i)&#123; Cnt[s[i].substr(u, j)]++; Ans[s[i].substr(u, j)] = i; &#125; &#125; &#125; int m = Inp(); for(int i = 1; i &lt;= m; i++)&#123; std::string str; std::cin &gt;&gt; str; printf(\"%d \", Cnt[str]); if(Cnt[str] == 0) printf(\"-\\n\"); else std::cout &lt;&lt; s[Ans[str]] &lt;&lt; std::endl; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://dilute.xyz/tags/哈希/"},{"name":"字符串","slug":"字符串","permalink":"https://dilute.xyz/tags/字符串/"},{"name":"STL","slug":"STL","permalink":"https://dilute.xyz/tags/STL/"}]},{"title":"题解 洛谷P3022 [USACO11OPEN]奇数度Odd degrees","slug":"Solutions/Solution-Luogu3022","date":"2018-11-18T12:22:00.000Z","updated":"2019-03-02T12:32:26.000Z","comments":true,"path":"2018/11/18/Solutions/Solution-Luogu3022/","link":"","permalink":"https://dilute.xyz/2018/11/18/Solutions/Solution-Luogu3022/","excerpt":"我感觉思路隔壁题解给的不够清楚啊…… 感觉我无法直接理解隔壁dalao的“正经的图上神搜”啊…… 那本蒟蒻就补充一下吧QwQ","text":"我感觉思路隔壁题解给的不够清楚啊…… 感觉我无法直接理解隔壁dalao的“正经的图上神搜”啊…… 那本蒟蒻就补充一下吧QwQ 这题的思路是这样的： 我们先不考虑断边，而是考虑连尽量多的边 继续考虑，对于每一个点，我们都考虑，对于它搜索过来的边（下文称其为“入边”），我们要不要连上，如果需要，那么我们的$Dfs()$函数返回值为$true$，否则为$true$ 再考虑入边之外的其他点。对于深搜搜到每一个点的时候，我们都考虑与它相邻且未被搜索的点，如果对于这些点，需要连上“入边”，我们就把当前搜索的这个点的度加上1 在搜索完与它相邻的点之后，我们看一看这个点的度，如果它已经是奇数度的话，我们就不需要连上它的入边了（$return$ $false$），否则则需要连上入边，我们需要将当前这个点的入边加入答案，然后$return$ $true$ 对于主函数，我们只需要将每个联通块都搜一遍即可QwQ，最后还有一点需要注意的，就是我们需要在搜索到每一个联通块的时候，如果发现一开始$Dfs$的返回值就是$true$了，但是！这个点没有入边，所以就无解辣QwQ 最后放上与隔壁大佬超级像的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Sooke bless me.// LJC00118 bless me.#include&lt;bits/stdc++.h&gt;#define INF 2147483647#define ll long longint Inp()&#123; char c = getchar(); int Neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') Neg = -1; c = getchar(); &#125; int Sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; Sum = ((Sum &lt;&lt; 3) + (Sum &lt;&lt; 1)) + c - '0'; c = getchar(); &#125; return Neg * Sum;&#125;int Head[50010], Next[400010], End[400010];bool Used[50010];int Ans[50010], Index = 0;int Cou = 0;void Link(int a, int b)&#123; Next[++Cou] = Head[a]; Head[a] = Cou; End[Cou] = b;&#125;bool Dfs(int Cur, int Edge)&#123; Used[Cur] = true; int Degree = 0; for(int x = Head[Cur]; x != -1; x = Next[x])&#123; if(Used[End[x]]) continue; if(Dfs(End[x], x)) Degree++; &#125; if(Degree % 2 == 1) return false; Ans[++Index] = (Edge + 1) &gt;&gt; 1; return true;&#125;int main()&#123; memset(Head, -1, sizeof(Head)); int n = Inp(); int m = Inp(); for(int i = 1; i &lt;= m; i++)&#123; int a = Inp(); int b = Inp(); Link(a, b); Link(b, a); &#125; for(int i = 1; i &lt;= n; i++) if(!Used[i]) if(Dfs(i, -1))&#123; printf(\"-1\"); return 0; &#125; std::sort(Ans + 1, Ans + Index + 1); printf(\"%d\", Index); for(int i = 1; i &lt;= Index; i++) printf(\"\\n%d\", Ans[i]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://dilute.xyz/tags/DFS/"},{"name":"图论","slug":"图论","permalink":"https://dilute.xyz/tags/图论/"}]},{"title":"我来了，我出锅了，我走了——NOIp2018游记","slug":"Other/NOIp2018-Journey","date":"2018-11-18T05:03:00.000Z","updated":"2019-03-20T04:10:02.000Z","comments":true,"path":"2018/11/18/Other/NOIp2018-Journey/","link":"","permalink":"https://dilute.xyz/2018/11/18/Other/NOIp2018-Journey/","excerpt":"Day （不想算）将RP耗尽在了初赛QwQ Day 0教练说这天Openday，随便打游戏，于是上午随手把最大流、费用流、树剖三个听说可能会考的板子给敲了一遍于是就去跟同学颓了一天的LOL","text":"Day （不想算）将RP耗尽在了初赛QwQ Day 0教练说这天Openday，随便打游戏，于是上午随手把最大流、费用流、树剖三个听说可能会考的板子给敲了一遍于是就去跟同学颓了一天的LOL Day 1来到学车中学，开考前随便跟同学奶了奶算法 照例解压，深吸一口气，打开题目。 看到T1，第一眼：卧槽这是什么玩意儿 第二眼：完了这是D1T1吗我要爆零了 第三眼（仔细一看）：这题好像有点眼熟？ 第四眼：这不是我们模拟赛做过的某题的弱化版吗？ 然而由于我太蒻了，我不会模拟赛的那道神仙题，于是找起了规律 我觉得可能跟差分有关系，于是就试着把数组的差分数据加起来，结果发现除了样例什么都过不了 于是我试着把最后一位加了上去，然后发现所有数据都大了一倍 于是我把答案除了个2，不管怎么证明，就去看T2了 看完题目，我开始大胆猜测：答案肯定是原先给出的集合的子集 然后xjb推了一番，采用显然法，得出一个数可以去掉当且仅当它可以被比他小的数表示出来 于是打了个好像是背包的奇怪DP，乱搞了一通，水过了大样例，就去看T3了 瞅了一眼T3，想到了一个$O(n^2)$的做法，结果正准备开始写的时候发现把题目重新看了一遍，卧槽，这路径不能重合的啊 之后，花了大概半个小时左右敲了$m = 1$的找直径和一条链的二分答案 估计得分 100 + 100 + 40 = 240 pts Day 2保持心态，一路上只是奶奶算法而已 正当大家奶的正欢时，一道响亮的声音划过长空 杨英豪：“我奶今年T1动态仙人掌，T2树链剖分套主席树套珂朵莉树，T3动态DP！” 大家也只是笑笑，没当真 进考场 开考，照例解压，看T1 看了看，先花了10分钟把树的情况贪心敲完了 接下来开始想基环树 于是我画了一草稿纸的基环树 终于发现其实只要枚举断那条边其实就可以了 看T2,一看，n这么小，m这么大，理所当然想到对每一列进行状压，于是画了30min敲了一个状压 然后一看，卧槽，除了$n = 2$的数据啥都过不了 接下来头铁手玩杠了一波$n = m = 3$的样例，结果发现状压就是过不了的 （手玩 + 找状压错误原因花费40min） 结果发现在$n \\geq 3$，会出现这种毒瘤情况： 恩，我没办法解决，敲暴力…… 这暴力还真是难敲…… 敲完暴力，顺手打了几个表，离考试结束只有一个小时多一些了 然后开始写T3，一看 世界沉默了。。。 这TM不就是动态DP吗！！！ （心中开始疯狂诅咒杨英豪） 手速爆发写了个$O(n^2)$树状DP 瞪了一眼数据约定，写了个只有一个深度$\\leq$ 300且其中一个询问为1 1的从询问点向根更新的$O(\\texttt{深度})$算法，打文件，交卷。 估计得分 100 + 50 + 52 = 202 pts Day 3开始讨论题目，发现 卧槽D1T2我的统计方案数是阶乘级的？会挂？ 卧槽D1T3其实二分 + 树状DP其实就能过了？ 卧槽D2T1我的复杂度会变成$O(n^2 \\log n)$？ 各种爆炸之后…… $luogu$估分 100 + 70 + 40 + 76 + 55 + 52 = 393 pts 作为一个初三党，第一次参加NOIp，感觉心态上还是出了点问题…… 明年再战吧 1Dilute.zibi = true; Day 11成绩出了…… $CCF$数据竟然有100 + 90 + 40 + 88 + 50 + 52 = 420 pts 这次$CCF$真的是用脚造的数据啊QwQ","categories":[{"name":"游记","slug":"游记","permalink":"https://dilute.xyz/categories/游记/"}],"tags":[{"name":"瞎写","slug":"瞎写","permalink":"https://dilute.xyz/tags/瞎写/"}]},{"title":"题解 CF1068B LCM","slug":"Solutions/Solution-CF1068B","date":"2018-11-17T09:00:00.000Z","updated":"2019-03-02T12:30:14.000Z","comments":true,"path":"2018/11/17/Solutions/Solution-CF1068B/","link":"","permalink":"https://dilute.xyz/2018/11/17/Solutions/Solution-CF1068B/","excerpt":"第一篇题解 我们都知道$lcm(a, b) = \\frac{a * b}{\\gcd(a, b)}$ ∴ $\\frac{lcm(a, b)}{a} = \\frac{\\frac{a * b}{\\gcd(a, b)}}{a} = \\frac{b}{\\gcd(a, b)}$ 题目的意思就被我们转化成了求$\\frac{b}{\\gcd(a, b)}$的种类数 又∵b是一个确定的数 ∴$\\frac{b}{\\gcd(a, b)}$的种类数就等于$\\gcd(a, b)$的种类数 由于$a$的范围在$[1, 10^{18}]$范围内，所以$\\gcd(a, b)$的种类数就等于b的因数个数。 因数个数就可以$O(\\sqrt n)$求辣QwQ","text":"第一篇题解 我们都知道$lcm(a, b) = \\frac{a * b}{\\gcd(a, b)}$ ∴ $\\frac{lcm(a, b)}{a} = \\frac{\\frac{a * b}{\\gcd(a, b)}}{a} = \\frac{b}{\\gcd(a, b)}$ 题目的意思就被我们转化成了求$\\frac{b}{\\gcd(a, b)}$的种类数 又∵b是一个确定的数 ∴$\\frac{b}{\\gcd(a, b)}$的种类数就等于$\\gcd(a, b)$的种类数 由于$a$的范围在$[1, 10^{18}]$范围内，所以$\\gcd(a, b)$的种类数就等于b的因数个数。 因数个数就可以$O(\\sqrt n)$求辣QwQ 12345678910111213141516171819202122232425262728293031323334353637383940// Sooke bless me.// LJC00118 bless me.#include&lt;bits/stdc++.h&gt;#define INF 2147483647#define ll long longll Inp()&#123; char c = getchar(); ll Neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') Neg = -1; c = getchar(); &#125; ll Sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; Sum = ((Sum &lt;&lt; 3) + (Sum &lt;&lt; 1)) + c - '0'; c = getchar(); &#125; return Neg * Sum;&#125;int main()&#123; ll n = Inp(); ll qn = sqrt(n); ll Ans = 1; for(ll i = 2; i &lt;= qn; i++)&#123; ll Cnt = 1; while(n % i == 0)&#123; n /= i; Cnt++; &#125; Ans *= Cnt; &#125; if(n &gt; 1)&#123; Ans *= 2; &#125; printf(\"%lld\", Ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"数论，数学","slug":"数论，数学","permalink":"https://dilute.xyz/tags/数论，数学/"}]},{"title":"题解 CF1077C Good Array","slug":"Solutions/Solution-CF1077C","date":"2018-11-17T09:00:00.000Z","updated":"2019-03-02T12:30:52.000Z","comments":true,"path":"2018/11/17/Solutions/Solution-CF1077C/","link":"","permalink":"https://dilute.xyz/2018/11/17/Solutions/Solution-CF1077C/","excerpt":"显然，我们可以发现一个序列是“好的”当且仅当这个序列中的最大值等于这个序列中的其他数之和相加，所以我们只需要保证序列单调递减，同时维护一下这个序列里面元素之和我们就可以$O(1)$判断一个序列是不是“好的”序列（$a_1 = Sum - a_1$） 由于题目要求求出去掉哪些元素之后，这个序列会变为一个“好的”序列，所以我们只需要把原序列排序之后再按照刚刚说过的办法$O(1)$判断，只需要吧把原序列之中的$Sum$减去我们需要去掉的元素即可 还有一点需要注意，我们需要特判去掉第一个的情况，这样删去后最大值就是原先的次大数，即$a_2$ 上代码QwQ","text":"显然，我们可以发现一个序列是“好的”当且仅当这个序列中的最大值等于这个序列中的其他数之和相加，所以我们只需要保证序列单调递减，同时维护一下这个序列里面元素之和我们就可以$O(1)$判断一个序列是不是“好的”序列（$a_1 = Sum - a_1$） 由于题目要求求出去掉哪些元素之后，这个序列会变为一个“好的”序列，所以我们只需要把原序列排序之后再按照刚刚说过的办法$O(1)$判断，只需要吧把原序列之中的$Sum$减去我们需要去掉的元素即可 还有一点需要注意，我们需要特判去掉第一个的情况，这样删去后最大值就是原先的次大数，即$a_2$ 上代码QwQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Sooke bless me.// LJC00118 bless me.#include&lt;bits/stdc++.h&gt;#define INF 2147483647#define ll long longint Inp()&#123; char c = getchar(); int Neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') Neg = -1; c = getchar(); &#125; int Sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; Sum = ((Sum &lt;&lt; 3) + (Sum &lt;&lt; 1)) + c - '0'; c = getchar(); &#125; return Neg * Sum;&#125;struct Node&#123; ll x; int k;&#125;s[200010];bool Cmp(Node a, Node b)&#123; return a.x &gt; b.x;&#125;int Ans[200010];int main()&#123; int n = Inp(); ll Sum = 0; for(int i = 1; i &lt;= n; i++)&#123; s[i].x = Inp(); Sum += s[i].x; s[i].k = i; &#125; std::sort(s + 1, s + n + 1, Cmp); int Cnt = 0; if(Sum - s[1].x - s[2].x == s[2].x) // 特判去掉1的情况 Ans[++Cnt] = s[1].k; for(int i = 2; i &lt;= n; i++)&#123; if(Sum - s[1].x - s[i].x == s[1].x) Ans[++Cnt] = s[i].k; &#125; printf(\"%d\\n\", Cnt); for(int i = 1; i &lt;= Cnt; i++) printf(\"%d \", Ans[i]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[]},{"title":"题解 洛谷P2547 [AHOI2004]DNA变异","slug":"Solutions/Solution-Luogu2547","date":"2018-10-24T02:00:00.000Z","updated":"2019-03-02T12:32:20.000Z","comments":true,"path":"2018/10/24/Solutions/Solution-Luogu2547/","link":"","permalink":"https://dilute.xyz/2018/10/24/Solutions/Solution-Luogu2547/","excerpt":"首先我作为一个蒟蒻，拿到字符串题，首先看看能不能无脑哈希 然后于是我们就发现了一个绝妙的做法：暴力枚举每个字符串能够转换成的字符串 于是我们就获得了$O(N * 8^4)$的优秀复杂度 显然会T飞QwQ 我们考虑再这个基础上进行优化","text":"首先我作为一个蒟蒻，拿到字符串题，首先看看能不能无脑哈希 然后于是我们就发现了一个绝妙的做法：暴力枚举每个字符串能够转换成的字符串 于是我们就获得了$O(N * 8^4)$的优秀复杂度 显然会T飞QwQ 我们考虑再这个基础上进行优化 我们会发现如果我们$O(8^4)$枚举的话，其中有一大部分枚举出来的状态都是重复的 那么我们思考：这其中有多少个状态是有用的呢 首先我们假设我们将$s_a, s_b$交换，$s_c, s_d$互换（$a,b,c,d\\in [1, 8] $, $a \\neq b \\neq c \\neq d$）同时我们令$a &lt; b $ 且 $c &lt; d$ 那么我们会发现最终只有$C_8^4 * 3$种可能是可行的 所以我们只需要把这些预处理出来，那么我们在后面枚举的时候只需要在这些状态中取就行了 最终复杂度$O(N * C_8^4 * 3 * 8)$，（最后的8是Hash的复杂度）佐以优秀的常数便可AC此题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// Sooke bless me.// LJC00118 bless me.#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 2147483647#define ll long longint Inp()&#123; char c = getchar(); register int Neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') Neg = -1; c = getchar(); &#125; register int Sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; Sum = ((Sum &lt;&lt; 3) + (Sum &lt;&lt; 1)) + c - '0'; c = getchar(); &#125; return Neg * Sum;&#125;string s[10010];bool Used[20];bool cg[10000000];inline int Hash(string s)&#123; int Sum = 0; for(int i = 0; i &lt; 8; i++)&#123; Sum &lt;&lt;= 2; switch(s[i])&#123; case 'A':&#123; Sum += 1; break; &#125; case 'C':&#123; Sum += 2; break; &#125; case 'T':&#123; Sum += 3; break; &#125; &#125; &#125; return Sum;&#125;int Hsh[10000];int sa[1010];int sb[1010];int C_swap;int main()&#123; register int n = Inp(); for(register int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i], Hsh[i] = Hash(s[i]); for(register int j1 = 0; j1 &lt; 8; j1++)&#123; Used[j1] = true; for(register int j2 = j1 + 1; j2 &lt; 8; j2++)&#123; if(Used[j2]) continue; Used[j2] = true; sa[++C_swap] = j1; sb[C_swap] = j2; Used[j2] = false; &#125; Used[j1] = false; &#125; register int Ans = 0; for(register int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= C_swap; j++) for(int u = j + 1; u &lt;= C_swap; u++)&#123; if(sa[j] == sa[u] || sb[j] == sb[u] || sa[j] == sb[u] || sb[j] == sa[u]) continue; string s2 = s[i]; swap(s2[sa[j]], s2[sb[j]]); swap(s2[sa[u]], s2[sb[u]]); cg[Hash(s2)] = true; &#125; for(register int j = i + 1; j &lt;= n; j++) if(cg[Hsh[j]]) Ans++, cg[Hsh[j]] = false; &#125; printf(\"%d\", Ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://dilute.xyz/tags/哈希/"},{"name":"字符串","slug":"字符串","permalink":"https://dilute.xyz/tags/字符串/"}]},{"title":"算法学习笔记-最小费用最大流","slug":"Notes/min-cost-max-flow","date":"2018-10-01T05:06:00.000Z","updated":"2019-03-02T12:29:24.000Z","comments":true,"path":"2018/10/01/Notes/min-cost-max-flow/","link":"","permalink":"https://dilute.xyz/2018/10/01/Notes/min-cost-max-flow/","excerpt":"前言某天我看到了memset0巨佬怒切17道网络流神仙题的时候，我顿时准备去做做看网络流24题以满足我内心的抖M之魂 于是，我这个蒟蒻看到某道费用流神题的时候，一脸懵逼地看着“费用流”的标签，决心去学一学这玩意","text":"前言某天我看到了memset0巨佬怒切17道网络流神仙题的时候，我顿时准备去做做看网络流24题以满足我内心的抖M之魂 于是，我这个蒟蒻看到某道费用流神题的时候，一脸懵逼地看着“费用流”的标签，决心去学一学这玩意 定义最小费用最大流（费用流）是在最大流的基础上，要求我们取到的总共需要的费用最小化。 同时每个边所消耗的费用都是与它这条边的流量成正比的 实现我们看一看增广路做最大流的做法（以Dinic为例） 首先，我们通过BFS确定是否拥有一条从源点流向汇点的增广路径，如果存在，说明当前搜到的不是最优解，继续进行，如果没有，退出程序 然后，如果我们要保证这条路径需要的费用最小化（将BFS改为SPFA，将DFS改为记录路径），便可以保证在我们搜到最优解的时候保证我们在保证流量最大的同时保证费用最小 证明$tan90^{O}$ 这种一个“感性理解”解决的东西需要严格证明吗？ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// Sooke bless me.// LJC00118 bless me.#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 2147483647#define ll long longint Inp()&#123; char c = getchar(); int Neg = 1; while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') Neg = -1; c = getchar(); &#125; int Sum = 0; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; Sum = ((Sum &lt;&lt; 3) + (Sum &lt;&lt; 1)) + c - '0'; c = getchar(); &#125; return Neg * Sum;&#125;int Head[5010];int Next[200010];int End[200010];int Value[200010];int Cost[200010];int Dis[5010];int Prev1[5010];int Prev2[5010];bool Inq[10000];int q[1000010];int Cou = -1;void Link(int a, int b, int v, int c)&#123; Next[++Cou] = Head[a]; Head[a] = Cou; End[Cou] = b; Value[Cou] = v; Cost[Cou] = c;&#125;int main()&#123; memset(Head, -1, sizeof(Head)); int n = Inp(); int m = Inp(); int s = Inp(); int e = Inp(); for(int i = 1; i &lt;= m; i++)&#123; int a = Inp(); int b = Inp(); int v1 = Inp(); int v2 = Inp(); Link(a, b, v1, v2); Link(b, a, 0, -v2); &#125; int Flow = 0; int Ans = 0; int f = INF; while(f &gt; 0)&#123; memset(Inq, false, sizeof(Inq)); for(int i = 1; i &lt;= n; i++) Dis[i] = INF; Dis[s] = 0; q[5000] = s; int qf = 5000; int qe = 5000; int Sum = 0; while(qf &lt;= qe)&#123; // SPFA（因为会有负权所以用SPFA） int u = q[qf++]; Inq[u] = false; Sum -= Dis[u]; for(int x = Head[u]; x != -1; x = Next[x])&#123; if(Value[x] &gt; 0 &amp;&amp; Dis[End[x]] &gt; Dis[u] + Cost[x])&#123; if(Inq[End[x]]) Sum -= Dis[End[x]]; Dis[End[x]] = Dis[u] + Cost[x]; Prev1[End[x]] = u; Prev2[End[x]] = x; Sum += Dis[End[x]]; if(!Inq[End[x]])&#123; q[++qe] = End[x]; Inq[End[x]] = true; &#125; &#125; &#125; &#125; if(Dis[e] == INF) break; int Delta = f; for(int i = e; i != s; i = Prev1[i]) Delta = min(Delta, Value[Prev2[i]]); f -= Delta; Flow += Delta; Ans += Delta * Dis[e]; for(int i = e; i != s; i = Prev1[i])&#123; Value[Prev2[i]] -= Delta; Value[Prev2[i] ^ 1] += Delta; &#125; &#125; printf(\"%d %d\", Flow, Ans);&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dilute.xyz/categories/学习笔记/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://dilute.xyz/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"https://dilute.xyz/tags/费用流/"}]},{"title":"算法学习笔记-单调队列","slug":"Notes/dandiao-queue","date":"2018-09-27T14:10:00.000Z","updated":"2019-03-02T12:28:00.000Z","comments":true,"path":"2018/09/27/Notes/dandiao-queue/","link":"","permalink":"https://dilute.xyz/2018/09/27/Notes/dandiao-queue/","excerpt":"前言单调队列一种非常经典的将O(n^2)的DP优化的O(n log n)的方式，在一个点可以更新一个范围的时候可以发挥很大作用。 记得当年NOIp2017我考PJ（那年的T4考到了单调队列），当时还不会，在考后听教练讲了一遍之后仍旧处于懵逼状态，大概1个月前照着题解打了一遍，但是到了现在已经忘得差不多了QwQ，于是写了一遍优化过的多重背包来练练手。","text":"前言单调队列一种非常经典的将O(n^2)的DP优化的O(n log n)的方式，在一个点可以更新一个范围的时候可以发挥很大作用。 记得当年NOIp2017我考PJ（那年的T4考到了单调队列），当时还不会，在考后听教练讲了一遍之后仍旧处于懵逼状态，大概1个月前照着题解打了一遍，但是到了现在已经忘得差不多了QwQ，于是写了一遍优化过的多重背包来练练手。 定义普及考完之后，我问Sooke大仙（如果T4开了longlong他就AK了）T4的做法，他跟我说：单调队列 我：（懵逼）单调队列是个啥子玩意儿 Sooke： 单调队列是一个队列，它具有单调性 是不是还是听不懂？那么我解释一下。 单调队列是一个队列（这不是废话吗QwQ），它里面的元素满足一个性质： 对于$i&lt;j$，一定满足$v_i &lt; v_j$ 并且 $k_i &lt; k_j$（v为一个点的DP值， k为点在DP数组中的位置） 这就是单调队列（你问它跟DP有设么关系？看下面的吧QwQ） 用法对于一个单调队列，你会发现如果一个要队中状态无法更关心当前扫到的这个状态，那么它也无法更新后面扫到的状态，（这个很容易证明）那么我们可以把这个状态丢掉，在通过这是最优的状态（队首元素）更新当前状态之后，将当前的状态加入队列然后继续往下扫 综上所述，一个比较精简的单调队列程序的核心部分就应该长成这样(伪代码)： 123456789for(int i = 1; i &lt;= n; i++)&#123; while(当前状态无用) qf++; while(如果加入当前状态会使队列不满足单调性) qe--; q[++qe] = 当前状态; if(q[qf] 更优于 f[i]) 更新f[i];&#125; 例题洛谷P3957 NOIP2017普及组T4 跳房子 我们看到这题之后，我们马上可以想到二分答案，在二分答案的Check()中可以加上一个DP 这题显然对于一个机器人的状态，它可以更新一个范围，所以大力套上单调队列即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int di[500100];int xi[500100];long long f[500100];int n;int q[1000100];int qf, qe;long long k;void Push(int x)&#123; while(f[q[qe]] &lt;= f[x] &amp;&amp; qe &gt;= qf) qe--; q[++qe] = x;&#125;long long check(int Min, int Max)&#123; for(int i = 1; i &lt;= n; i++) f[i] = -1000000000000000000; f[0] = 0; qf = 1; qe = 0; int kk = 0; q[1] = 0; for(int i = 1; i &lt;= n; i++)&#123; while(di[i] - di[kk] &gt;= Min &amp;&amp; kk &lt; i) Push(kk++); while(di[i] - di[q[qf]] &gt; Max &amp;&amp; qf &lt;= qe) qf++; // 把不符合区间的给出队 if(qf &gt; qe || f[q[qf]] == -1000000000000000000) continue; f[i] = f[q[qf]] + xi[i]; if(f[i] &gt;= k) return true; &#125; return false;&#125;inline void fopen()&#123; freopen(\"jump.in\", \"r\", stdin); freopen(\"jump.out\", \"w\", stdout);&#125;int main()&#123; //fopen(); //freopen(\"jump10.in\", \"r\", stdin); di[0] = 0; long long d; scanf(\"%d %d %lld\", &amp;n, &amp;d, &amp;k); int maxd = 0; long long sumx = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d %d\", &amp;di[i], &amp;xi[i]); if(xi[i] &gt; 0) sumx += xi[i]; if(di[i] &gt; maxd) maxd = di[i]; &#125; if(sumx &lt; k)&#123; printf(\"-1\"); return 0; &#125; int l = 0, r = maxd; while(l &lt; r)&#123; int mid = (l+r) / 2; if(check((d - mid &gt; 1 ? d - mid : 1), d+mid)) r = mid; else l = mid + 1; &#125; printf(\"%d\", l); return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dilute.xyz/categories/学习笔记/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"},{"name":"单调队列","slug":"单调队列","permalink":"https://dilute.xyz/tags/单调队列/"}]},{"title":"杭十三中冠军联赛S1 Extra Round 题解","slug":"Solutions/Solution-S1ExtraRound","date":"2018-09-26T06:11:00.000Z","updated":"2019-03-02T12:32:46.000Z","comments":true,"path":"2018/09/26/Solutions/Solution-S1ExtraRound/","link":"","permalink":"https://dilute.xyz/2018/09/26/Solutions/Solution-S1ExtraRound/","excerpt":"$$ \\texttt{ Writer：世界最蒻Dilute}$$$$\\texttt{ #A 某脱碳甲醛的电磁炮题}$$ $$\\texttt{ 出题人 Dilute}​$$ 电流公式$I=\\frac{U}{R}$大家都知道（不知道的话在题面中也给出了） 所以直接输出就可以了（ps：C++中除法自动向下取整）","text":"$$ \\texttt{ Writer：世界最蒻Dilute}$$$$\\texttt{ #A 某脱碳甲醛的电磁炮题}$$ $$\\texttt{ 出题人 Dilute}​$$ 电流公式$I=\\frac{U}{R}$大家都知道（不知道的话在题面中也给出了） 所以直接输出就可以了（ps：C++中除法自动向下取整） std by Dilute 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int U, R; scanf(\"%d %d\", &amp;U, &amp;R); int Ans = U / R; printf(\"%d\", Ans); return 0;&#125; $$\\texttt{ #B 黑子的瞬移范围}$$$$\\texttt{ 出题人 SLYZ_0120}​$$ 跟上一题差不多，但是坑点有二： 1.此题给定的是直径d而非半径r 2.保留3位输出需使用printf的%.3lf（具体看std） std by SLYZ_0120 123456789#include&lt;bits/stdc++.h&gt;using namespace std;int d;double s;int main()&#123; scanf(\"%d\",&amp;d); printf(\"%.3lf\",d*d*3.1415926/4); return 0;&#125; $$\\texttt{ #C 末日的时候有空吗？在干什么？可以来AK吗？}$$$$\\texttt{ 出题人 Dilute}​$$ 这可能是整场比赛代码最长的题？QwQ 由题目我们经过一番思考我们会想出来一个策略：先从较弱（即消耗法力值较小）的“兽”开始打，打倒无法再打下去为止 由此我们可以对表示$w_i$的序列排序再从前往后做即可 std by Dilute 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int w[10010];int main()&#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;w[i]); sort(w+1, w+n+1); // 排序 for(int i = 1; i &lt;= n; i++)&#123; m -= w[i]; // 消耗掉该“兽”所需要的法力值 if(m &lt;= 0)&#123; printf(\"%d\", i - 1); // 如果法力值耗尽，那么应该在第i - 1只“兽”就停止 return 0; &#125; &#125; printf(\"%d\", n); // 如果一直到最后都没有耗尽法力，那么久表示可以将所有“兽”杀死&#125; 我珂美如画！ $$\\texttt{ #D 打怪升级}$$$$\\texttt{ 出题人 SLYZ_0120}$$ 我们直接按照题意，模拟桐人和亚丝娜打怪升级的过程 教大家一个指令 $pow(a, b)$可以表示$a^b$即$a$的$b$次方 std by SLYZ_0120 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int n;int ans = 0;int main()&#123; scanf(\"%d\",&amp;n); for(int i = 1;i&lt;n;i++)&#123; ans += pow(2,i-1); &#125; ans *= 2; printf(\"%d\",ans); return 0;&#125; $$\\texttt{ #E 结构体排序}$$$$\\texttt{ 出题人 bh1234666}​$$ 第一种思路我们进行多次排序，首先以$a$为关键字，排序完成之后对于a相等的几个进行第二次排序，最后输出即可 std by bh1234666 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;struct paixu&#123; int a,b;&#125;a[100005];int cmp1(paixu x,paixu y)&#123; return x.a&lt;y.a;&#125;int cmp2(paixu x,paixu y)&#123; return x.b&lt;y.b;&#125;int main()&#123; int n,i; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) scanf(\"%d%d\",&amp;a[i].a,&amp;a[i].b); sort(a,a+n,cmp1); int flag=0; for(i=0;i&lt;n;i++) if(a[i].a!=a[flag].a) &#123; sort(a+flag,a+i,cmp2); flag=i; &#125; sort(a+flag,a+i,cmp2); for(i=0;i&lt;n;i++) printf(\"%d %d\\n\",a[i].a,a[i].b); return 0; &#125; 第二种思路其实只用一次排序就行了QwQ（只要在Cmp加入$a$相等的情况即可） std by Dilute 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;struct Node&#123; int a; int b;&#125;Num[100010];bool Cmp(Node a, Node b)&#123; if(a.a == b.a) return a.b &lt; b.b; return a.a &lt; b.a;&#125;int main()&#123; int n; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d %d\", &amp;Num[i].a, &amp;Num[i].b); sort(Num + 1, Num + n + 1, Cmp); for(int i = 1; i &lt;= n; i++) printf(\"%d %d\\n\", Num[i].a, Num[i].b);&#125; $$\\texttt{ #F 诡异的字符}$$$$\\texttt{ 出题人 bh1234666}$$ 这题非常不常规……（但是并不能改变这是道大水题的事实QwQ） 这题要求输出的字符串中有两个问题： 1.反斜杠\\这个字符在C++中是转义符，如果单单一个\\在字符串中会将后面的字符转义，从而导致我们不想要的效果，所以我们需要打两个\\让\\将自己转义（反斜杠转义后便是一个正常的字符）便可 2.双引号&quot;，如果你打在引号中的话程序会认为你这个引号是一个字符串的结尾从而导致问题，我们只要手动在定义字符串后将应该是&quot;的那个字符用ASCII码调整成双引号即可 std by bh1234666 123456789#include&lt;cstdio&gt;char a[]=\"!@#$%^&amp;*()[]&#123;&#125;;:' \\\\|,&lt;.&gt;/?`~-_=+`~\";int main()&#123; a[17]=34; // 双引号的ASC码为34 // 上面那行中的34等价于'\"' puts(a); return 0;&#125; $$\\texttt{ #G 身份证号}$$$$\\texttt{ 出题人 bh1234666}​$$ 不难得出字符串710位为年份，1112位为月份，13~14位为日期，那么把前面六位读进垃圾桶，再读进四位，输出刚刚读进的四位，输出空格，读进两位，输出刚刚读进的两位，再空格，最后读进两位，输出两位就行了 std by bh1234666 123456789101112131415161718192021222324#include&lt;cstdio&gt;int main()&#123; char x; scanf(\"%*c%*c%*c%*c%*c%*c%c\",&amp;x); printf(\"%c\",x); scanf(\"%c\",&amp;x); printf(\"%c\",x); scanf(\"%c\",&amp;x); printf(\"%c\",x); scanf(\"%c\",&amp;x); printf(\"%c\",x); printf(\" \"); scanf(\"%c\",&amp;x); printf(\"%c\",x); scanf(\"%c\",&amp;x); printf(\"%c\",x); printf(\" \"); scanf(\"%c\",&amp;x); printf(\"%c\",x); scanf(\"%c\",&amp;x); printf(\"%c\",x); return 0;&#125; 本场比赛的出题人们 Dilute 卢景行SLYZ_0120 杨茗bh1234666 包涵 最后，我想说 哦景真老师你真是太帅了！哦景真老师你真是太帅了！哦景真老师你真是太帅了！QwQ","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://dilute.xyz/tags/字符串/"},{"name":"模拟","slug":"模拟","permalink":"https://dilute.xyz/tags/模拟/"},{"name":"贪心","slug":"贪心","permalink":"https://dilute.xyz/tags/贪心/"}]},{"title":"题解 洛谷P4819 [中山市选]杀人游戏","slug":"Solutions/Solution-Luogu4819","date":"2018-08-29T08:00:00.000Z","updated":"2019-03-02T12:32:34.000Z","comments":true,"path":"2018/08/29/Solutions/Solution-Luogu4819/","link":"","permalink":"https://dilute.xyz/2018/08/29/Solutions/Solution-Luogu4819/","excerpt":"首先我们考虑一件事：如果存在一个人，使任何一个人都不认识，我们称这种人为“孤独”的人，那么警察只能通过调查他来取得他的身份。 然后对于一个不“孤独”的人，我们发现他们肯定至少被一个那些“孤独”的人直接或间接的认识。 所以我们得出结论：只要统计“孤独”的人的数量即可。 你照着这么做，就可以获得100 mod 10分的好成绩。","text":"首先我们考虑一件事：如果存在一个人，使任何一个人都不认识，我们称这种人为“孤独”的人，那么警察只能通过调查他来取得他的身份。 然后对于一个不“孤独”的人，我们发现他们肯定至少被一个那些“孤独”的人直接或间接的认识。 所以我们得出结论：只要统计“孤独”的人的数量即可。 你照着这么做，就可以获得100 mod 10分的好成绩。 那么为什么这不对呢？假设a认识b，就相当于在一个图中从a点向b点连一条边，这样就会造成一个问题：在这张图中会出现环 于是一旦出现环，我们就会发现只要调查环中的一个人，就可以知道环中所有人的身份，但是有可能环中每一个人都不被“孤独”的人间接认识，那么这样，我们可以使用Tarjan缩点，将一个环缩成一个点再进行一开始的算法。 你照着这么做，就可以获得21分的好成绩 那么这次问题又出在哪儿了呢？ 我们考虑以下情况 输入数据： 1100 0 如果按照我们原来的思路，那么我们的程序会输出0，但是实际上可能会怎样呢？ 警察来到了一个神奇的地方，这里的人们“鸡犬相闻，而民老死不相往来”（大雾），说白了就是谁都不认识 警察调查了前99个人，发现这99个人里面谁都不是杀手。 正在警察准备调查第100个人时，突然发现只剩一个人了，但是前99个人都不是杀手，所以最后一个人肯定是杀手，不用去调查了 我们瞎算一通，发现出现这种情况的概率是1%，所以我们原来的程序错了！ 那怎么办呢？ 对于一个入度为0的点，如果它在缩点前是一个点而不是一个环，并且与它相连的点入度都不为1（也就是说不调查这个人不会影响其他人的身份是否明了），那么这个点就可以不调查，但是只允许不调查1个这样的点（原因前面已经讲过了） 你照着这么做，就可以A了。 接下来上代码QAQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 200010#define MAXM 2000010int Dfn[MAXN];int Low[MAXN];int Stack[MAXN];int Top = 0;int Point[MAXN];bool Ins[MAXN];int Index;int Head[MAXN];int End[MAXM];int Next[MAXM];int Head2[MAXN];int End2[MAXM];int Next2[MAXM];bool Used[MAXN];int Dis[MAXN];int Degree[MAXN];int Cnt = 0;int Cou_p[MAXN]; void Tarjan(int Cur)&#123; // 以烈焰净化一切的环！（大雾） Dfn[Cur] = Low[Cur] = ++Index; Ins[Cur] = true; Stack[++Top] = Cur; for(int x = Head[Cur]; x != -1; x = Next[x])&#123; if(Dfn[End[x]] == -1)&#123; Tarjan(End[x]); if(Low[End[x]] &lt; Low[Cur]) Low[Cur] = Low[End[x]]; &#125; else if(Ins[End[x]] &amp;&amp; Dfn[End[x]] &lt; Low[Cur]) Low[Cur] = Dfn[End[x]]; &#125; if(Dfn[Cur] == Low[Cur])&#123; Cnt++; do&#123; Cou_p[Cnt]++; Point[Stack[Top]] = Cnt; Ins[Stack[Top]] = false; &#125;while(Stack[Top--] != Cur); &#125;&#125;int Cou = 0;void Link(int a, int b)&#123; // 连边 Next[++Cou] = Head[a]; Head[a] = Cou; End[Cou] = b;&#125;int Cou2 = 0;void Relink(int a, int b)&#123; // 重连边 Next2[++Cou2] = Head2[a]; Head2[a] = Cou2; End2[Cou2] = b;&#125;bool Single(int xx)&#123; for(int x = Head2[xx]; x != -1; x = Next2[x]) if(Degree[End2[x]] == 1) return false; return true;&#125;int main()&#123; memset(Head, -1, sizeof(Head)); memset(Head2, -1, sizeof(Head2)); memset(Dfn, -1, sizeof(Dfn)); int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++)&#123; int a, b; scanf(\"%d %d\", &amp;a, &amp;b); Link(a, b); &#125; for(int i = 1; i &lt;= n; i++) if(Dfn[i] == -1) Tarjan(i); for(int i = 1; i &lt;= n; i++) // 重建图 for(int x = Head[i]; x != -1; x = Next[x]) if(Point[i] != Point[End[x]])&#123; Relink(Point[i], Point[End[x]]); Degree[Point[End[x]]]++; &#125; int Ans = 0; bool Have_one = false; for(int i = 1; i &lt;= Cnt; i++)&#123; if(!Have_one &amp;&amp; Cou_p[i] == 1 &amp;&amp; Degree[i] == 0 &amp;&amp; Single(i)) // 是否可以使用“排除法” Have_one = true; if(Degree[i] == 0) Ans++; &#125; if(Have_one) Ans--; printf(\"%.6lf\", 1.0 - (double)Ans / (double)n);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"https://dilute.xyz/tags/Tarjan/"},{"name":"缩点","slug":"缩点","permalink":"https://dilute.xyz/tags/缩点/"},{"name":"拓扑","slug":"拓扑","permalink":"https://dilute.xyz/tags/拓扑/"}]},{"title":"题解 CF702E Analysis of Pathes in Functional Graph","slug":"Solutions/Solution-CF702E","date":"2018-08-21T08:05:00.000Z","updated":"2019-03-02T12:30:02.000Z","comments":true,"path":"2018/08/21/Solutions/Solution-CF702E/","link":"","permalink":"https://dilute.xyz/2018/08/21/Solutions/Solution-CF702E/","excerpt":"一道非常好的练倍增的题目思路很简单，就是倍增处理出每个点往后$2^i$个点的路径权值和与最小值，同时要注意一下$k​$要用longlong存，否则会挂掉 如果不会倍增的右转百度找其他博客去吧……我这里就不赘述了","text":"一道非常好的练倍增的题目思路很简单，就是倍增处理出每个点往后$2^i$个点的路径权值和与最小值，同时要注意一下$k​$要用longlong存，否则会挂掉 如果不会倍增的右转百度找其他博客去吧……我这里就不赘述了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;int Son[100010][50];long long Ans[100010][50];int Min[100010][50];long long Solve1(int Cur, long long k)&#123; // 求出Cur向后k条路径的权值和 if(k == 0) return 0; int xx = 0; long long x = 1; // 由于2 ^ xx 会爆int，所以应当开一个变量专门存 while(x &lt;= k) xx++, x &lt;&lt;= 1; xx--; x &gt;&gt;= 1; return Ans[Cur][xx] + Solve1(Son[Cur][xx], k - x); &#125;int Solve2(int Cur, long long k)&#123; // 求出Cur向后k条路径的权值最小值 if(k == 0) return 2147483647; int xx = 0; long long x = 1; // 与上面同理 while(x &lt;= k) xx++, x &lt;&lt;= 1; xx--; x &gt;&gt;= 1; return min(Min[Cur][xx], Solve2(Son[Cur][xx], k - x)); &#125;int main()&#123; int n; long long k; scanf(\"%d %I64d\", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;Son[i][0]); for(int i = 0; i &lt; n; i++) scanf(\"%I64d\", &amp;Ans[i][0]), Min[i][0] = Ans[i][0]; for(int t = 1; t &lt;= 40; t++) // 预处理出第2^i辈儿子 for(int i = 0; i &lt; n; i++) Son[i][t] = Son[Son[i][t-1]][t-1]; for(int t = 1; t &lt;= 40; t++) // 预处理往后$2^i$个点的路径权值之和 for(int i = 0; i &lt; n; i++) Ans[i][t] = Ans[i][t-1] + Ans[Son[i][t-1]][t-1]; for(int t = 1; t &lt;= 40; t++) // 预处理往后$2^i$个点的路径权值最小值 for(int i = 0; i &lt; n; i++) Min[i][t] = min(Min[i][t-1], Min[Son[i][t-1]][t-1]); for(int i = 0; i &lt; n; i++) printf(\"%I64d %d\\n\", Solve1(i, k), Solve2(i, k));&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"https://dilute.xyz/tags/倍增/"}]},{"title":"题解 洛谷P3045 [USACO12FEB]牛券Cow Coupons","slug":"Solutions/Solution-Luogu3045","date":"2018-08-03T08:24:00.000Z","updated":"2019-03-02T12:32:28.000Z","comments":true,"path":"2018/08/03/Solutions/Solution-Luogu3045/","link":"","permalink":"https://dilute.xyz/2018/08/03/Solutions/Solution-Luogu3045/","excerpt":"欧洲退火！没错你没有看错这么一道Heap的题我拿出了退火来做！ 那么模拟退火的基本思路这里不讲了如果要看右转P1337去看。 废话不多说，上思路","text":"欧洲退火！没错你没有看错这么一道Heap的题我拿出了退火来做！ 那么模拟退火的基本思路这里不讲了如果要看右转P1337去看。 废话不多说，上思路 这个思路有些类似P2503的思路，基本的操作就是_“交换”_，在这道题里就是把一个在以前的最优解中，把一个用了优惠券的牛的优惠券转而用到另一只没有用优惠券的牛身上。 而至于估价的话我们就采用贪心，直接取最便宜的几头牛就是了。 但是你会惊奇的发现如果这样你会死活调不出来，在WA与TLE之间挣扎，只有62分。 而且SA的过程中已经没有什么可以优化了，于是我们只能考虑在SA的过程外优化 自然而然联想到可以用一个错的离谱的贪心来选择初始状态 在这里我选用的是以$p_i + c_i$为关键字进行升序排序，于是就A了 AC记录 接下来上代码吧2333 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;struct Node&#123; int p; int c;&#125;s[60000];bool cmp(Node a, Node b)&#123; // 错误贪心排序 return (a.p + a.c) &lt; (b.p + b.c);&#125;bool Cpn[60000]; // 维护当前每头牛有没有用优惠券int Usc[60000]; // 用了优惠券的牛int Duc[60000]; // 没有用优惠券的牛int n, k;long long m;int Ans;int Calc()&#123; // 为当前状态估价 int Num[60000]; for(int i = 1; i &lt;= n; i++) Num[i] = Cpn[i] ? s[i].c : s[i].p; sort(Num+1, Num+n+1); int Ans = 0; long long Res = 0; for(int i = 1; Res &lt;= m &amp;&amp; i &lt;= n; i++)&#123; Res += (long long)Num[i]; Ans++; &#125; if(Res &lt;= m) return Ans; return Ans - 1;&#125;void SA()&#123; for(double Temp = 2000; Temp &gt;= 1; Temp *= 0.9)&#123; // 退火 int x = rand() % k + 1; // 在用了优惠券的牛里面选一头 int y = rand() % (n - k) + 1; // 在没用…… swap(Usc[x], Duc[y]); Cpn[Usc[x]] = true; Cpn[Duc[y]] = false; int Nxt = Calc(); int Del = Nxt - Ans; if(Del &gt; 0) Ans = Nxt; else if(exp(-(double)Del / Temp) * RAND_MAX * 2 &lt; rand())&#123; // 有概率接受一个更差解 swap(Usc[x], Duc[y]); Cpn[Usc[x]] = true; Cpn[Duc[y]] = false; &#125; &#125;&#125;int main()&#123; srand(20050426 + 20031119); // LJC00118 + Saofish的生日 scanf(\"%d %d %lld\", &amp;n, &amp;k, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(\"%d %d\", &amp;s[i].p, &amp;s[i].c); sort(s+1, s+n+1, cmp); // 玄学排序 for(int i = 1; i &lt;= k; i++)&#123; // 默认将前k个设为用了优惠券的 Usc[i] = i; Cpn[i] = true; &#125; for(int i = k+1; i &lt;= n; i++)&#123; // 其余的不用 Duc[i - k] = i; Cpn[i] = false; &#125; Ans = Calc(); // 为初始状态估价 SA(); // 退火 printf(\"%d\", Ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"骗分","slug":"骗分","permalink":"https://dilute.xyz/tags/骗分/"},{"name":"模拟退火","slug":"模拟退火","permalink":"https://dilute.xyz/tags/模拟退火/"}]},{"title":"题解 洛谷P4267 [USACO18FEB]Taming the Herd","slug":"Solutions/Solution-Luogu4267","date":"2018-07-31T12:40:00.000Z","updated":"2019-03-02T12:32:32.000Z","comments":true,"path":"2018/07/31/Solutions/Solution-Luogu4267/","link":"","permalink":"https://dilute.xyz/2018/07/31/Solutions/Solution-Luogu4267/","excerpt":"竟然没有人写题解2333那本蒟蒻就来$H_2O$一篇吧首先，看完题面不难想到DP，之后再看数据范围考虑$O(N^3)$DP，之后瞎搞一通可以想到 $f[i][j]$表示在前$i$个里面经历$k$次出逃可以取到最少的修改数 那么接下来我们就发现$f[i][j]$可以影响的范围为$f[u][j+1]$($i &lt; u ≤n$)，然后我们就可以写出如下的程序：","text":"竟然没有人写题解2333那本蒟蒻就来$H_2O$一篇吧首先，看完题面不难想到DP，之后再看数据范围考虑$O(N^3)$DP，之后瞎搞一通可以想到 $f[i][j]$表示在前$i$个里面经历$k$次出逃可以取到最少的修改数 那么接下来我们就发现$f[i][j]$可以影响的范围为$f[u][j+1]$($i &lt; u ≤n$)，然后我们就可以写出如下的程序： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int Num[110];int Cnt[110][110];int f[110][110]; // dp数组int main()&#123; memset(f, 127, sizeof(f)); // f数组初值极大 int n; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;Num[i]); /* * Cnt[i][j]表示如果第i天出逃那么到第j天如果改成输入的序列需要修改的次数 * 这里我们把Cnt预处理以下 */ for(int i = 0; i &lt;= n; i++)&#123; int Cou = 0; for(int j = i; j &lt;= n; j++)&#123; if(Num[j] != j - i) Cou++; Cnt[i][j] = Cou; &#125; &#125; // dp f[0][0] = 0; for(int i = 0; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) for(int u = i+1; u &lt;= n; u++) // 枚举f[i][j]可以更新的状态 if(f[u][j] &gt; f[i][j-1] + Cnt[i+1][u]) // 如果更优 f[u][j] = f[i][j-1] + Cnt[i+1][u]; // 不难看出答案就是f[n][1]……f[n][n] for(int i = 1; i &lt;= n; i++) printf(\"%d\\n\", f[n][i]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"}]},{"title":"题解 洛谷P1704 寻找最优美做题曲线","slug":"Solutions/Solution-Luogu1704","date":"2018-04-09T13:41:00.000Z","updated":"2019-03-02T12:32:18.000Z","comments":true,"path":"2018/04/09/Solutions/Solution-Luogu1704/","link":"","permalink":"https://dilute.xyz/2018/04/09/Solutions/Solution-Luogu1704/","excerpt":"暴力赛高！暴力是全世界最最最（以下省略2147483647个人最）NB的算法！AC记录这里似乎没有朴素的算法啊（啊当然Pascal不算哈） 我开始做题的时候还专门为了求稳去学习了一下$nlogn$的最长上升子序列呢 其实我们会发现，暴力的时间复杂度其实根本不是$O(n^2)$，就让我们来分析一下暴力的时间复杂度。","text":"暴力赛高！暴力是全世界最最最（以下省略2147483647个人最）NB的算法！AC记录这里似乎没有朴素的算法啊（啊当然Pascal不算哈） 我开始做题的时候还专门为了求稳去学习了一下$nlogn$的最长上升子序列呢 其实我们会发现，暴力的时间复杂度其实根本不是$O(n^2)$，就让我们来分析一下暴力的时间复杂度。 首先，读入，时间复杂度$O(n+k$)，即$O(n)$； 接下来，对必须做题的时间排序，复杂度$O(nlogn)$； 再下去，对每段进行最长上升子序列，在一般情况下$c_i$平均分布，复杂度为$O((n/k)^2 * k)$，即$O(n^2/k)$，但是，在某些奇葩的数据下，会出现这个复杂度退化为$O(n^2)$的情况，显然，这道题并没有这样的数据（啊当然NOIP的话你是可以看看CCF会不会出这种毒瘤数据，但是这种一般的题目出题人都是直接敲个随机生成就走人的）（不要问我为什么因为我自己出题就是这么干的）。 综上所述，暴力的时间复杂度为$O(n^2/k)$，似乎AC并没有多少问题。。。 上代码，具体的问题就看代码辣~~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt; // 万能头文件 using namespace std;bool cmp(int a, int b)&#123; // sort需要的比较函数 return a &lt; b;&#125;int Num[1100000]; // 题面中的c int f[1100000]; // 最长上升子序列的数组 int Get(int l, int r)&#123; // Get(l,r)表示从Num[l+1~r-1]这段的最长上升子序列 int Lbound = Num[l]; // 表示左边的边界，如果数要被放进最长上升子序列中必须要大于这个边界 int Rbound = Num[r]; // 表示右边的边界，如果数要被放进最长上升子序列中必须要小于这个边界 for(int i = l+1; i &lt; r; i++)&#123; // O(n^2)最长上升子序列应该不用我多说了吧 if(Num[i] &gt; Lbound &amp;&amp; Num[i] &lt; Rbound)&#123; // 判定这个数是否符合在两个边界之间的条件 f[i] = 1; for(int j = l+1; j &lt; i; j++)&#123; // 这里注意不要把l和r扫进去，会死得很惨 if(f[j] + 1 &gt; f[i] &amp;&amp; Num[j] &lt; Num[i]) f[i] = f[j]+1; &#125; &#125; &#125; int Ans = 0; for(int i = l+1; i &lt; r; i++)&#123; // 这个时候也是同理，别把l和r扫进去 if(f[i] &gt; Ans) Ans = f[i]; &#125; return Ans;&#125;int main()&#123; memset(f, 0, sizeof(f)); int n, k; //----------开始读入------------- scanf(\"%d %d\", &amp;n, &amp;k); int OI[500000]; for(int i = 1; i &lt;= k; i++)&#123; scanf(\"%d\", &amp;OI[i]); &#125; sort(OI+1, OI+k+1, cmp); for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\", &amp;Num[i]); &#125; //---------读入结束-------------- Num[0] = -1; // 注意一下这句话，因为我们要保证在0~第一个必须做题的天之内左边界为无限小 int Ans = k + Get(0, OI[1]); // 特判一下从0~c[1]之间的这段 for(int i = 1; i &lt; k; i++)&#123; // 扫一遍所有区间 Ans += Get(OI[i], OI[i+1]); // 加上这个区间的最长上升子序列长度 if(Num[OI[i]] &gt;= Num[OI[i+1]])&#123; // 特判：如果后面一个节点和前面一个节点并不严格单调，则无解 printf(\"impossible\"); return 0; &#125; &#125; Num[n+1] = 2147483647; // 和上面的同理（n+1是为了把最后一天扫进去） Ans += Get(OI[k], n+1); if(OI[1] == 0) Ans--; // 对于第七组数据的特判，看讨论里面所以加的，但是似乎是数据出错了。。。 printf(\"%d\", Ans); // 直接输出答案 return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://dilute.xyz/tags/DP/"},{"name":"骗分","slug":"骗分","permalink":"https://dilute.xyz/tags/骗分/"}]},{"title":"题解 洛谷P1396 营救","slug":"Solutions/Solution-Luogu1396","date":"2018-03-22T16:00:00.000Z","updated":"2019-03-02T12:32:16.000Z","comments":true,"path":"2018/03/23/Solutions/Solution-Luogu1396/","link":"","permalink":"https://dilute.xyz/2018/03/23/Solutions/Solution-Luogu1396/","excerpt":"令人智熄的二分操作AC记录 要看正常的解法请看其他题解 而且还蛮快的。。。 其实，这是非常奇葩的一个想法 总体思路就是：二分答案 你没听错，二分答案 我们从题面中可以看到，其实这道题的拥挤度也就$10000$而已，所以我们就会发现二分似乎可以？？？ 存图存完之后直接二分，二分的$Check()$里面打一个$BFS$，来求能否通往终点，就好了 具体的东西就上代码来看吧","text":"令人智熄的二分操作AC记录 要看正常的解法请看其他题解 而且还蛮快的。。。 其实，这是非常奇葩的一个想法 总体思路就是：二分答案 你没听错，二分答案 我们从题面中可以看到，其实这道题的拥挤度也就$10000$而已，所以我们就会发现二分似乎可以？？？ 存图存完之后直接二分，二分的$Check()$里面打一个$BFS$，来求能否通往终点，就好了 具体的东西就上代码来看吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt; // 万能头文件 using namespace std; // 邻接表存图 // 由于是无向图，所以这些数组要开大一倍，我就是这么被坑掉了10分 int End[50100]; // End[i]表示第i条边的终点 int Value[50100]; // Value[i]表示第i条边的边权 int Next[50100]; // Next[i]表示第i条边的下一条边 int Head[10100]; // Head[i]表示第i个点的第一条便 int q[50100]; // BFS的队列 int n, m, s, t; // 如题意 int qf, qe; // BFS队列的队首、队尾 bool Used[10100]; // BFS，表示是否到过这个点 bool Check(int x)&#123; memset(Used, false, sizeof(Used)); // 朴实无华的BFS qf = qe = 1; q[1] = s; Used[s] = true; while(qf &lt;= qe)&#123; int xx = Head[q[qf]]; while(xx != -1)&#123; if(!Used[End[xx]] &amp;&amp; Value[xx] &lt;= x)&#123; // 拓展 q[++qe] = End[xx]; Used[End[xx]] = true; &#125; xx = Next[xx]; &#125; qf++; // 出队 &#125; return Used[t]; // 返回终点有没有到过 &#125;int main()&#123; memset(Next, -1, sizeof(Next)); memset(Head, -1, sizeof(Head)); scanf(\"%d %d %d %d\", &amp;n, &amp;m, &amp;s, &amp;t); int r = 0; for(int i = 1; i &lt;= m; i++)&#123; // 读入、存图 int a, b, c; scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); Value[i*2] = c; End[i*2] = b; Next[i*2] = Head[a]; Head[a] = i*2; Value[i*2+1] = c; // 由于是无向图，所以要存两次 End[i*2+1] = a; Next[i*2+1] = Head[b]; Head[b] = i*2+1; if(c &gt; r) r = c; // 生成一个值等于所有最高拥挤度的r，方便二分 &#125; // ------------读入完毕--------------- // ------------二分开始--------------- r++; int l = 1; while(l &lt; r)&#123; // 同样朴素的二分~~~ int Mid = ((l+r) &gt;&gt; 1); if(Check(Mid)) r = Mid; else l = Mid+1; &#125; printf(\"%d\", l);&#125; 感谢 学委 对我的启发","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://dilute.xyz/tags/二分答案/"},{"name":"BFS","slug":"BFS","permalink":"https://dilute.xyz/tags/BFS/"}]},{"title":"题解 洛谷P2814 家谱","slug":"Solutions/Solution-Luogu2814","date":"2018-03-16T14:34:00.000Z","updated":"2019-03-02T12:32:22.000Z","comments":true,"path":"2018/03/16/Solutions/Solution-Luogu2814/","link":"","permalink":"https://dilute.xyz/2018/03/16/Solutions/Solution-Luogu2814/","excerpt":"STL大法好！（看到楼下的大佬们都没有用我这个方法，我就来脱碳甲醛一下辣~~） 以上都是废话 我所说的这个方法，具体思路是这样的： 最首先，基础的并查集大家应该都会，如果不会的话可以看代码或者出门右转P3367并查集模板 然后，STL中的Map可以直接方便地解决字符串哈希的问题 但是，每次都用一遍Map似乎显得有些不优美，似乎有些慢的说 所以，我们需要引进两个数组，一个Num和一个Names Num是一个Map，它的作用就是Num[“A”]表示名为A的人的编号 于是，Names就是反过来的Num，Name[i]表示编号为i的人的名字 总体而言，不仅加快了速度，还方便了调试","text":"STL大法好！（看到楼下的大佬们都没有用我这个方法，我就来脱碳甲醛一下辣~~） 以上都是废话 我所说的这个方法，具体思路是这样的： 最首先，基础的并查集大家应该都会，如果不会的话可以看代码或者出门右转P3367并查集模板 然后，STL中的Map可以直接方便地解决字符串哈希的问题 但是，每次都用一遍Map似乎显得有些不优美，似乎有些慢的说 所以，我们需要引进两个数组，一个Num和一个Names Num是一个Map，它的作用就是Num[“A”]表示名为A的人的编号 于是，Names就是反过来的Num，Name[i]表示编号为i的人的名字 总体而言，不仅加快了速度，还方便了调试 上代码~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt; // 万能头文件 using namespace std;int f[50100]; // 并查集，f[i]表示编号为i的人的祖先（可能是之一） map &lt;string, int&gt; Num; // 前面已经解释过了 string Names[50100]; // 同上 map &lt;string, bool&gt; Used; // 表示这个人有没有被加进Num数组里面 int Find(int x)&#123; // 找到编号为x的人最早的祖先（并查集的东西） if(f[x] == x) return x; int next = Find(f[x]); f[x] = next; // 路径压缩 return next;&#125;void Link(int Fa, int Son)&#123; // 将两个人连起来（把Son加到Fa的族谱下方） f[Son] = f[Find(Fa)];&#125;int main()&#123; string Name; // 当前这组父子关系中儿子的名字 string Fa; // Fa ♂乐♂器 （划掉）其实是表示当前这组父子关系中父亲的名字 char Type = 'A'; // 顾名思义，当前读入指令的种类 int Cur = 0; // 当前编号编到第几个 int Fanum; // 表示当前这组父子关系中父亲的编号 while(Type != '$')&#123; Type = getchar(); switch(Type)&#123; case '#':&#123; cin &gt;&gt; Fa; if(!Used[Fa])&#123; // 如果这人第一次出现，给他编个号 Used[Fa] = true; Num[Fa] = ++Cur; Names[Cur] = Fa; &#125; if(f[Num[Fa]] == 0) // 如果他没有祖先，将他的祖先定义为他自己 f[Cur] = Cur; Fanum = f[Num[Fa]]; break; &#125; case '+':&#123; cin &gt;&gt; Name; if(!Used[Name])&#123; // 如果这个人是第一次出现，给他编个号 Used[Name] = true; Num[Name] = ++Cur; Names[Cur] = Name; &#125; if(f[Num[Name]] == 0) // 如果他没有祖先，将他的祖先定义为他自己 f[Num[Name]] = Cur; Link(Fanum, Num[Name]); // 设定：他是他爸爸的儿子 break; &#125; case '?':&#123; // 问询操作：输出Name和Name最早的祖先 cin &gt;&gt; Name; cout &lt;&lt; Name &lt;&lt; \" \" &lt;&lt; Names[Find(Num[Name])]&lt;&lt; endl; break; &#125; default:break; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dilute.xyz/categories/题解/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://dilute.xyz/tags/哈希/"},{"name":"STL","slug":"STL","permalink":"https://dilute.xyz/tags/STL/"},{"name":"并查集","slug":"并查集","permalink":"https://dilute.xyz/tags/并查集/"}]}]}